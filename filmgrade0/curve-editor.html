<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FilmGrade Curve Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1e1e1e;
            color: #e0e0e0;
            padding: 20px;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
            color: #ffffff;
        }

        .main-layout {
            display: grid;
            grid-template-columns: 1fr 550px;
            gap: 30px;
            margin-bottom: 30px;
            align-items: start;
        }

        .curves-container {
            display: flex;
            flex-direction: column;
            gap: 30px;
            max-height: calc(100vh - 140px);
            overflow-y: auto;
            padding-right: 15px;
        }

        .curves-container::-webkit-scrollbar {
            width: 10px;
        }

        .curves-container::-webkit-scrollbar-track {
            background: #1a1a1a;
            border-radius: 5px;
        }

        .curves-container::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 5px;
        }

        .curves-container::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        .visualizations-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            background: #2d2d2d;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #444;
            position: sticky;
            top: 20px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
        }

        .visualizations-container::-webkit-scrollbar {
            width: 8px;
        }

        .visualizations-container::-webkit-scrollbar-track {
            background: #1a1a1a;
            border-radius: 4px;
        }

        .visualizations-container::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 4px;
        }

        .visualization-box {
            background: #1e1e1e;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #333;
        }

        .visualization-box h2 {
            font-size: 16px;
            margin-bottom: 8px;
            color: #e0e0e0;
        }

        .visualization-box p {
            font-size: 12px;
            color: #888;
            margin-bottom: 10px;
        }

        .curve-editor {
            background: #2d2d2d;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        .curve-editor h2 {
            margin-bottom: 15px;
            color: #4fc3f7;
            font-size: 18px;
        }

        .curve-info {
            margin-bottom: 10px;
            font-size: 14px;
            color: #b0b0b0;
        }

        canvas {
            width: 100%;
            background: #1a1a1a;
            border-radius: 4px;
            cursor: crosshair;
            display: block;
        }

        .curve-canvas {
            height: auto;
            aspect-ratio: 4/3;
            max-height: 900px;
        }

        .vectorscope-canvas {
            width: 100%;
            height: auto;
            margin: 0 auto;
            display: block;
        }

        .preview-canvas {
            height: 80px;
            cursor: default;
        }

        .controls {
            margin-top: 15px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .preset-controls {
            margin-bottom: 15px;
        }

        .preset-controls select {
            background: #1a1a1a;
            color: #e0e0e0;
            border: 1px solid #3d3d3d;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 14px;
            cursor: pointer;
            min-width: 200px;
        }

        button {
            background: #4fc3f7;
            color: #1e1e1e;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: background 0.2s;
        }

        button:hover {
            background: #6dd5ff;
        }

        button.danger {
            background: #e57373;
        }

        button.danger:hover {
            background: #ef5350;
        }

        button.secondary {
            background: #666666;
        }

        button.secondary:hover {
            background: #777777;
        }

        .point-editor {
            margin-top: 15px;
            background: #1a1a1a;
            border-radius: 4px;
            padding: 15px;
            max-height: 300px;
            overflow-y: auto;
        }

        .point-editor h3 {
            color: #4fc3f7;
            font-size: 14px;
            margin-bottom: 10px;
        }

        .point-row {
            display: grid;
            grid-template-columns: auto 1fr 1fr auto;
            gap: 10px;
            align-items: center;
            margin-bottom: 8px;
            padding: 8px;
            background: #2d2d2d;
            border-radius: 4px;
        }

        .point-row label {
            font-size: 12px;
            color: #b0b0b0;
        }

        .point-row input[type="number"] {
            background: #1a1a1a;
            color: #e0e0e0;
            border: 1px solid #3d3d3d;
            padding: 6px 8px;
            border-radius: 4px;
            font-size: 12px;
            width: 100%;
        }

        .point-row button {
            padding: 6px 10px;
            font-size: 12px;
        }

        .export-section {
            background: #2d2d2d;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            margin-bottom: 30px;
        }

        .export-section h2 {
            margin-bottom: 15px;
            color: #4fc3f7;
        }

        textarea {
            width: 100%;
            min-height: 200px;
            background: #1a1a1a;
            color: #e0e0e0;
            border: 1px solid #3d3d3d;
            border-radius: 4px;
            padding: 15px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px;
            resize: vertical;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .instructions {
            background: #2d2d2d;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 30px;
            border-left: 4px solid #4fc3f7;
        }

        .instructions h3 {
            color: #4fc3f7;
            margin-bottom: 10px;
        }

        .instructions ul {
            margin-left: 20px;
            line-height: 1.8;
        }

        .instructions li {
            color: #b0b0b0;
        }

        .visualization-box {
            background: #2d2d2d;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        .visualization-box h2 {
            margin-bottom: 15px;
            color: #4fc3f7;
            font-size: 18px;
        }

        .visualization-box p {
            font-size: 12px;
            color: #b0b0b0;
            margin-bottom: 10px;
        }

        .gradient-preview {
            margin-top: 15px;
        }

        .gradient-preview h3 {
            font-size: 14px;
            color: #4fc3f7;
            margin-bottom: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>FilmGrade Curve Editor</h1>

        <div class="instructions">
            <h3>How to Use</h3>
            <ul>
                <li><strong>Click</strong> on canvas to add control points</li>
                <li><strong>Drag</strong> points to adjust curve shape</li>
                <li><strong>Edit numbers</strong> in point editor for precise control</li>
                <li><strong>Right-click</strong> on a point to delete it</li>
                <li><strong>Load presets</strong> for common film looks</li>
                <li><strong>Vectorscopes</strong> show hue transformations in real-time</li>
                <li><strong>Density curves</strong> simulate film dye layers (Cyan/Magenta/Yellow)</li>
                <li><strong>Export DCTL</strong> generates code to paste into FilmGrade.dctl</li>
            </ul>
        </div>

        <div class="main-layout">
            <div class="curves-container">
                <!-- Sat to Hue Curve -->
                <div class="curve-editor">
                    <h2>Sat → Hue</h2>
                    <div class="curve-info">X: Saturation (0.0 - 1.0) | Y: Hue Shift (degrees)</div>

                    <div class="preset-controls">
                        <select id="sat-to-hue-preset" onchange="loadPreset('sat-to-hue', this.value)">
                            <option value="">-- Load Preset --</option>
                            <option value="neutral">Neutral</option>
                            <option value="kodak-5219">Kodak 5219 Vision3</option>
                            <option value="fuji-eterna">Fuji Eterna 500T</option>
                            <option value="ektachrome">Ektachrome E100</option>
                            <option value="agfa-xtr">Agfa XTR 100</option>
                            <option value="teal-orange">Teal & Orange</option>
                            <option value="bleach-bypass">Bleach Bypass</option>
                        </select>
                    </div>

                    <canvas id="sat-to-hue-canvas" class="curve-canvas" width="1200" height="900"></canvas>

                    <div class="gradient-preview">
                        <h3>Preview: Hue Ring Transformation</h3>
                        <canvas id="sat-to-hue-preview" class="preview-canvas" width="800" height="160"></canvas>
                    </div>

                    <div class="controls">
                        <button onclick="addPoint('sat-to-hue', 0.5, 0)">Add Point (0.5, 0)</button>
                        <button onclick="clearCurve('sat-to-hue')">Clear Curve</button>
                        <button onclick="resetCurve('sat-to-hue')">Reset to Linear</button>
                    </div>

                    <div class="point-editor" id="sat-to-hue-points"></div>
                </div>

                <!-- Lum to Hue Curve -->
                <div class="curve-editor">
                    <h2>Lum → Hue</h2>
                    <div class="curve-info">X: Luminance (0.0 - 1.0) | Y: Hue Shift (degrees)</div>

                    <div class="preset-controls">
                        <select id="lum-to-hue-preset" onchange="loadPreset('lum-to-hue', this.value)">
                            <option value="">-- Load Preset --</option>
                            <option value="neutral">Neutral</option>
                            <option value="kodak-5219">Kodak 5219 Vision3</option>
                            <option value="fuji-eterna">Fuji Eterna 500T</option>
                            <option value="ektachrome">Ektachrome E100</option>
                            <option value="agfa-xtr">Agfa XTR 100</option>
                            <option value="teal-orange">Teal & Orange</option>
                            <option value="bleach-bypass">Bleach Bypass</option>
                        </select>
                    </div>

                    <canvas id="lum-to-hue-canvas" class="curve-canvas" width="1200" height="900"></canvas>

                    <div class="gradient-preview">
                        <h3>Preview: Luminance to Hue Shift</h3>
                        <canvas id="lum-to-hue-preview" class="preview-canvas" width="800" height="160"></canvas>
                    </div>

                    <div class="controls">
                        <button onclick="addPoint('lum-to-hue', 0.5, 0)">Add Point (0.5, 0)</button>
                        <button onclick="clearCurve('lum-to-hue')">Clear Curve</button>
                        <button onclick="resetCurve('lum-to-hue')">Reset to Linear</button>
                    </div>

                    <div class="point-editor" id="lum-to-hue-points"></div>
                </div>

                <!-- Lum to Lum Curve -->
                <div class="curve-editor">
                    <h2>Lum → Lum</h2>
                    <div class="curve-info">X: Input Luminance (0.0 - 1.0) | Y: Output Luminance (0.0 - 1.0)</div>

                    <div class="preset-controls">
                        <select id="lum-to-lum-preset" onchange="loadPreset('lum-to-lum', this.value)">
                            <option value="">-- Load Preset --</option>
                            <option value="neutral">Neutral</option>
                            <option value="kodak-5219">Kodak 5219 Vision3</option>
                            <option value="fuji-eterna">Fuji Eterna 500T</option>
                            <option value="ektachrome">Ektachrome E100</option>
                            <option value="agfa-xtr">Agfa XTR 100</option>
                            <option value="teal-orange">Teal & Orange</option>
                            <option value="bleach-bypass">Bleach Bypass</option>
                        </select>
                    </div>

                    <canvas id="lum-to-lum-canvas" class="curve-canvas" width="1200" height="900"></canvas>

                    <div class="gradient-preview">
                        <h3>Preview: Tone Response</h3>
                        <canvas id="lum-to-lum-preview" class="preview-canvas" width="800" height="160"></canvas>
                    </div>

                    <div class="controls">
                        <button onclick="addPoint('lum-to-lum', 0.5, 0.5)">Add Point (0.5, 0.5)</button>
                        <button onclick="clearCurve('lum-to-lum')">Clear Curve</button>
                        <button onclick="resetCurve('lum-to-lum')">Reset to Linear</button>
                    </div>

                    <div class="point-editor" id="lum-to-lum-points"></div>
                </div>

                <!-- Red Density Curve (Cyan Dye Layer) -->
                <div class="curve-editor">
                    <h2>Red Density (Cyan Dye)</h2>
                    <div class="curve-info">X: Input Red (0.0 - 1.0) | Y: Output Red (0.0 - 1.0)</div>

                    <div class="preset-controls">
                        <select id="red-density-preset" onchange="loadPreset('red-density', this.value)">
                            <option value="">-- Load Preset --</option>
                            <option value="neutral">Neutral</option>
                            <option value="kodak-5219">Kodak 5219 Vision3</option>
                            <option value="fuji-eterna">Fuji Eterna 500T</option>
                            <option value="ektachrome">Ektachrome E100</option>
                            <option value="agfa-xtr">Agfa XTR 100</option>
                            <option value="teal-orange">Teal & Orange</option>
                            <option value="bleach-bypass">Bleach Bypass</option>
                        </select>
                    </div>

                    <canvas id="red-density-canvas" class="curve-canvas" width="1200" height="900"></canvas>

                    <div class="gradient-preview">
                        <h3>Preview: Red Channel Response</h3>
                        <canvas id="red-density-preview" class="preview-canvas" width="800" height="160"></canvas>
                    </div>

                    <div class="controls">
                        <button onclick="addPoint('red-density', 0.5, 0.5)">Add Point (0.5, 0.5)</button>
                        <button onclick="clearCurve('red-density')">Clear Curve</button>
                        <button onclick="resetCurve('red-density')">Reset to Linear</button>
                    </div>

                    <div class="point-editor" id="red-density-points"></div>
                </div>

                <!-- Green Density Curve (Magenta Dye Layer) -->
                <div class="curve-editor">
                    <h2>Green Density (Magenta Dye)</h2>
                    <div class="curve-info">X: Input Green (0.0 - 1.0) | Y: Output Green (0.0 - 1.0)</div>

                    <div class="preset-controls">
                        <select id="green-density-preset" onchange="loadPreset('green-density', this.value)">
                            <option value="">-- Load Preset --</option>
                            <option value="neutral">Neutral</option>
                            <option value="kodak-5219">Kodak 5219 Vision3</option>
                            <option value="fuji-eterna">Fuji Eterna 500T</option>
                            <option value="ektachrome">Ektachrome E100</option>
                            <option value="agfa-xtr">Agfa XTR 100</option>
                            <option value="teal-orange">Teal & Orange</option>
                            <option value="bleach-bypass">Bleach Bypass</option>
                        </select>
                    </div>

                    <canvas id="green-density-canvas" class="curve-canvas" width="1200" height="900"></canvas>

                    <div class="gradient-preview">
                        <h3>Preview: Green Channel Response</h3>
                        <canvas id="green-density-preview" class="preview-canvas" width="800" height="160"></canvas>
                    </div>

                    <div class="controls">
                        <button onclick="addPoint('green-density', 0.5, 0.5)">Add Point (0.5, 0.5)</button>
                        <button onclick="clearCurve('green-density')">Clear Curve</button>
                        <button onclick="resetCurve('green-density')">Reset to Linear</button>
                    </div>

                    <div class="point-editor" id="green-density-points"></div>
                </div>

                <!-- Blue Density Curve (Yellow Dye Layer) -->
                <div class="curve-editor">
                    <h2>Blue Density (Yellow Dye)</h2>
                    <div class="curve-info">X: Input Blue (0.0 - 1.0) | Y: Output Blue (0.0 - 1.0)</div>

                    <div class="preset-controls">
                        <select id="blue-density-preset" onchange="loadPreset('blue-density', this.value)">
                            <option value="">-- Load Preset --</option>
                            <option value="neutral">Neutral</option>
                            <option value="kodak-5219">Kodak 5219 Vision3</option>
                            <option value="fuji-eterna">Fuji Eterna 500T</option>
                            <option value="ektachrome">Ektachrome E100</option>
                            <option value="agfa-xtr">Agfa XTR 100</option>
                            <option value="teal-orange">Teal & Orange</option>
                            <option value="bleach-bypass">Bleach Bypass</option>
                        </select>
                    </div>

                    <canvas id="blue-density-canvas" class="curve-canvas" width="1200" height="900"></canvas>

                    <div class="gradient-preview">
                        <h3>Preview: Blue Channel Response</h3>
                        <canvas id="blue-density-preview" class="preview-canvas" width="800" height="160"></canvas>
                    </div>

                    <div class="controls">
                        <button onclick="addPoint('blue-density', 0.5, 0.5)">Add Point (0.5, 0.5)</button>
                        <button onclick="clearCurve('blue-density')">Clear Curve</button>
                        <button onclick="resetCurve('blue-density')">Reset to Linear</button>
                    </div>

                    <div class="point-editor" id="blue-density-points"></div>
                </div>
            </div>

            <!-- Visualizations Column -->
            <div class="visualizations-container">
                <!-- Sat to Hue Vectorscope -->
                <div class="visualization-box">
                    <h2>Sat → Hue Vectorscope</h2>
                    <p>Shows how saturation affects hue rotation. Outer ring = high saturation, inner ring = low saturation.</p>
                    <canvas id="sat-vectorscope" class="vectorscope-canvas" width="300" height="300"></canvas>
                </div>

                <!-- Lum to Hue Vectorscope -->
                <div class="visualization-box">
                    <h2>Lum → Hue Vectorscope</h2>
                    <p>Shows how luminance affects hue rotation. Outer ring = bright, inner ring = dark.</p>
                    <canvas id="lum-vectorscope" class="vectorscope-canvas" width="300" height="300"></canvas>
                </div>

                <!-- Combined Hue Wheel -->
                <div class="visualization-box">
                    <h2>Combined Hue Transformation</h2>
                    <p>Visual representation of final hue mapping after both Sat→Hue and Lum→Hue.</p>
                    <canvas id="combined-hue-wheel" class="vectorscope-canvas" width="300" height="300"></canvas>
                </div>

                <!-- Luminance Response -->
                <div class="visualization-box">
                    <h2>Luminance Response</h2>
                    <p>Tone curve showing input vs output luminance mapping.</p>
                    <canvas id="lum-response" class="vectorscope-canvas" width="300" height="300"></canvas>
                </div>

                <!-- Density Transform -->
                <div class="visualization-box">
                    <h2>Density Transform</h2>
                    <p>Shows how R/G/B density curves affect color (cyan/magenta/yellow dye layers).</p>
                    <canvas id="density-vectorscope" class="vectorscope-canvas" width="300" height="300"></canvas>
                </div>
            </div>
        </div>

        <div class="export-section">
            <h2>Export / Import</h2>
            <textarea id="export-output" readonly placeholder="Click 'Generate DCTL Code' to export your curves..."></textarea>
            <div class="button-group">
                <button onclick="generateDCTL()">Generate DCTL Code</button>
                <button onclick="copyToClipboard()">Copy to Clipboard</button>
                <button onclick="importFromDCTL()">Import from DCTL</button>
                <button class="secondary" onclick="saveToJSON()">Save Configuration (JSON)</button>
                <button class="secondary" onclick="loadFromJSON()">Load Configuration (JSON)</button>
            </div>
        </div>
    </div>

    <script>
        // Curve data storage
        const curves = {
            'sat-to-hue': {
                points: [{x: 0, y: 0}, {x: 1, y: 0}],
                yRange: [-30, 30],
                name: 'Sat → Hue',
                varName: 'sat_to_hue'
            },
            'lum-to-hue': {
                points: [{x: 0, y: 0}, {x: 1, y: 0}],
                yRange: [-30, 30],
                name: 'Lum → Hue',
                varName: 'lum_to_hue'
            },
            'lum-to-lum': {
                points: [{x: 0, y: 0}, {x: 1, y: 1}],
                yRange: [0, 1],
                name: 'Lum → Lum',
                varName: 'lum_to_lum'
            },
            'red-density': {
                points: [{x: 0, y: 0}, {x: 1, y: 1}],
                yRange: [0, 1],
                name: 'Red Density (Cyan Dye)',
                varName: 'red_density'
            },
            'green-density': {
                points: [{x: 0, y: 0}, {x: 1, y: 1}],
                yRange: [0, 1],
                name: 'Green Density (Magenta Dye)',
                varName: 'green_density'
            },
            'blue-density': {
                points: [{x: 0, y: 0}, {x: 1, y: 1}],
                yRange: [0, 1],
                name: 'Blue Density (Yellow Dye)',
                varName: 'blue_density'
            }
        };

        const presets = {
            'sat-to-hue': {
                'neutral': [{x: 0, y: 0}, {x: 1, y: 0}],
                'kodak-5219': [{x: 0, y: 0}, {x: 0.6, y: 3}, {x: 1, y: 8}],
                'fuji-eterna': [{x: 0, y: 0}, {x: 0.4, y: -4}, {x: 1, y: -8}],
                'ektachrome': [{x: 0, y: 0}, {x: 0.5, y: 5}, {x: 1, y: 18}],
                'agfa-xtr': [{x: 0, y: 0}, {x: 0.5, y: -3}, {x: 1, y: -6}],
                'teal-orange': [{x: 0, y: 0}, {x: 0.3, y: -15}, {x: 0.7, y: 10}, {x: 1, y: 5}],
                'bleach-bypass': [{x: 0, y: 0}, {x: 0.5, y: -8}, {x: 1, y: -15}],
                'warm-shift': [{x: 0, y: 0}, {x: 0.5, y: 10}, {x: 1, y: 15}],
                'cool-shift': [{x: 0, y: 0}, {x: 0.5, y: -10}, {x: 1, y: -15}]
            },
            'lum-to-hue': {
                'neutral': [{x: 0, y: 0}, {x: 1, y: 0}],
                'kodak-5219': [{x: 0, y: -5}, {x: 0.18, y: 0}, {x: 0.7, y: 6}, {x: 1, y: 10}],
                'fuji-eterna': [{x: 0, y: -12}, {x: 0.18, y: -3}, {x: 0.8, y: 2}, {x: 1, y: 5}],
                'ektachrome': [{x: 0, y: -10}, {x: 0.18, y: 0}, {x: 0.6, y: 8}, {x: 1, y: 15}],
                'agfa-xtr': [{x: 0, y: 2}, {x: 0.18, y: 1}, {x: 0.8, y: -2}, {x: 1, y: -4}],
                'teal-orange': [{x: 0, y: -20}, {x: 0.18, y: -8}, {x: 0.5, y: 0}, {x: 0.75, y: 12}, {x: 1, y: 18}],
                'bleach-bypass': [{x: 0, y: -6}, {x: 0.18, y: -4}, {x: 1, y: -2}]
            },
            'lum-to-lum': {
                'neutral': [{x: 0, y: 0}, {x: 1, y: 1}],
                'kodak-5219': [{x: 0, y: 0}, {x: 0.05, y: 0.08}, {x: 0.18, y: 0.21}, {x: 0.6, y: 0.65}, {x: 1, y: 1}],
                'fuji-eterna': [{x: 0, y: 0.02}, {x: 0.18, y: 0.22}, {x: 0.7, y: 0.72}, {x: 1, y: 0.96}],
                'ektachrome': [{x: 0, y: 0}, {x: 0.18, y: 0.16}, {x: 0.6, y: 0.68}, {x: 1, y: 1}],
                'agfa-xtr': [{x: 0, y: 0.04}, {x: 0.18, y: 0.24}, {x: 0.7, y: 0.74}, {x: 1, y: 0.94}],
                'teal-orange': [{x: 0, y: 0}, {x: 0.18, y: 0.15}, {x: 0.6, y: 0.72}, {x: 1, y: 1}],
                'bleach-bypass': [{x: 0, y: 0}, {x: 0.1, y: 0.05}, {x: 0.18, y: 0.14}, {x: 0.7, y: 0.8}, {x: 1, y: 1}]
            },
            'red-density': {
                'neutral': [{x: 0, y: 0}, {x: 1, y: 1}],
                'kodak-5219': [{x: 0, y: 0}, {x: 0.5, y: 0.48}, {x: 1, y: 1}],
                'fuji-eterna': [{x: 0, y: 0}, {x: 0.5, y: 0.52}, {x: 1, y: 1}],
                'ektachrome': [{x: 0, y: 0}, {x: 0.5, y: 0.46}, {x: 1, y: 1}],
                'agfa-xtr': [{x: 0, y: 0}, {x: 0.5, y: 0.49}, {x: 1, y: 1}],
                'teal-orange': [{x: 0, y: 0}, {x: 0.3, y: 0.26}, {x: 0.7, y: 0.75}, {x: 1, y: 1}],
                'bleach-bypass': [{x: 0, y: 0}, {x: 0.5, y: 0.46}, {x: 1, y: 1}]
            },
            'green-density': {
                'neutral': [{x: 0, y: 0}, {x: 1, y: 1}],
                'kodak-5219': [{x: 0, y: 0}, {x: 0.5, y: 0.50}, {x: 1, y: 1}],
                'fuji-eterna': [{x: 0, y: 0}, {x: 0.5, y: 0.48}, {x: 1, y: 1}],
                'ektachrome': [{x: 0, y: 0}, {x: 0.5, y: 0.51}, {x: 1, y: 1}],
                'agfa-xtr': [{x: 0, y: 0}, {x: 0.5, y: 0.52}, {x: 1, y: 1}],
                'teal-orange': [{x: 0, y: 0}, {x: 0.5, y: 0.48}, {x: 1, y: 1}],
                'bleach-bypass': [{x: 0, y: 0}, {x: 0.5, y: 0.47}, {x: 1, y: 1}]
            },
            'blue-density': {
                'neutral': [{x: 0, y: 0}, {x: 1, y: 1}],
                'kodak-5219': [{x: 0, y: 0}, {x: 0.5, y: 0.52}, {x: 1, y: 1}],
                'fuji-eterna': [{x: 0, y: 0}, {x: 0.5, y: 0.50}, {x: 1, y: 1}],
                'ektachrome': [{x: 0, y: 0}, {x: 0.5, y: 0.54}, {x: 1, y: 1}],
                'agfa-xtr': [{x: 0, y: 0}, {x: 0.5, y: 0.48}, {x: 1, y: 1}],
                'teal-orange': [{x: 0, y: 0}, {x: 0.3, y: 0.35}, {x: 0.7, y: 0.68}, {x: 1, y: 1}],
                'bleach-bypass': [{x: 0, y: 0}, {x: 0.5, y: 0.51}, {x: 1, y: 1}]
            }
        };

        let selectedPoint = null;
        let activeCanvas = null;

        // Initialize canvases
        function initCanvas(canvasId, curveKey) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');

            // Mouse events
            canvas.addEventListener('mousedown', (e) => handleMouseDown(e, canvas, curveKey));
            canvas.addEventListener('mousemove', (e) => handleMouseMove(e, canvas, curveKey));
            canvas.addEventListener('mouseup', (e) => handleMouseUp(e, canvas, curveKey));
            canvas.addEventListener('contextmenu', (e) => handleRightClick(e, canvas, curveKey));
            canvas.addEventListener('mouseleave', () => {
                selectedPoint = null;
                activeCanvas = null;
            });

            drawCurve(canvas, curveKey);
            updatePointEditor(curveKey);
        }

        // Convert canvas coordinates to curve coordinates
        function canvasToCurve(canvas, x, y, curveKey) {
            const rect = canvas.getBoundingClientRect();
            const canvasX = (x - rect.left) * (canvas.width / rect.width);
            const canvasY = (y - rect.top) * (canvas.height / rect.height);

            const padding = 60;
            const plotWidth = canvas.width - 2 * padding;
            const plotHeight = canvas.height - 2 * padding;

            const curve = curves[curveKey];
            const curveX = (canvasX - padding) / plotWidth;
            const curveY = curve.yRange[0] + (1 - (canvasY - padding) / plotHeight) * (curve.yRange[1] - curve.yRange[0]);

            return {
                x: Math.max(0, Math.min(1, curveX)),
                y: Math.max(curve.yRange[0], Math.min(curve.yRange[1], curveY))
            };
        }

        // Convert curve coordinates to canvas coordinates
        function curveToCanvas(canvas, point, curveKey) {
            const padding = 60;
            const plotWidth = canvas.width - 2 * padding;
            const plotHeight = canvas.height - 2 * padding;

            const curve = curves[curveKey];
            const canvasX = padding + point.x * plotWidth;
            const canvasY = padding + (1 - (point.y - curve.yRange[0]) / (curve.yRange[1] - curve.yRange[0])) * plotHeight;

            return { x: canvasX, y: canvasY };
        }

        // Draw curve on canvas
        function drawCurve(canvas, curveKey) {
            const ctx = canvas.getContext('2d');
            const curve = curves[curveKey];
            const padding = 60;
            const plotWidth = canvas.width - 2 * padding;
            const plotHeight = canvas.height - 2 * padding;

            // Clear canvas
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw grid
            ctx.strokeStyle = '#333333';
            ctx.lineWidth = 1;

            // Vertical grid lines
            for (let i = 0; i <= 10; i++) {
                const x = padding + (i / 10) * plotWidth;
                ctx.beginPath();
                ctx.moveTo(x, padding);
                ctx.lineTo(x, padding + plotHeight);
                ctx.stroke();
            }

            // Horizontal grid lines
            const ySteps = 10;
            for (let i = 0; i <= ySteps; i++) {
                const y = padding + (i / ySteps) * plotHeight;
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(padding + plotWidth, y);
                ctx.stroke();
            }

            // Draw axes
            ctx.strokeStyle = '#666666';
            ctx.lineWidth = 2;
            ctx.strokeRect(padding, padding, plotWidth, plotHeight);

            // Draw zero line (for hue curves)
            if (curve.yRange[0] < 0 && curve.yRange[1] > 0) {
                const zeroY = padding + (1 - (0 - curve.yRange[0]) / (curve.yRange[1] - curve.yRange[0])) * plotHeight;
                ctx.strokeStyle = '#555555';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(padding, zeroY);
                ctx.lineTo(padding + plotWidth, zeroY);
                ctx.stroke();
            }

            // Draw labels
            ctx.fillStyle = '#b0b0b0';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';

            // X-axis labels
            for (let i = 0; i <= 10; i += 2) {
                const x = padding + (i / 10) * plotWidth;
                ctx.fillText((i / 10).toFixed(1), x, canvas.height - 20);
            }

            // Y-axis labels
            ctx.textAlign = 'right';
            for (let i = 0; i <= 4; i++) {
                const y = padding + (i / 4) * plotHeight;
                const value = curve.yRange[1] - (i / 4) * (curve.yRange[1] - curve.yRange[0]);
                ctx.fillText(value.toFixed(1), padding - 10, y + 5);
            }

            // Sort points by x
            curve.points.sort((a, b) => a.x - b.x);

            // Draw curve using cubic spline
            if (curve.points.length >= 2) {
                ctx.strokeStyle = '#4fc3f7';
                ctx.lineWidth = 3;
                ctx.beginPath();

                for (let i = 0; i <= 200; i++) {
                    const x = i / 200;
                    const y = cubicSplineInterpolate(x, curve.points);
                    const canvasPos = curveToCanvas(canvas, {x, y}, curveKey);

                    if (i === 0) {
                        ctx.moveTo(canvasPos.x, canvasPos.y);
                    } else {
                        ctx.lineTo(canvasPos.x, canvasPos.y);
                    }
                }

                ctx.stroke();
            }

            // Draw control points
            curve.points.forEach((point, index) => {
                const canvasPos = curveToCanvas(canvas, point, curveKey);

                ctx.fillStyle = '#4fc3f7';
                ctx.beginPath();
                ctx.arc(canvasPos.x, canvasPos.y, 8, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = '#1e1e1e';
                ctx.lineWidth = 2;
                ctx.stroke();
            });
        }

        // Cubic spline interpolation (matches DCTL implementation)
        function cubicSplineInterpolate(x, points) {
            if (points.length === 0) return 0;
            if (points.length === 1) return points[0].y;
            if (x <= points[0].x) return points[0].y;
            if (x >= points[points.length - 1].x) return points[points.length - 1].y;

            // Find segment
            let i = 0;
            for (i = 0; i < points.length - 1; i++) {
                if (x >= points[i].x && x <= points[i + 1].x) break;
            }

            const x0 = points[i].x;
            const x1 = points[i + 1].x;
            const y0 = points[i].y;
            const y1 = points[i + 1].y;

            // Estimate derivatives using neighboring points
            let m0, m1;

            if (i === 0) {
                m0 = (y1 - y0) / (x1 - x0);
            } else {
                const x_prev = points[i - 1].x;
                const y_prev = points[i - 1].y;
                m0 = ((y1 - y0) / (x1 - x0) + (y0 - y_prev) / (x0 - x_prev)) / 2;
            }

            if (i === points.length - 2) {
                m1 = (y1 - y0) / (x1 - x0);
            } else {
                const x_next = points[i + 2].x;
                const y_next = points[i + 2].y;
                m1 = ((y_next - y1) / (x_next - x1) + (y1 - y0) / (x1 - x0)) / 2;
            }

            // Hermite basis functions
            const t = (x - x0) / (x1 - x0);
            const t2 = t * t;
            const t3 = t2 * t;

            const h00 = 2 * t3 - 3 * t2 + 1;
            const h10 = t3 - 2 * t2 + t;
            const h01 = -2 * t3 + 3 * t2;
            const h11 = t3 - t2;

            return h00 * y0 + h10 * (x1 - x0) * m0 + h01 * y1 + h11 * (x1 - x0) * m1;
        }

        // HSL to RGB conversion
        function hslToRgb(h, s, l) {
            h = h / 360;
            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;

            const hueToRgb = (p, q, t) => {
                if (t < 0) t += 1;
                if (t > 1) t -= 1;
                if (t < 1/6) return p + (q - p) * 6 * t;
                if (t < 1/2) return q;
                if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                return p;
            };

            return {
                r: Math.round(hueToRgb(p, q, h + 1/3) * 255),
                g: Math.round(hueToRgb(p, q, h) * 255),
                b: Math.round(hueToRgb(p, q, h - 1/3) * 255)
            };
        }

        // Draw gradient preview
        function drawGradientPreview(canvasId, curveKey) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            const curve = curves[curveKey];

            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const barHeight = canvas.height / 2;
            const barY1 = 10;
            const barY2 = barHeight + 20;

            // Draw before/after comparison
            for (let i = 0; i < canvas.width; i++) {
                const x = i / canvas.width;

                if (curveKey === 'lum-to-lum' || curveKey.includes('density')) {
                    // Luminance/density curves - show grayscale or channel gradient
                    const inputVal = Math.round(x * 255);
                    const outputVal = Math.round(cubicSplineInterpolate(x, curve.points) * 255);

                    if (curveKey === 'red-density') {
                        // Red channel only
                        ctx.fillStyle = `rgb(${inputVal}, 0, 0)`;
                        ctx.fillRect(i, barY1, 1, barHeight);
                        ctx.fillStyle = `rgb(${outputVal}, 0, 0)`;
                        ctx.fillRect(i, barY2, 1, barHeight);
                    } else if (curveKey === 'green-density') {
                        // Green channel only
                        ctx.fillStyle = `rgb(0, ${inputVal}, 0)`;
                        ctx.fillRect(i, barY1, 1, barHeight);
                        ctx.fillStyle = `rgb(0, ${outputVal}, 0)`;
                        ctx.fillRect(i, barY2, 1, barHeight);
                    } else if (curveKey === 'blue-density') {
                        // Blue channel only
                        ctx.fillStyle = `rgb(0, 0, ${inputVal})`;
                        ctx.fillRect(i, barY1, 1, barHeight);
                        ctx.fillStyle = `rgb(0, 0, ${outputVal})`;
                        ctx.fillRect(i, barY2, 1, barHeight);
                    } else {
                        // Lum to Lum - grayscale
                        ctx.fillStyle = `rgb(${inputVal}, ${inputVal}, ${inputVal})`;
                        ctx.fillRect(i, barY1, 1, barHeight);
                        ctx.fillStyle = `rgb(${outputVal}, ${outputVal}, ${outputVal})`;
                        ctx.fillRect(i, barY2, 1, barHeight);
                    }
                } else {
                    // Hue curves - show hue ring transformation
                    const inputHue = x * 360;
                    const hueShift = cubicSplineInterpolate(x, curve.points);
                    const outputHue = (inputHue + hueShift + 360) % 360;

                    const inputColor = hslToRgb(inputHue, 1, 0.5);
                    const outputColor = hslToRgb(outputHue, 1, 0.5);

                    ctx.fillStyle = `rgb(${inputColor.r}, ${inputColor.g}, ${inputColor.b})`;
                    ctx.fillRect(i, barY1, 1, barHeight);

                    ctx.fillStyle = `rgb(${outputColor.r}, ${outputColor.g}, ${outputColor.b})`;
                    ctx.fillRect(i, barY2, 1, barHeight);
                }
            }

            // Labels
            ctx.fillStyle = '#b0b0b0';
            ctx.font = '12px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('Input', 10, barY1 + barHeight / 2);
            ctx.fillText('Output', 10, barY2 + barHeight / 2);
        }

        // Draw vectorscope
        function drawVectorscope(canvasId, curveKey, isCombined = false) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            const centerX = w / 2;
            const centerY = h / 2;
            const radius = Math.min(centerX, centerY) - 30;

            // Black background (JP_2499 style)
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, w, h);

            // Subtle grid - 2 concentric circles for clarity
            ctx.strokeStyle = '#1a1a1a';
            ctx.lineWidth = 1;
            for (let i = 1; i <= 2; i++) {
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius * (i / 2), 0, Math.PI * 2);
                ctx.stroke();
            }

            // Hue spokes at primary/secondary hues
            const hueSpokes = [
                [0, 'R'], [60, 'Y'], [120, 'G'], [180, 'C'], [240, 'B'], [300, 'M']
            ];

            hueSpokes.forEach(([hue, label]) => {
                const angle = (hue - 90) * Math.PI / 180;
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(centerX + Math.cos(angle) * radius, centerY + Math.sin(angle) * radius);
                ctx.stroke();
            });

            // Draw dense hue/saturation point cloud
            const satCurve = curves['sat-to-hue'];
            const lumCurve = curves['lum-to-hue'];

            // Ensure points are sorted
            satCurve.points.sort((a, b) => a.x - b.x);
            lumCurve.points.sort((a, b) => a.x - b.x);

            // Dense sampling for smooth vectorscope
            for (let hue = 0; hue < 360; hue += 5) {
                for (let sat = 0.1; sat <= 1.0; sat += 0.1) {
                    let hueShift = 0;

                    if (curveKey === 'sat-to-hue') {
                        hueShift = cubicSplineInterpolate(sat, satCurve.points);
                    } else if (curveKey === 'lum-to-hue') {
                        // For lum-to-hue, use saturation as proxy for luminance
                        hueShift = cubicSplineInterpolate(sat, lumCurve.points);
                    } else if (isCombined) {
                        hueShift = cubicSplineInterpolate(sat, satCurve.points) +
                                   cubicSplineInterpolate(sat, lumCurve.points);
                    }

                    const outputHue = (hue + hueShift + 360) % 360;
                    const angle = (outputHue - 90) * Math.PI / 180;
                    const r = sat * radius;
                    const x = centerX + Math.cos(angle) * r;
                    const y = centerY + Math.sin(angle) * r;

                    // Color the point based on output hue
                    const color = hslToRgb(outputHue, sat, 0.5);
                    ctx.fillStyle = `rgb(${color.r}, ${color.g}, ${color.b})`;
                    ctx.fillRect(x - 1, y - 1, 2, 2);
                }
            }

            // Draw labels in subtle gray
            ctx.fillStyle = '#666';
            ctx.font = '14px monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            hueSpokes.forEach(([hue, label]) => {
                const angle = (hue - 90) * Math.PI / 180;
                const labelDist = radius - 15;
                const x = centerX + Math.cos(angle) * labelDist;
                const y = centerY + Math.sin(angle) * labelDist;
                ctx.fillText(label, x, y);
            });
        }

        // Draw luminance response visualization
        function drawLumResponse() {
            const canvas = document.getElementById('lum-response');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            const padding = 40;

            // Black background
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, w, h);

            const lumCurve = curves['lum-to-lum'];
            lumCurve.points.sort((a, b) => a.x - b.x);

            // Draw input gradient bar (bottom)
            const barHeight = 30;
            const barY = h - padding + 10;
            for (let i = 0; i < w - 2 * padding; i++) {
                const t = i / (w - 2 * padding);
                const gray = Math.floor(t * 255);
                ctx.fillStyle = `rgb(${gray}, ${gray}, ${gray})`;
                ctx.fillRect(padding + i, barY, 1, barHeight);
            }
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1;
            ctx.strokeRect(padding, barY, w - 2 * padding, barHeight);

            // Draw output gradient bar (left side, vertical) - transformed
            const barWidth = 30;
            const barX = padding - barWidth - 10;
            for (let i = 0; i < h - 2 * padding; i++) {
                const t = 1 - (i / (h - 2 * padding)); // inverted because canvas Y goes down
                const outputLum = cubicSplineInterpolate(t, lumCurve.points);
                const gray = Math.floor(outputLum * 255);
                ctx.fillStyle = `rgb(${gray}, ${gray}, ${gray})`;
                ctx.fillRect(barX, padding + i, barWidth, 1);
            }
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1;
            ctx.strokeRect(barX, padding, barWidth, h - 2 * padding);

            // Grid
            ctx.strokeStyle = '#1a1a1a';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const x = padding + (i / 4) * (w - 2 * padding);
                const y = padding + (i / 4) * (h - 2 * padding);
                ctx.beginPath();
                ctx.moveTo(x, padding);
                ctx.lineTo(x, h - padding);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(w - padding, y);
                ctx.stroke();
            }

            // Diagonal reference line
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(padding, h - padding);
            ctx.lineTo(w - padding, padding);
            ctx.stroke();
            ctx.setLineDash([]);

            // Draw curve
            ctx.strokeStyle = '#4a9eff';
            ctx.lineWidth = 3;
            ctx.beginPath();

            for (let i = 0; i <= 100; i++) {
                const t = i / 100;
                const outputLum = cubicSplineInterpolate(t, lumCurve.points);
                const x = padding + t * (w - 2 * padding);
                const y = h - padding - outputLum * (h - 2 * padding);

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();

            // Labels
            ctx.fillStyle = '#888';
            ctx.font = '11px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('Input', w / 2, barY + barHeight + 15);
            ctx.save();
            ctx.translate(barX + barWidth / 2, h / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Output', 0, 0);
            ctx.restore();
        }

        // Draw density transform vectorscope
        function drawDensityVectorscope() {
            const canvas = document.getElementById('density-vectorscope');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            const centerX = w / 2;
            const centerY = h / 2;
            const radius = Math.min(centerX, centerY) - 30;

            // Black background
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, w, h);

            // Grid - 2 concentric circles
            ctx.strokeStyle = '#1a1a1a';
            ctx.lineWidth = 1;
            for (let i = 1; i <= 2; i++) {
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius * (i / 2), 0, Math.PI * 2);
                ctx.stroke();
            }

            // Hue spokes
            const hueSpokes = [
                [0, 'R'], [60, 'Y'], [120, 'G'], [180, 'C'], [240, 'B'], [300, 'M']
            ];

            hueSpokes.forEach(([hue, label]) => {
                const angle = (hue - 90) * Math.PI / 180;
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(centerX + Math.cos(angle) * radius, centerY + Math.sin(angle) * radius);
                ctx.stroke();
            });

            // Get density curves
            const redCurve = curves['red-density'];
            const greenCurve = curves['green-density'];
            const blueCurve = curves['blue-density'];

            redCurve.points.sort((a, b) => a.x - b.x);
            greenCurve.points.sort((a, b) => a.x - b.x);
            blueCurve.points.sort((a, b) => a.x - b.x);

            // Draw color transformation points
            for (let hue = 0; hue < 360; hue += 2) {
                for (let sat = 0.1; sat <= 1.0; sat += 0.05) {
                    // Convert HSL to RGB
                    const inputColor = hslToRgb(hue, sat, 0.5);
                    const r = inputColor.r / 255;
                    const g = inputColor.g / 255;
                    const b = inputColor.b / 255;

                    // Apply density curves (simulating film dye layers)
                    const rOut = cubicSplineInterpolate(r, redCurve.points);
                    const gOut = cubicSplineInterpolate(g, greenCurve.points);
                    const bOut = cubicSplineInterpolate(b, blueCurve.points);

                    // Convert back to HSL to get output hue/saturation
                    const outputColor = rgbToHsl(rOut * 255, gOut * 255, bOut * 255);
                    const outputHue = outputColor.h;
                    const outputSat = outputColor.s;

                    const angle = (outputHue - 90) * Math.PI / 180;
                    const r_pos = outputSat * radius;
                    const x = centerX + Math.cos(angle) * r_pos;
                    const y = centerY + Math.sin(angle) * r_pos;

                    // Color by output
                    ctx.fillStyle = `rgb(${rOut*255}, ${gOut*255}, ${bOut*255})`;
                    ctx.fillRect(x - 1, y - 1, 2, 2);
                }
            }

            // Labels
            ctx.fillStyle = '#666';
            ctx.font = '14px monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            hueSpokes.forEach(([hue, label]) => {
                const angle = (hue - 90) * Math.PI / 180;
                const labelDist = radius - 15;
                const x = centerX + Math.cos(angle) * labelDist;
                const y = centerY + Math.sin(angle) * labelDist;
                ctx.fillText(label, x, y);
            });
        }

        // RGB to HSL helper
        function rgbToHsl(r, g, b) {
            r /= 255;
            g /= 255;
            b /= 255;

            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            const l = (max + min) / 2;
            let h, s;

            if (max === min) {
                h = s = 0;
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

                switch (max) {
                    case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                    case g: h = ((b - r) / d + 2) / 6; break;
                    case b: h = ((r - g) / d + 4) / 6; break;
                }
            }

            return { h: h * 360, s: s, l: l };
        }

        // Update all visualizations
        function updateAllVisualizations() {
            drawGradientPreview('sat-to-hue-preview', 'sat-to-hue');
            drawGradientPreview('lum-to-hue-preview', 'lum-to-hue');
            drawGradientPreview('lum-to-lum-preview', 'lum-to-lum');
            drawGradientPreview('red-density-preview', 'red-density');
            drawGradientPreview('green-density-preview', 'green-density');
            drawGradientPreview('blue-density-preview', 'blue-density');

            drawVectorscope('sat-vectorscope', 'sat-to-hue');
            drawVectorscope('lum-vectorscope', 'lum-to-hue');
            drawVectorscope('combined-hue-wheel', null, true);
            drawLumResponse();
            drawDensityVectorscope();
        }

        // Update point editor
        function updatePointEditor(curveKey) {
            const container = document.getElementById(curveKey + '-points');
            const curve = curves[curveKey];

            curve.points.sort((a, b) => a.x - b.x);

            container.innerHTML = '<h3>Control Points</h3>';

            curve.points.forEach((point, index) => {
                const row = document.createElement('div');
                row.className = 'point-row';

                const xPrecision = curveKey === 'lum-to-lum' ? 3 : 3;
                const yPrecision = curveKey === 'lum-to-lum' ? 3 : 1;

                row.innerHTML = `
                    <label>P${index + 1}</label>
                    <input type="number"
                           value="${point.x.toFixed(xPrecision)}"
                           step="0.01"
                           min="0"
                           max="1"
                           onchange="updatePointValue('${curveKey}', ${index}, 'x', this.value)">
                    <input type="number"
                           value="${point.y.toFixed(yPrecision)}"
                           step="${curveKey === 'lum-to-lum' ? '0.01' : '0.5'}"
                           min="${curve.yRange[0]}"
                           max="${curve.yRange[1]}"
                           onchange="updatePointValue('${curveKey}', ${index}, 'y', this.value)">
                    <button class="danger" onclick="deletePoint('${curveKey}', ${index})">Delete</button>
                `;

                container.appendChild(row);
            });
        }

        // Update point value from text input
        function updatePointValue(curveKey, index, axis, value) {
            const curve = curves[curveKey];
            const numValue = parseFloat(value);

            if (axis === 'x') {
                curve.points[index].x = Math.max(0, Math.min(1, numValue));
            } else {
                curve.points[index].y = Math.max(curve.yRange[0], Math.min(curve.yRange[1], numValue));
            }

            const canvas = document.getElementById(curveKey + '-canvas');
            drawCurve(canvas, curveKey);
            updatePointEditor(curveKey);
            updateAllVisualizations();
        }

        // Delete point
        function deletePoint(curveKey, index) {
            const curve = curves[curveKey];
            if (curve.points.length > 2) {
                curve.points.splice(index, 1);
                const canvas = document.getElementById(curveKey + '-canvas');
                drawCurve(canvas, curveKey);
                updatePointEditor(curveKey);
                updateAllVisualizations();
            }
        }

        // Add point programmatically
        function addPoint(curveKey, x, y) {
            curves[curveKey].points.push({x, y});
            const canvas = document.getElementById(curveKey + '-canvas');
            drawCurve(canvas, curveKey);
            updatePointEditor(curveKey);
            updateAllVisualizations();
        }

        // Mouse event handlers
        function handleMouseDown(e, canvas, curveKey) {
            const pos = canvasToCurve(canvas, e.clientX, e.clientY, curveKey);
            const curve = curves[curveKey];

            // Check if clicking on existing point
            selectedPoint = null;
            for (let i = 0; i < curve.points.length; i++) {
                const point = curve.points[i];
                const canvasPos = curveToCanvas(canvas, point, curveKey);
                const rect = canvas.getBoundingClientRect();
                const mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
                const mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);

                const dist = Math.sqrt((mouseX - canvasPos.x) ** 2 + (mouseY - canvasPos.y) ** 2);
                if (dist < 12) {
                    selectedPoint = i;
                    activeCanvas = curveKey;
                    break;
                }
            }

            // If not clicking on point, add new point
            if (selectedPoint === null) {
                curve.points.push(pos);
                drawCurve(canvas, curveKey);
                updatePointEditor(curveKey);
                updateAllVisualizations();
            }
        }

        function handleMouseMove(e, canvas, curveKey) {
            if (selectedPoint !== null && activeCanvas === curveKey) {
                const pos = canvasToCurve(canvas, e.clientX, e.clientY, curveKey);
                curves[curveKey].points[selectedPoint] = pos;
                drawCurve(canvas, curveKey);
                updatePointEditor(curveKey);
                updateAllVisualizations();
            }
        }

        function handleMouseUp(e, canvas, curveKey) {
            selectedPoint = null;
            activeCanvas = null;
        }

        function handleRightClick(e, canvas, curveKey) {
            e.preventDefault();
            const curve = curves[curveKey];

            // Find point to delete
            for (let i = 0; i < curve.points.length; i++) {
                const point = curve.points[i];
                const canvasPos = curveToCanvas(canvas, point, curveKey);
                const rect = canvas.getBoundingClientRect();
                const mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
                const mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);

                const dist = Math.sqrt((mouseX - canvasPos.x) ** 2 + (mouseY - canvasPos.y) ** 2);
                if (dist < 12) {
                    if (curve.points.length > 2) {
                        curve.points.splice(i, 1);
                        drawCurve(canvas, curveKey);
                        updatePointEditor(curveKey);
                        updateAllVisualizations();
                    }
                    break;
                }
            }
        }

        // Curve operations
        function clearCurve(curveKey) {
            curves[curveKey].points = [];
            const canvas = document.getElementById(curveKey + '-canvas');
            drawCurve(canvas, curveKey);
            updatePointEditor(curveKey);
            updateAllVisualizations();
        }

        function resetCurve(curveKey) {
            if (curveKey === 'lum-to-lum' || curveKey.includes('density')) {
                // Linear curves (diagonal)
                curves[curveKey].points = [{x: 0, y: 0}, {x: 1, y: 1}];
            } else {
                // Flat hue curves (horizontal)
                curves[curveKey].points = [{x: 0, y: 0}, {x: 1, y: 0}];
            }
            const canvas = document.getElementById(curveKey + '-canvas');
            drawCurve(canvas, curveKey);
            updatePointEditor(curveKey);
            updateAllVisualizations();
        }

        // Load preset
        function loadPreset(curveKey, presetName) {
            if (!presetName) return;

            const preset = presets[curveKey][presetName];
            if (preset) {
                curves[curveKey].points = JSON.parse(JSON.stringify(preset));
                const canvas = document.getElementById(curveKey + '-canvas');
                drawCurve(canvas, curveKey);
                updatePointEditor(curveKey);
                updateAllVisualizations();
            }

            // Reset dropdown
            document.getElementById(curveKey + '-preset').value = '';
        }

        // Generate DCTL code
        function generateDCTL() {
            let output = '// ============================================================================\n';
            output += '// FILMGRADE CUSTOM CURVES - Generated from Web App\n';
            output += '// ============================================================================\n';
            output += '// INSTRUCTIONS:\n';
            output += '// 1. Open FilmGrade.dctl in your text editor\n';
            output += '// 2. Find the section: "// 3. SELECT PRESET CURVES" (around line 672)\n';
            output += '// 3. Add this code AFTER the preset selection if/else block\n';
            output += '// 4. The curves will override the preset values\n';
            output += '// ============================================================================\n\n';

            output += '    // CUSTOM CURVES FROM WEB APP (paste after preset selection)\n';

            // Generate inline array declarations that override presets
            for (const [key, curve] of Object.entries(curves)) {
                const points = [];
                curve.points.sort((a, b) => a.x - b.x);

                for (const point of curve.points) {
                    points.push(`${point.x.toFixed(6)}f, ${point.y.toFixed(6)}f`);
                }

                output += `    float custom_${curve.varName}[] = {${points.join(', ')}};\n`;
            }

            output += '\n    // Override preset arrays with custom curves\n';
            for (const [key, curve] of Object.entries(curves)) {
                output += `    ${curve.varName} = custom_${curve.varName};\n`;
                output += `    ${curve.varName}_size = ${curve.points.length};\n`;
            }

            output += '\n// ============================================================================\n';
            output += '// END CUSTOM CURVES\n';
            output += '// ============================================================================\n\n';

            output += '// ALTERNATIVE: Replace __CONSTANT__ arrays at the top of the file\n';
            output += '// If you prefer to create permanent presets, replace the arrays at lines 567-648:\n\n';

            for (const [key, curve] of Object.entries(curves)) {
                output += `// ${curve.name}\n`;
                output += `__CONSTANT__ float custom_${curve.varName}[][2] = {\n`;

                const points = [];
                curve.points.sort((a, b) => a.x - b.x);

                for (const point of curve.points) {
                    points.push(`    {${point.x.toFixed(6)}f, ${point.y.toFixed(6)}f}`);
                }

                output += points.join(',\n');
                output += '\n};\n\n';
            }

            document.getElementById('export-output').value = output;
        }

        // Copy to clipboard
        function copyToClipboard() {
            const textarea = document.getElementById('export-output');
            textarea.select();
            document.execCommand('copy');
            alert('DCTL code copied to clipboard!');
        }

        // Import from DCTL
        function importFromDCTL() {
            const input = prompt('Paste DCTL curve data (arrays only):');
            if (!input) return;

            try {
                // Parse each curve array
                for (const [key, curve] of Object.entries(curves)) {
                    const regex = new RegExp(`float ${curve.varName}\\[\\]\\s*=\\s*\\{([^}]+)\\}`, 'i');
                    const match = input.match(regex);

                    if (match) {
                        const values = match[1].split(',').map(v => parseFloat(v.trim().replace('f', '')));
                        curve.points = [];

                        for (let i = 0; i < values.length; i += 2) {
                            if (i + 1 < values.length) {
                                curve.points.push({
                                    x: values[i],
                                    y: values[i + 1]
                                });
                            }
                        }

                        const canvas = document.getElementById(key + '-canvas');
                        drawCurve(canvas, key);
                        updatePointEditor(key);
                    }
                }

                updateAllVisualizations();
                alert('Curves imported successfully!');
            } catch (e) {
                alert('Error importing curves: ' + e.message);
            }
        }

        // Save configuration to JSON
        function saveToJSON() {
            const config = {
                version: '1.0',
                curves: {}
            };

            for (const [key, curve] of Object.entries(curves)) {
                config.curves[key] = {
                    points: curve.points,
                    name: curve.name
                };
            }

            const json = JSON.stringify(config, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = 'filmgrade-curves.json';
            a.click();

            URL.revokeObjectURL(url);
        }

        // Load configuration from JSON
        function loadFromJSON() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';

            input.onchange = (e) => {
                const file = e.target.files[0];
                const reader = new FileReader();

                reader.onload = (event) => {
                    try {
                        const config = JSON.parse(event.target.result);

                        for (const [key, data] of Object.entries(config.curves)) {
                            if (curves[key]) {
                                curves[key].points = data.points;
                                const canvas = document.getElementById(key + '-canvas');
                                drawCurve(canvas, key);
                                updatePointEditor(key);
                            }
                        }

                        updateAllVisualizations();
                        alert('Configuration loaded successfully!');
                    } catch (err) {
                        alert('Error loading configuration: ' + err.message);
                    }
                };

                reader.readAsText(file);
            };

            input.click();
        }

        // Initialize all canvases
        initCanvas('sat-to-hue-canvas', 'sat-to-hue');
        initCanvas('lum-to-hue-canvas', 'lum-to-hue');
        initCanvas('lum-to-lum-canvas', 'lum-to-lum');
        initCanvas('red-density-canvas', 'red-density');
        initCanvas('green-density-canvas', 'green-density');
        initCanvas('blue-density-canvas', 'blue-density');

        // Initial visualization draw
        updateAllVisualizations();
    </script>
</body>
</html>
