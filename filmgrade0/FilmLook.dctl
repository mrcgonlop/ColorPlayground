// FilmLook DCTL - Scene-Referred Film Look Development
// Works in DaVinci Wide Gamut Log, designed to complement OpenDRT
// Input: DWG Log to Output: DWG Log (pass to OpenDRT for display rendering)
//
// Based on FilmGrade.dctl hybrid approach:
// - Color pipeline: Linear Rec.709 working space (JP_2499 style)
// - Hue operations: Opponent color space (OpenDRT style)

// ============================================================================
// PRESET SYSTEM (loads starting values, then fully editable)
// ============================================================================

DEFINE_UI_PARAMS(preset, Film Look Preset, DCTLUI_COMBO_BOX, 1, {CUSTOM, NEUTRAL, KODAK_5219, FUJI_ETERNA, EKTACHROME, AGFA_XTR, TEAL_ORANGE, BLEACH_BYPASS}, {Custom, Neutral, Kodak 5219 Vision3, Fuji Eterna 500T, Ektachrome E100, Agfa XTR 100, Teal and Orange, Bleach Bypass})

// ============================================================================
// GLOBAL DENSITY
// ============================================================================

DEFINE_UI_PARAMS(enable_global_density, Enable Global Density, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(global_density, Global Density, DCTLUI_SLIDER_FLOAT, 1.0, 0.0, 1.5, 0.01)

// ============================================================================
// RGB DENSITY CURVES (Film Dye Layers)
// ============================================================================

DEFINE_UI_PARAMS(enable_density_curves, Enable RGB Density Curves, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(density_red_compress, Red Density Compression, DCTLUI_SLIDER_FLOAT, 0.0, -0.05, 0.05, 0.001)
DEFINE_UI_PARAMS(density_green_compress, Green Density Compression, DCTLUI_SLIDER_FLOAT, 0.0, -0.05, 0.05, 0.001)
DEFINE_UI_PARAMS(density_blue_compress, Blue Density Compression, DCTLUI_SLIDER_FLOAT, 0.0, -0.05, 0.05, 0.001)
DEFINE_UI_PARAMS(density_curves_mix, Density Curves Mix, DCTLUI_SLIDER_FLOAT, 1.0, 0.0, 1.0, 0.01)

// ============================================================================
// CHANNEL CROSSTALK
// ============================================================================

DEFINE_UI_PARAMS(enable_crosstalk, Enable Channel Crosstalk, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(crosstalk_rg, Red to Green, DCTLUI_SLIDER_FLOAT, 0.0, -0.3, 0.3, 0.01)
DEFINE_UI_PARAMS(crosstalk_rb, Red to Blue, DCTLUI_SLIDER_FLOAT, 0.0, -0.3, 0.3, 0.01)
DEFINE_UI_PARAMS(crosstalk_gr, Green to Red, DCTLUI_SLIDER_FLOAT, 0.0, -0.3, 0.3, 0.01)
DEFINE_UI_PARAMS(crosstalk_gb, Green to Blue, DCTLUI_SLIDER_FLOAT, 0.0, -0.3, 0.3, 0.01)
DEFINE_UI_PARAMS(crosstalk_br, Blue to Red, DCTLUI_SLIDER_FLOAT, 0.0, -0.3, 0.3, 0.01)
DEFINE_UI_PARAMS(crosstalk_bg, Blue to Green, DCTLUI_SLIDER_FLOAT, 0.0, -0.3, 0.3, 0.01)
DEFINE_UI_PARAMS(crosstalk_mix, Crosstalk Mix, DCTLUI_SLIDER_FLOAT, 1.0, 0.0, 1.0, 0.01)

// ============================================================================
// OVERALL HUE ROTATION (JP_2499 style)
// ============================================================================

DEFINE_UI_PARAMS(enable_overall_hue, Enable Overall Hue Rotation, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(overall_hue_r, Overall Hue R, DCTLUI_SLIDER_FLOAT, 0.0, -0.5, 0.5, 0.01)
DEFINE_UI_PARAMS(overall_hue_g, Overall Hue G, DCTLUI_SLIDER_FLOAT, 0.0, -0.5, 0.5, 0.01)
DEFINE_UI_PARAMS(overall_hue_b, Overall Hue B, DCTLUI_SLIDER_FLOAT, 0.0, -0.5, 0.5, 0.01)
DEFINE_UI_PARAMS(overall_hue_mix, Overall Hue Mix, DCTLUI_SLIDER_FLOAT, 1.0, 0.0, 1.0, 0.01)

// ============================================================================
// SAT TO HUE (Parametric)
// ============================================================================

DEFINE_UI_PARAMS(enable_sat_to_hue, Enable Sat to Hue, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(sat_hue_strength, Sat to Hue Strength deg, DCTLUI_SLIDER_FLOAT, 0.0, -30.0, 30.0, 0.5)
DEFINE_UI_PARAMS(sat_hue_peak, Sat to Hue Peak, DCTLUI_SLIDER_FLOAT, 0.7, 0.3, 1.0, 0.01)
DEFINE_UI_PARAMS(sat_hue_shape, Sat to Hue Shape, DCTLUI_SLIDER_FLOAT, 1.0, 0.3, 3.0, 0.01)
DEFINE_UI_PARAMS(sat_hue_mix, Sat to Hue Mix, DCTLUI_SLIDER_FLOAT, 1.0, 0.0, 1.0, 0.01)

// ============================================================================
// SAT TO HUE PER-ZONE (CMY)
// ============================================================================

DEFINE_UI_PARAMS(enable_hue_zone_sat_cmy, Enable CMY Sat to Hue, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(sat_hue_cyan, Sat to Hue Cyan deg, DCTLUI_SLIDER_FLOAT, 0.0, -30.0, 30.0, 0.5)
DEFINE_UI_PARAMS(sat_hue_magenta, Sat to Hue Magenta deg, DCTLUI_SLIDER_FLOAT, 0.0, -30.0, 30.0, 0.5)
DEFINE_UI_PARAMS(sat_hue_yellow, Sat to Hue Yellow deg, DCTLUI_SLIDER_FLOAT, 0.0, -30.0, 30.0, 0.5)

// ============================================================================
// SAT TO HUE PER-ZONE (RGB)
// ============================================================================

DEFINE_UI_PARAMS(enable_hue_zone_sat_rgb, Enable RGB Sat to Hue, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(sat_hue_red, Sat to Hue Red deg, DCTLUI_SLIDER_FLOAT, 0.0, -30.0, 30.0, 0.5)
DEFINE_UI_PARAMS(sat_hue_green, Sat to Hue Green deg, DCTLUI_SLIDER_FLOAT, 0.0, -30.0, 30.0, 0.5)
DEFINE_UI_PARAMS(sat_hue_blue, Sat to Hue Blue deg, DCTLUI_SLIDER_FLOAT, 0.0, -30.0, 30.0, 0.5)

// ============================================================================
// LUM TO HUE (Parametric)
// ============================================================================

DEFINE_UI_PARAMS(enable_lum_to_hue, Enable Lum to Hue, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(shadow_hue_shift, Shadow Hue Shift deg, DCTLUI_SLIDER_FLOAT, 0.0, -30.0, 30.0, 0.5)
DEFINE_UI_PARAMS(highlight_hue_shift, Highlight Hue Shift deg, DCTLUI_SLIDER_FLOAT, 0.0, -30.0, 30.0, 0.5)
DEFINE_UI_PARAMS(lum_hue_midpoint, Lum to Hue Midpoint, DCTLUI_SLIDER_FLOAT, 0.18, 0.05, 0.5, 0.01)
DEFINE_UI_PARAMS(lum_hue_smoothness, Lum to Hue Smoothness, DCTLUI_SLIDER_FLOAT, 2.0, 0.3, 5.0, 0.1)
DEFINE_UI_PARAMS(lum_hue_mix, Lum to Hue Mix, DCTLUI_SLIDER_FLOAT, 1.0, 0.0, 1.0, 0.01)

// ============================================================================
// LUM TO HUE PER-ZONE (CMY)
// ============================================================================

DEFINE_UI_PARAMS(enable_hue_zone_lum_cmy, Enable CMY Lum to Hue, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(lum_hue_cyan, Lum to Hue Cyan deg, DCTLUI_SLIDER_FLOAT, 0.0, -30.0, 30.0, 0.5)
DEFINE_UI_PARAMS(lum_hue_magenta, Lum to Hue Magenta deg, DCTLUI_SLIDER_FLOAT, 0.0, -30.0, 30.0, 0.5)
DEFINE_UI_PARAMS(lum_hue_yellow, Lum to Hue Yellow deg, DCTLUI_SLIDER_FLOAT, 0.0, -30.0, 30.0, 0.5)

// ============================================================================
// LUM TO HUE PER-ZONE (RGB)
// ============================================================================

DEFINE_UI_PARAMS(enable_hue_zone_lum_rgb, Enable RGB Lum to Hue, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(lum_hue_red, Lum to Hue Red deg, DCTLUI_SLIDER_FLOAT, 0.0, -30.0, 30.0, 0.5)
DEFINE_UI_PARAMS(lum_hue_green, Lum to Hue Green deg, DCTLUI_SLIDER_FLOAT, 0.0, -30.0, 30.0, 0.5)
DEFINE_UI_PARAMS(lum_hue_blue, Lum to Hue Blue deg, DCTLUI_SLIDER_FLOAT, 0.0, -30.0, 30.0, 0.5)

// ============================================================================
// LUM TO LUM (Scene-Referred Contrast)
// ============================================================================

DEFINE_UI_PARAMS(enable_lum_to_lum, Enable Lum to Lum, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(contrast, Contrast, DCTLUI_SLIDER_FLOAT, 1.0, 0.5, 2.0, 0.01)
DEFINE_UI_PARAMS(toe_lift, Toe Lift, DCTLUI_SLIDER_FLOAT, 0.0, 0.0, 0.2, 0.01)
DEFINE_UI_PARAMS(shoulder_softness, Shoulder Softness, DCTLUI_SLIDER_FLOAT, 0.0, 0.0, 0.3, 0.01)
DEFINE_UI_PARAMS(lum_pivot, Luminance Pivot, DCTLUI_SLIDER_FLOAT, 0.18, 0.05, 0.5, 0.01)
DEFINE_UI_PARAMS(lum_to_lum_mix, Lum to Lum Mix, DCTLUI_SLIDER_FLOAT, 1.0, 0.0, 1.0, 0.01)

// ============================================================================
// PURITY (Scene-Referred Saturation)
// ============================================================================

DEFINE_UI_PARAMS(enable_purity, Enable Purity, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(purity_red, Purity Red, DCTLUI_SLIDER_FLOAT, 0.0, -0.5, 0.5, 0.01)
DEFINE_UI_PARAMS(purity_green, Purity Green, DCTLUI_SLIDER_FLOAT, 0.0, -0.5, 0.5, 0.01)
DEFINE_UI_PARAMS(purity_blue, Purity Blue, DCTLUI_SLIDER_FLOAT, 0.0, -0.5, 0.5, 0.01)
DEFINE_UI_PARAMS(purity_mix, Purity Mix, DCTLUI_SLIDER_FLOAT, 1.0, 0.0, 1.0, 0.01)

// ============================================================================
// ADVANCED
// ============================================================================

DEFINE_UI_PARAMS(use_moment_saturation, Use Moment Space Saturation, DCTLUI_CHECK_BOX, 0)

// ============================================================================
// MATRIX DEFINITIONS & HELPER FUNCTIONS
// ============================================================================

typedef struct {
    float3 x, y, z;
} float3x3;

__DEVICE__ float3x3 make_float3x3(float3 a, float3 b, float3 c) {
    float3x3 m;
    m.x = a; m.y = b; m.z = c;
    return m;
}

#define matrix_davinciwg_to_xyz \
    make_float3x3(make_float3(0.700622320175f, 0.148774802685f, 0.101058728993f), \
                  make_float3(0.274118483067f, 0.873631775379f, -0.147750422359f), \
                  make_float3(-0.098962903023f, -0.137895315886f, 1.325916051865f))

#define matrix_xyz_to_rec709 \
    make_float3x3(make_float3(3.2409699419f, -1.53738317757f, -0.498610760293f), \
                  make_float3(-0.969243636281f, 1.87596750151f, 0.041555057407f), \
                  make_float3(0.055630079697f, -0.203976958889f, 1.05697151424f))

#define matrix_rec709_to_xyz \
    make_float3x3(make_float3(0.412390917540f, 0.357584357262f, 0.180480793118f), \
                  make_float3(0.212639078498f, 0.715168714523f, 0.072192311287f), \
                  make_float3(0.019330825657f, 0.119194783270f, 0.950532138348f))

#define matrix_xyz_to_davinciwg \
    make_float3x3(make_float3(1.51690828f, -0.30806916f, -0.15530531f), \
                  make_float3(-0.46917558f, 1.31930816f, 0.15153047f), \
                  make_float3(0.07168483f, 0.08814808f, 0.75964379f))

__DEVICE__ inline float3x3 inv_f33(float3x3 m) {
    float d = m.x.x * (m.y.y * m.z.z - m.z.y * m.y.z) -
              m.x.y * (m.y.x * m.z.z - m.y.z * m.z.x) +
              m.x.z * (m.y.x * m.z.y - m.y.y * m.z.x);
    float id = 1.0f / d;
    float3x3 c;
    c.x.x = id * (m.y.y * m.z.z - m.z.y * m.y.z);
    c.x.y = id * (m.x.z * m.z.y - m.x.y * m.z.z);
    c.x.z = id * (m.x.y * m.y.z - m.x.z * m.y.y);
    c.y.x = id * (m.y.z * m.z.x - m.y.x * m.z.z);
    c.y.y = id * (m.x.x * m.z.z - m.x.z * m.z.x);
    c.y.z = id * (m.y.x * m.x.z - m.x.x * m.y.z);
    c.z.x = id * (m.y.x * m.z.y - m.z.x * m.y.y);
    c.z.y = id * (m.z.x * m.x.y - m.x.x * m.z.y);
    c.z.z = id * (m.x.x * m.y.y - m.y.x * m.x.y);
    return c;
}

__DEVICE__ inline float3 vdot(float3x3 m, float3 v) {
    return make_float3(
        m.x.x * v.x + m.x.y * v.y + m.x.z * v.z,
        m.y.x * v.x + m.y.y * v.y + m.y.z * v.z,
        m.z.x * v.x + m.z.y * v.y + m.z.z * v.z);
}

__DEVICE__ inline float max3(float x, float y, float z) {
    return _fmaxf(x, _fmaxf(y, z));
}

__DEVICE__ inline float3 maxf3(float b, float3 a) {
    return make_float3(_fmaxf(a.x, b), _fmaxf(a.y, b), _fmaxf(a.z, b));
}

__DEVICE__ inline float _sign(float x) {
    if (x > 0.0f) return 1.0f;
    if (x < 0.0f) return -1.0f;
    return 0.0f;
}

__DEVICE__ inline float spowf(float a, float b) {
    return _sign(a) * _powf(_fabs(a), b);
}

__DEVICE__ inline float smoothstep(float edge0, float edge1, float x) {
    float t = _fmaxf(0.0f, _fminf(1.0f, (x - edge0) / (edge1 - edge0)));
    return t * t * (3.0f - 2.0f * t);
}

__DEVICE__ inline float smootherstep(float edge0, float edge1, float x) {
    float t = _fmaxf(0.0f, _fminf(1.0f, (x - edge0) / (edge1 - edge0)));
    return t * t * t * (t * (t * 6.0f - 15.0f) + 10.0f);
}

__DEVICE__ inline float gaussian_falloff(float x, float center, float width) {
    float t = (x - center) / width;
    return _expf(-0.5f * t * t);
}

__DEVICE__ inline float oetf_davinci_intermediate(float x, int inv) {
    const float A = 0.0075f;
    const float B = 7.0f;
    const float C = 0.07329248f;
    const float M = 10.44426855f;
    const float LIN_CUT = 0.00262409f;
    const float LOG_CUT = 0.02740668f;

    if (inv == 1) {
        return x <= LOG_CUT ? x / M : _exp2f(x / C - B) - A;
    } else {
        return x <= LIN_CUT ? x * M : (_log2f(x + A) + B) * C;
    }
}

__DEVICE__ inline float3x3 transpose_f33(float3x3 A) {
    float3x3 B;
    B.x = make_float3(A.x.x, A.y.x, A.z.x);
    B.y = make_float3(A.x.y, A.y.y, A.z.y);
    B.z = make_float3(A.x.z, A.y.z, A.z.z);
    return B;
}

__DEVICE__ inline float3 avgweights(float3x3 mt) {
    float3 weights = vdot(mt, make_float3(1.0f, 1.0f, 1.0f));
    mt.x /= weights.x;
    mt.y /= weights.y;
    mt.z /= weights.z;
    mt = transpose_f33(mt);
    weights = make_float3(
        mt.x.x + mt.x.y + mt.x.z,
        mt.y.x + mt.y.y + mt.y.z,
        mt.z.x + mt.z.y + mt.z.z
    );
    weights /= 3.0f;
    return weights;
}

__DEVICE__ inline float3x3 crosstalkMatrix(float rg, float rb, float gr, float gb, float br, float bg) {
    float3 redcoeff   = make_float3(1.0f, gr, br);
    float3 greencoeff = make_float3(rg, 1.0f, bg);
    float3 bluecoeff  = make_float3(rb, gb, 1.0f);
    return make_float3x3(redcoeff, greencoeff, bluecoeff);
}

__DEVICE__ inline float3x3 simpleHueMatrix(float red, float green, float blue) {
    float3 redcoeff = make_float3(1.0f, green > 0.0f ? green : 0.0f, blue < 0.0f ? -blue : 0.0f);
    float3 greencoeff = make_float3(red > 0.0f ? red : 0.0f, 1.0f, blue > 0.0f ? blue : 0.0f);
    float3 bluecoeff = make_float3(red < 0.0f ? -red : 0.0f, green < 0.0f ? -green : 0.0f, 1.0f);

    float3 white;
    white.x = 1.0f + redcoeff.y + redcoeff.z;
    white.y = greencoeff.x + 1.0f + greencoeff.z;
    white.z = bluecoeff.x + bluecoeff.y + 1.0f;

    redcoeff = redcoeff / white.x;
    greencoeff = greencoeff / white.y;
    bluecoeff = bluecoeff / white.z;

    return make_float3x3(redcoeff, greencoeff, bluecoeff);
}

__DEVICE__ inline float3x3 simpleInsetMatrix(float red, float green, float blue, int inv) {
    float gain_coef = 1.0f + red + green + blue;
    float3 redcoeff = make_float3(1.0f + red, green, blue) / gain_coef;
    float3 greencoeff = make_float3(red, 1.0f + green, blue) / gain_coef;
    float3 bluecoeff = make_float3(red, green, 1.0f + blue) / gain_coef;
    float3x3 M = make_float3x3(redcoeff, greencoeff, bluecoeff);
    M = inv ? inv_f33(M) : M;
    return M;
}

__DEVICE__ inline float satmask(float3 rgb) {
    float3x3 inset = simpleInsetMatrix(0.1f, 0.7f, 0.2f, 0);
    rgb = vdot(inset, rgb);
    float avg = (rgb.x + rgb.y + rgb.z) / 3.0f;
    float saturation = avg == 0.0f ? 0.0f :
        _sqrtf((rgb.x - avg) * (rgb.x - avg) +
               (rgb.y - avg) * (rgb.y - avg) +
               (rgb.z - avg) * (rgb.z - avg)) / (2.0f * avg);
    return saturation;
}

__DEVICE__ inline float2 opponent(float3 rgb) {
    return make_float2(rgb.x - rgb.z, rgb.y - (rgb.x + rgb.z) / 2.0f);
}

__DEVICE__ inline float3 opponent_to_rgb(float2 opp, float lum) {
    float b = lum - opp.y / 3.0f - opp.x / 2.0f;
    float r = b + opp.x;
    float g = opp.y + (r + b) / 2.0f;
    return make_float3(r, g, b);
}

__DEVICE__ inline float achromatic_distance(float2 opp) {
    return _sqrtf(_fmaxf(0.0f, opp.x * opp.x + opp.y * opp.y)) / 2.0f;
}

__DEVICE__ inline float2 rotate_hue(float2 opp, float rotation) {
    float radius = _sqrtf(_fmaxf(0.0f, opp.x * opp.x + opp.y * opp.y));
    if (radius < 1e-6f) return opp;
    float hue = _atan2f(opp.y, opp.x);
    hue += rotation;
    return make_float2(radius * _cosf(hue), radius * _sinf(hue));
}

__DEVICE__ inline float3 get_hue_zone_weights_cmy(float2 opp) {
    const float PI = 3.14159265359f;
    float hue = _atan2f(opp.y, opp.x);
    float hue_deg = hue * 180.0f / PI;
    if (hue_deg < 0.0f) hue_deg += 360.0f;

    float weight_cyan = gaussian_falloff(hue_deg, 180.0f, 80.0f);
    float weight_yellow = gaussian_falloff(hue_deg, 60.0f, 80.0f);
    if (hue_deg > 300.0f) weight_yellow += gaussian_falloff(hue_deg - 360.0f, 60.0f, 80.0f);
    float weight_magenta = gaussian_falloff(hue_deg, 300.0f, 80.0f);

    float total = weight_cyan + weight_magenta + weight_yellow;
    if (total > 0.001f) {
        weight_cyan /= total;
        weight_magenta /= total;
        weight_yellow /= total;
    }
    return make_float3(weight_cyan, weight_magenta, weight_yellow);
}

__DEVICE__ inline float3 get_hue_zone_weights_rgb(float2 opp) {
    const float PI = 3.14159265359f;
    float hue = _atan2f(opp.y, opp.x);
    float hue_deg = hue * 180.0f / PI;
    if (hue_deg < 0.0f) hue_deg += 360.0f;

    float weight_red = gaussian_falloff(hue_deg, 0.0f, 80.0f);
    if (hue_deg > 300.0f) weight_red += gaussian_falloff(hue_deg - 360.0f, 0.0f, 80.0f);
    float weight_green = gaussian_falloff(hue_deg, 120.0f, 80.0f);
    float weight_blue = gaussian_falloff(hue_deg, 240.0f, 80.0f);

    float total = weight_red + weight_green + weight_blue;
    if (total > 0.001f) {
        weight_red /= total;
        weight_green /= total;
        weight_blue /= total;
    }
    return make_float3(weight_red, weight_green, weight_blue);
}

// ============================================================================
// PARAMETRIC CURVE FUNCTIONS
// ============================================================================

__DEVICE__ float parametric_sat_to_hue(float sat, float strength, float peak, float shape) {
    if (_fabs(strength) < 0.01f) return 0.0f;
    float x = _fminf(sat / _fmaxf(peak, 0.01f), 2.0f);
    float t = _fminf(x, 1.0f);
    t = smootherstep(0.0f, 1.0f, t);
    float curve = _powf(t, 1.0f / _fmaxf(shape, 0.1f));
    if (x > 1.0f) {
        float overshoot = x - 1.0f;
        float decay = 1.0f - smootherstep(0.0f, 1.0f, _fminf(overshoot, 1.0f)) * 0.3f;
        curve *= decay;
    }
    return curve * strength;
}

__DEVICE__ float parametric_lum_to_hue(float lum, float shadow_shift, float highlight_shift,
                                        float midpoint, float smoothness) {
    float t = (lum - midpoint) / (_fmaxf(smoothness * midpoint, 0.01f));
    float blend = 0.5f + 0.5f * _tanhf(t);
    blend = smootherstep(0.0f, 1.0f, blend);
    return shadow_shift * (1.0f - blend) + highlight_shift * blend;
}

// FIXED: RGB Density - works in log space to preserve hue
__DEVICE__ float parametric_density_curve(float x, float compression) {
    if (_fabs(compression) < 0.0001f) return x;

    // Work in log space to preserve hue relationships
    // This simulates film dye density which is logarithmic
    float safe_x = _fmaxf(x, 0.0001f);
    float log_x = _log2f(safe_x);

    // Apply compression in log space
    // compression > 0: adds density (darkens)
    // compression < 0: removes density (brightens)
    float log_result = log_x - compression * 5.0f;

    // Back to linear
    float result = _exp2f(log_result);

    return _fmaxf(result, 0.0f);
}

__DEVICE__ float parametric_lum_to_lum(float lum, float contrast, float toe_lift,
                                        float shoulder_softness, float pivot) {
    float x = _fmaxf(lum, 0.0f) / _fmaxf(pivot, 0.01f);
    float y = _powf(x, contrast);
    float out = y * pivot;

    if (toe_lift > 0.0f) {
        float toe_blend = gaussian_falloff(lum, 0.0f, 0.1f);
        out = out + toe_lift * toe_blend;
    }

    if (shoulder_softness > 0.0f) {
        float shoulder_start = 0.7f;
        float shoulder_blend = smootherstep(shoulder_start, 1.0f, lum);
        float compression_amount = shoulder_softness * 0.5f;
        float compressed = 1.0f - (1.0f - out) * (1.0f - compression_amount * shoulder_blend);
        out = out * (1.0f - shoulder_blend) + compressed * shoulder_blend;
    }

    return _fmaxf(out, 0.0f);
}

// ============================================================================
// PRESET REFERENCE VALUES
// ============================================================================
//
// To use presets in DaVinci Resolve:
// 1. Select a preset name from dropdown (currently just labels)
// 2. Manually set the sliders to the values listed below for that preset
// 3. Right-click the preset dropdown and select "Save Preset" to store your values
//
// NEUTRAL (preset 1):
//   All sliders at default/zero values
//
// KODAK 5219 Vision3 (preset 2):
//   Sat to Hue Strength: 8.0, Shadow Hue: -5.0, Highlight Hue: 10.0
//   Contrast: 1.08, Toe Lift: 0.04, Shoulder Softness: 0.015
//   Red Density: -0.012, Blue Density: 0.012
//
// FUJI Eterna 500T (preset 3):
//   Sat to Hue Strength: -8.0, Peak: 0.6, Shadow Hue: -12.0, Highlight: 5.0
//   Contrast: 0.95, Toe Lift: 0.02
//   Red Density: 0.012, Green Density: -0.012
//
// EKTACHROME E100 (preset 4):
//   Sat to Hue Strength: 15.0, Shape: 1.2, Shadow: -10.0, Highlight: 15.0
//   Contrast: 1.15
//   Red Density: -0.025, Green: 0.006, Blue: 0.025
//
// AGFA XTR 100 (preset 5):
//   Sat to Hue Strength: -6.0, Shadow: 2.0, Highlight: -4.0
//   Contrast: 0.92, Toe Lift: 0.025
//   Red Density: -0.008, Green: 0.012, Blue: -0.012
//   Purity Red: -0.08, Green: 0.08, Blue: -0.08
//
// TEAL & ORANGE (preset 6):
//   Sat to Hue Strength: 5.0, Shadow: -20.0, Highlight: 18.0, Smoothness: 3.0
//   Contrast: 1.12
//   Red Density: -0.028, Green: -0.012, Blue: 0.028
//
// BLEACH BYPASS (preset 7):
//   Sat to Hue Strength: -12.0, Shadow: -6.0, Highlight: -2.0
//   Contrast: 1.25
//   Red Density: -0.025, Green: -0.020, Blue: 0.008
//   Purity Red: -0.18, Green: -0.18, Blue: -0.12
//
// ============================================================================

// ============================================================================
// MAIN TRANSFORM
// ============================================================================

__DEVICE__ float3 transform(int p_Width, int p_Height, int p_X, int p_Y, float p_R, float p_G, float p_B) {

    float3 rgb = make_float3(p_R, p_G, p_B);

    // LOG TO LINEAR
    rgb.x = oetf_davinci_intermediate(rgb.x, 1);
    rgb.y = oetf_davinci_intermediate(rgb.y, 1);
    rgb.z = oetf_davinci_intermediate(rgb.z, 1);

    // DWG TO REC.709
    rgb = vdot(matrix_davinciwg_to_xyz, rgb);
    rgb = vdot(matrix_xyz_to_rec709, rgb);

    // GLOBAL DENSITY
    if (enable_global_density) {
        float satm = satmask(rgb);
        float density_multiplier = _powf(1.0f / (1.0f + 0.5f * satm * satm), global_density);
        rgb *= density_multiplier;
    }

    // CHANNEL CROSSTALK
    if (enable_crosstalk) {
        float3 rgb_pre = rgb;
        float3x3 ct_matrix = crosstalkMatrix(crosstalk_rg, crosstalk_rb, crosstalk_gr,
                                              crosstalk_gb, crosstalk_br, crosstalk_bg);
        rgb = vdot(ct_matrix, rgb);
        rgb = rgb_pre + (rgb - rgb_pre) * crosstalk_mix;
    }

    // OVERALL HUE ROTATION
    if (enable_overall_hue) {
        float3 rgb_pre = rgb;
        float3x3 hue_matrix = simpleHueMatrix(overall_hue_r, overall_hue_g, overall_hue_b);
        rgb = vdot(hue_matrix, rgb);
        rgb = rgb_pre + (rgb - rgb_pre) * overall_hue_mix;
    }

    // RGB DENSITY CURVES
    if (enable_density_curves) {
        float3 rgb_pre = rgb;
        rgb.x = parametric_density_curve(rgb.x, density_red_compress);
        rgb.y = parametric_density_curve(rgb.y, density_green_compress);
        rgb.z = parametric_density_curve(rgb.z, density_blue_compress);
        rgb = rgb_pre + (rgb - rgb_pre) * density_curves_mix;
        rgb = maxf3(0.0f, rgb);
    }

    // OPPONENT SPACE HUE OPERATIONS
    float2 opp = opponent(rgb);
    float lum = (rgb.x + rgb.y + rgb.z) / 3.0f;

    float sat;
    if (use_moment_saturation) {
        sat = satmask(rgb);
    } else {
        sat = achromatic_distance(opp);
    }

    float sat_blend = smootherstep(0.0f, 0.2f, sat);
    float3 hue_weights_cmy = get_hue_zone_weights_cmy(opp);
    float3 hue_weights_rgb = get_hue_zone_weights_rgb(opp);

    float total_hue_shift = 0.0f;

    // SAT TO HUE
    if ((enable_sat_to_hue || enable_hue_zone_sat_cmy || enable_hue_zone_sat_rgb) && sat > 0.001f) {
        float hue_shift_deg = 0.0f;

        if (enable_sat_to_hue) {
            hue_shift_deg += parametric_sat_to_hue(sat, sat_hue_strength, sat_hue_peak, sat_hue_shape);
        }

        if (enable_hue_zone_sat_cmy) {
            float zone_shift = hue_weights_cmy.x * sat_hue_cyan +
                              hue_weights_cmy.y * sat_hue_magenta +
                              hue_weights_cmy.z * sat_hue_yellow;
            hue_shift_deg += zone_shift * sat_blend;
        }

        if (enable_hue_zone_sat_rgb) {
            float zone_shift = hue_weights_rgb.x * sat_hue_red +
                              hue_weights_rgb.y * sat_hue_green +
                              hue_weights_rgb.z * sat_hue_blue;
            hue_shift_deg += zone_shift * sat_blend;
        }

        if (_fabs(hue_shift_deg) > 0.01f) {
            const float DEG_TO_RAD = 3.14159265359f / 180.0f;
            total_hue_shift += hue_shift_deg * DEG_TO_RAD * (enable_sat_to_hue ? sat_hue_mix : 1.0f);
        }
    }

    // LUM TO HUE
    if ((enable_lum_to_hue || enable_hue_zone_lum_cmy || enable_hue_zone_lum_rgb) && sat > 0.001f) {
        float hue_shift_deg = 0.0f;

        if (enable_lum_to_hue) {
            hue_shift_deg += parametric_lum_to_hue(lum, shadow_hue_shift, highlight_hue_shift,
                                                   lum_hue_midpoint, lum_hue_smoothness);
        }

        if (enable_hue_zone_lum_cmy) {
            float zone_shift = hue_weights_cmy.x * lum_hue_cyan +
                              hue_weights_cmy.y * lum_hue_magenta +
                              hue_weights_cmy.z * lum_hue_yellow;
            hue_shift_deg += zone_shift * sat_blend;
        }

        if (enable_hue_zone_lum_rgb) {
            float zone_shift = hue_weights_rgb.x * lum_hue_red +
                              hue_weights_rgb.y * lum_hue_green +
                              hue_weights_rgb.z * lum_hue_blue;
            hue_shift_deg += zone_shift * sat_blend;
        }

        if (_fabs(hue_shift_deg) > 0.01f) {
            const float DEG_TO_RAD = 3.14159265359f / 180.0f;
            total_hue_shift += hue_shift_deg * DEG_TO_RAD * (enable_lum_to_hue ? lum_hue_mix : 1.0f);
        }
    }

    if (_fabs(total_hue_shift) > 0.001f) {
        opp = rotate_hue(opp, total_hue_shift);
    }

    rgb = opponent_to_rgb(opp, lum);
    rgb = maxf3(0.0f, rgb);

    // LUM TO LUM
    if (enable_lum_to_lum) {
        float3 weights = avgweights(matrix_rec709_to_xyz);
        float lum_in = weights.x * rgb.x + weights.y * rgb.y + weights.z * rgb.z;
        float lum_out = parametric_lum_to_lum(lum_in, contrast, toe_lift, shoulder_softness, lum_pivot);
        lum_out = lum_in + (lum_out - lum_in) * lum_to_lum_mix;
        if (lum_in > 0.0001f) {
            float ratio = lum_out / lum_in;
            rgb *= ratio;
        }
    }

    // PURITY
    if (enable_purity) {
        float3 rgb_pre = rgb;
        float3x3 purity_matrix = simpleInsetMatrix(purity_red / 10.0f, purity_green / 10.0f, purity_blue / 10.0f, 1);
        rgb = vdot(purity_matrix, rgb);
        rgb = rgb_pre + (rgb - rgb_pre) * purity_mix;
    }

    // REC.709 TO DWG
    rgb = vdot(matrix_rec709_to_xyz, rgb);
    rgb = vdot(matrix_xyz_to_davinciwg, rgb);

    // LINEAR TO LOG
    rgb.x = oetf_davinci_intermediate(rgb.x, 0);
    rgb.y = oetf_davinci_intermediate(rgb.y, 0);
    rgb.z = oetf_davinci_intermediate(rgb.z, 0);

    return rgb;
}
