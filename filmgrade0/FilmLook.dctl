/*----------------------------------------------------------------------
    FilmLook - Pre-DRT Film Emulation Tool
    v0.1.0

    A scene-referred look development tool designed to work before OpenDRT.
    Input: DaVinci Wide Gamut / DaVinci Intermediate (Log)
    Output: DaVinci Wide Gamut / DaVinci Intermediate (Log)

    Inspired by OpenDRT and JP_2499 approaches.
----------------------------------------------------------------------*/

// ============================================================================
// MATH HELPERS
// ============================================================================

typedef struct {
    float3 x, y, z;
} float3x3;

__DEVICE__ float3x3 make_float3x3(float3 a, float3 b, float3 c) {
    float3x3 d;
    d.x = a; d.y = b; d.z = c;
    return d;
}

__DEVICE__ float3x3 identity_33() {
    return make_float3x3(
        make_float3(1.0f, 0.0f, 0.0f),
        make_float3(0.0f, 1.0f, 0.0f),
        make_float3(0.0f, 0.0f, 1.0f)
    );
}

__DEVICE__ float3 mv_33_3(float3x3 m, float3 v) {
    return make_float3(
        m.x.x * v.x + m.x.y * v.y + m.x.z * v.z,
        m.y.x * v.x + m.y.y * v.y + m.y.z * v.z,
        m.z.x * v.x + m.z.y * v.y + m.z.z * v.z
    );
}

__DEVICE__ float3x3 mult_33_33(float3x3 a, float3x3 b) {
    return make_float3x3(
        make_float3(a.x.x*b.x.x + a.x.y*b.y.x + a.x.z*b.z.x,
                    a.x.x*b.x.y + a.x.y*b.y.y + a.x.z*b.z.y,
                    a.x.x*b.x.z + a.x.y*b.y.z + a.x.z*b.z.z),
        make_float3(a.y.x*b.x.x + a.y.y*b.y.x + a.y.z*b.z.x,
                    a.y.x*b.x.y + a.y.y*b.y.y + a.y.z*b.z.y,
                    a.y.x*b.x.z + a.y.y*b.y.z + a.y.z*b.z.z),
        make_float3(a.z.x*b.x.x + a.z.y*b.y.x + a.z.z*b.z.x,
                    a.z.x*b.x.y + a.z.y*b.y.y + a.z.z*b.z.y,
                    a.z.x*b.x.z + a.z.y*b.y.z + a.z.z*b.z.z)
    );
}

__DEVICE__ float3x3 inv_33(float3x3 m) {
    float d = m.x.x * (m.y.y * m.z.z - m.z.y * m.y.z)
            - m.x.y * (m.y.x * m.z.z - m.y.z * m.z.x)
            + m.x.z * (m.y.x * m.z.y - m.y.y * m.z.x);
    float id = 1.0f / d;
    float3x3 c;
    c.x.x = id * (m.y.y * m.z.z - m.z.y * m.y.z);
    c.x.y = id * (m.x.z * m.z.y - m.x.y * m.z.z);
    c.x.z = id * (m.x.y * m.y.z - m.x.z * m.y.y);
    c.y.x = id * (m.y.z * m.z.x - m.y.x * m.z.z);
    c.y.y = id * (m.x.x * m.z.z - m.x.z * m.z.x);
    c.y.z = id * (m.y.x * m.x.z - m.x.x * m.y.z);
    c.z.x = id * (m.y.x * m.z.y - m.z.x * m.y.y);
    c.z.y = id * (m.z.x * m.x.y - m.x.x * m.z.y);
    c.z.z = id * (m.x.x * m.y.y - m.y.x * m.x.y);
    return c;
}

__DEVICE__ float max3(float x, float y, float z) {
    return _fmaxf(x, _fmaxf(y, z));
}

__DEVICE__ float min3(float x, float y, float z) {
    return _fminf(x, _fminf(y, z));
}

__DEVICE__ float3 maxf3(float b, float3 a) {
    return make_float3(_fmaxf(a.x, b), _fmaxf(a.y, b), _fmaxf(a.z, b));
}

__DEVICE__ float3 minf3(float b, float3 a) {
    return make_float3(_fminf(a.x, b), _fminf(a.y, b), _fminf(a.z, b));
}

__DEVICE__ float clampf(float x, float lo, float hi) {
    return _fmaxf(lo, _fminf(x, hi));
}

__DEVICE__ float3 clampf3(float3 v, float lo, float hi) {
    return make_float3(clampf(v.x, lo, hi), clampf(v.y, lo, hi), clampf(v.z, lo, hi));
}

__DEVICE__ float signf(float x) {
    if (x > 0.0f) return 1.0f;
    if (x < 0.0f) return -1.0f;
    return 0.0f;
}

__DEVICE__ float spowf(float a, float b) {
    return signf(a) * _powf(_fabs(a), b);
}

__DEVICE__ float lerpf(float a, float b, float t) {
    return a + t * (b - a);
}

__DEVICE__ float3 lerpf3(float3 a, float3 b, float t) {
    return make_float3(lerpf(a.x, b.x, t), lerpf(a.y, b.y, t), lerpf(a.z, b.z, t));
}

// ============================================================================
// COLOR SPACE MATRICES
// ============================================================================

// DaVinci Wide Gamut to XYZ D65
#define MATRIX_DWG_TO_XYZ make_float3x3( \
    make_float3(0.700622320175f, 0.148774802685f, 0.101058728993f), \
    make_float3(0.274118483067f, 0.873631775379f, -0.147750422359f), \
    make_float3(-0.098962903023f, -0.137895315886f, 1.325916051865f))

// XYZ D65 to DaVinci Wide Gamut
#define MATRIX_XYZ_TO_DWG make_float3x3( \
    make_float3(1.51667204f, -0.28147805f, -0.14696363f), \
    make_float3(-0.46491710f, 1.25142378f, 0.17488461f), \
    make_float3(0.06484905f, 0.10913934f, 0.76141462f))

// XYZ D65 to Rec.709
#define MATRIX_XYZ_TO_REC709 make_float3x3( \
    make_float3(3.2409699419f, -1.53738317757f, -0.498610760293f), \
    make_float3(-0.969243636281f, 1.87596750151f, 0.041555057407f), \
    make_float3(0.055630079697f, -0.203976958889f, 1.05697151424f))

// Rec.709 to XYZ D65
#define MATRIX_REC709_TO_XYZ make_float3x3( \
    make_float3(0.412390917540f, 0.357584357262f, 0.180480793118f), \
    make_float3(0.212639078498f, 0.715168714523f, 0.072192311287f), \
    make_float3(0.019330825657f, 0.119194783270f, 0.950532138348f))

// Direct DWG to Rec.709 (combined matrix)
#define MATRIX_DWG_TO_REC709 make_float3x3( \
    make_float3(1.70505094f, -0.62179213f, -0.08325881f), \
    make_float3(-0.13025642f, 1.14080473f, -0.01054831f), \
    make_float3(-0.02400496f, -0.12896675f, 1.15297171f))

// Direct Rec.709 to DWG (combined matrix)
#define MATRIX_REC709_TO_DWG make_float3x3( \
    make_float3(0.64118807f, 0.34920508f, 0.00960685f), \
    make_float3(0.07592115f, 0.90828031f, 0.01579854f), \
    make_float3(0.02055773f, 0.10906734f, 0.87037493f))

// Rec.709 luminance weights
#define REC709_Y make_float3(0.2126f, 0.7152f, 0.0722f)

// DaVinci Wide Gamut luminance weights (from DWG to XYZ Y row)
#define DWG_Y make_float3(0.274118483067f, 0.873631775379f, -0.147750422359f)

// ============================================================================
// LOG ENCODING - DaVinci Intermediate
// ============================================================================

__DEVICE__ float di_to_linear(float x) {
    // DaVinci Intermediate Log to Linear
    const float A = 0.0075f;
    const float B = 7.0f;
    const float C = 0.07329248f;
    const float M = 10.44426855f;
    const float LOG_CUT = 0.02740668f;

    return x <= LOG_CUT ? x / M : _exp2f(x / C - B) - A;
}

__DEVICE__ float linear_to_di(float x) {
    // Linear to DaVinci Intermediate Log
    const float A = 0.0075f;
    const float B = 7.0f;
    const float C = 0.07329248f;
    const float M = 10.44426855f;
    const float LIN_CUT = 0.00262409f;

    return x <= LIN_CUT ? x * M : (_log2f(x + A) + B) * C;
}

__DEVICE__ float3 di_to_linear_f3(float3 v) {
    return make_float3(di_to_linear(v.x), di_to_linear(v.y), di_to_linear(v.z));
}

__DEVICE__ float3 linear_to_di_f3(float3 v) {
    return make_float3(linear_to_di(v.x), linear_to_di(v.y), linear_to_di(v.z));
}

// ============================================================================
// SATURATION MASK
// ============================================================================

__DEVICE__ float saturation_mask(float3 rgb) {
    // Compute saturation as distance from achromatic axis
    float maxc = max3(rgb.x, rgb.y, rgb.z);
    float minc = min3(rgb.x, rgb.y, rgb.z);
    float chroma = maxc - minc;

    // Avoid division by zero, normalize by max to get relative saturation
    if (maxc <= 0.0f) return 0.0f;
    return chroma / maxc;
}

// ============================================================================
// LUMINANCE CALCULATION
// ============================================================================

__DEVICE__ float luminance_rec709(float3 rgb) {
    return rgb.x * REC709_Y.x + rgb.y * REC709_Y.y + rgb.z * REC709_Y.z;
}

__DEVICE__ float luminance_dwg(float3 rgb) {
    // Luminance for DaVinci Wide Gamut (Y from XYZ)
    return rgb.x * DWG_Y.x + rgb.y * DWG_Y.y + rgb.z * DWG_Y.z;
}

// ============================================================================
// HUE ROTATION MATRIX (JP_2499 style)
// ============================================================================

__DEVICE__ float3x3 hue_rotation_matrix(float rot_r, float rot_g, float rot_b) {
    // Creates a white-balanced hue rotation matrix
    // Positive rot_r shifts red toward yellow, negative toward magenta
    // Positive rot_g shifts green toward yellow, negative toward cyan
    // Positive rot_b shifts blue toward cyan, negative toward magenta

    float3 redcoeff = make_float3(1.0f,
        rot_g > 0.0f ? rot_g : 0.0f,
        rot_b < 0.0f ? -rot_b : 0.0f);
    float3 greencoeff = make_float3(
        rot_r > 0.0f ? rot_r : 0.0f,
        1.0f,
        rot_b > 0.0f ? rot_b : 0.0f);
    float3 bluecoeff = make_float3(
        rot_r < 0.0f ? -rot_r : 0.0f,
        rot_g < 0.0f ? -rot_g : 0.0f,
        1.0f);

    // Normalize to preserve white
    float3 white;
    white.x = 1.0f + redcoeff.y + redcoeff.z;
    white.y = greencoeff.x + 1.0f + greencoeff.z;
    white.z = bluecoeff.x + bluecoeff.y + 1.0f;

    redcoeff = redcoeff / white.x;
    greencoeff = greencoeff / white.y;
    bluecoeff = bluecoeff / white.z;

    return make_float3x3(redcoeff, greencoeff, bluecoeff);
}

// ============================================================================
// PURITY/SATURATION INSET MATRIX (JP_2499 style)
// ============================================================================

__DEVICE__ float3x3 purity_matrix(float r, float g, float b, int inv) {
    // Increase/decrease purity of individual primaries
    float gain = 1.0f + r + g + b;

    float3 redcoeff = make_float3(1.0f + r, g, b) / gain;
    float3 greencoeff = make_float3(r, 1.0f + g, b) / gain;
    float3 bluecoeff = make_float3(r, g, 1.0f + b) / gain;

    float3x3 m = make_float3x3(redcoeff, greencoeff, bluecoeff);

    return inv ? inv_33(m) : m;
}

// ============================================================================
// CROSSTALK MATRIX
// ============================================================================

__DEVICE__ float3x3 crosstalk_matrix(float rg, float rb, float gr, float gb, float br, float bg) {
    // Creates a crosstalk matrix where each channel bleeds into others
    // rg = red bleeding into green, rb = red bleeding into blue, etc.

    float3 r_row = make_float3(1.0f - rg - rb, rg, rb);
    float3 g_row = make_float3(gr, 1.0f - gr - gb, gb);
    float3 b_row = make_float3(br, bg, 1.0f - br - bg);

    return make_float3x3(r_row, g_row, b_row);
}

// ============================================================================
// GLOBAL DENSITY
// ============================================================================

__DEVICE__ float3 apply_density(float3 rgb, float density) {
    // Darken saturated colors - film dye density effect
    // More saturated = more light blocked
    float sat = saturation_mask(rgb);
    float factor = _powf(1.0f / (1.0f + 0.5f * sat * sat), density);
    return rgb * factor;
}

// ============================================================================
// RGB DENSITY CURVES (per-channel in log space)
// ============================================================================

__DEVICE__ float3 apply_rgb_density(float3 log_rgb, float r_dens, float g_dens, float b_dens) {
    // Apply per-channel density adjustments in log space
    // Works like density curves - affects mid-to-high values more
    // Positive = more density (darker), Negative = less density (lighter)

    float3 result;
    result.x = log_rgb.x - r_dens * log_rgb.x * 0.5f;
    result.y = log_rgb.y - g_dens * log_rgb.y * 0.5f;
    result.z = log_rgb.z - b_dens * log_rgb.z * 0.5f;

    return result;
}

// ============================================================================
// HUE ANGLE CALCULATION (in opponent space)
// ============================================================================

__DEVICE__ float hue_angle(float3 rgb) {
    // Calculate hue angle in radians [0, 2*PI]
    float a = 0.5f * (2.0f * rgb.x - rgb.y - rgb.z);
    float b = (rgb.y - rgb.z) * 0.86602540378f; // sqrt(3)/2
    float h = _atan2f(b, a);
    if (h < 0.0f) h += 6.28318530718f; // 2*PI
    return h;
}

// ============================================================================
// GAUSSIAN FALLOFF FOR HUE ZONES
// ============================================================================

__DEVICE__ float gaussian_weight(float x, float center, float width) {
    float d = x - center;
    // Handle wraparound for hue
    if (d > 3.14159265359f) d -= 6.28318530718f;
    if (d < -3.14159265359f) d += 6.28318530718f;
    return _expf(-d * d / (2.0f * width * width));
}

// ============================================================================
// SATURATION-TO-HUE ROTATION
// ============================================================================

__DEVICE__ float3 sat_to_hue_rotate(float3 rgb, float strength, float peak_sat, float shape,
                                      float cyan, float magenta, float yellow,
                                      float red, float green, float blue) {
    if (strength == 0.0f && cyan == 0.0f && magenta == 0.0f && yellow == 0.0f &&
        red == 0.0f && green == 0.0f && blue == 0.0f) return rgb;

    float sat = saturation_mask(rgb);
    float hue = hue_angle(rgb);

    // Global saturation-based rotation
    float sat_factor = _expf(-_powf((sat - peak_sat) / _fmaxf(shape, 0.01f), 2.0f));
    float rotation = strength * sat_factor;

    // Per-zone rotations (hue positions: R=0, Y=PI/3, G=2PI/3, C=PI, B=4PI/3, M=5PI/3)
    float PI = 3.14159265359f;
    rotation += red * gaussian_weight(hue, 0.0f, 0.5f);
    rotation += yellow * gaussian_weight(hue, PI / 3.0f, 0.5f);
    rotation += green * gaussian_weight(hue, 2.0f * PI / 3.0f, 0.5f);
    rotation += cyan * gaussian_weight(hue, PI, 0.5f);
    rotation += blue * gaussian_weight(hue, 4.0f * PI / 3.0f, 0.5f);
    rotation += magenta * gaussian_weight(hue, 5.0f * PI / 3.0f, 0.5f);

    // Apply rotation via matrix
    float3x3 rot = hue_rotation_matrix(rotation, rotation, rotation);
    return mv_33_3(rot, rgb);
}

// ============================================================================
// LUMINANCE-TO-HUE ROTATION
// ============================================================================

__DEVICE__ float3 lum_to_hue_rotate(float3 rgb, float shadow_shift, float highlight_shift,
                                      float midpoint, float smoothness,
                                      float cyan, float magenta, float yellow,
                                      float red, float green, float blue) {
    if (shadow_shift == 0.0f && highlight_shift == 0.0f &&
        cyan == 0.0f && magenta == 0.0f && yellow == 0.0f &&
        red == 0.0f && green == 0.0f && blue == 0.0f) return rgb;

    float lum = luminance_dwg(rgb);
    float hue = hue_angle(rgb);

    // Shadow/highlight blend based on luminance
    float shadow_weight = 1.0f / (1.0f + _expf((lum - midpoint) * smoothness * 10.0f));
    float highlight_weight = 1.0f - shadow_weight;

    float rotation = shadow_shift * shadow_weight + highlight_shift * highlight_weight;

    // Per-zone rotations
    float PI = 3.14159265359f;
    float zone_factor = shadow_weight + highlight_weight * 0.5f; // Blend zone effect
    rotation += red * gaussian_weight(hue, 0.0f, 0.5f) * zone_factor;
    rotation += yellow * gaussian_weight(hue, PI / 3.0f, 0.5f) * zone_factor;
    rotation += green * gaussian_weight(hue, 2.0f * PI / 3.0f, 0.5f) * zone_factor;
    rotation += cyan * gaussian_weight(hue, PI, 0.5f) * zone_factor;
    rotation += blue * gaussian_weight(hue, 4.0f * PI / 3.0f, 0.5f) * zone_factor;
    rotation += magenta * gaussian_weight(hue, 5.0f * PI / 3.0f, 0.5f) * zone_factor;

    float3x3 rot = hue_rotation_matrix(rotation, rotation, rotation);
    return mv_33_3(rot, rgb);
}

// ============================================================================
// UI PARAMETERS
// ============================================================================

// Preset Selection
DEFINE_UI_PARAMS(preset, Film Preset, DCTLUI_COMBO_BOX, 0, {p_none, p_kodak5219, p_kodak2383, p_fuji_eterna, p_portra, p_cinestill}, {None - Manual, Kodak 5219 Vision3, Kodak 2383 Print, Fuji Eterna, Portra 400, Cinestill 800T})

// Global Density
DEFINE_UI_PARAMS(density_enable, Enable Density, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(density, Global Density, DCTLUI_SLIDER_FLOAT, 0.5, 0.0, 2.0, 0.01)

// RGB Density
DEFINE_UI_PARAMS(rgb_density_enable, Enable RGB Density, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(r_density, Red Density, DCTLUI_SLIDER_FLOAT, 0.0, -1.0, 1.0, 0.01)
DEFINE_UI_PARAMS(g_density, Green Density, DCTLUI_SLIDER_FLOAT, 0.0, -1.0, 1.0, 0.01)
DEFINE_UI_PARAMS(b_density, Blue Density, DCTLUI_SLIDER_FLOAT, 0.0, -1.0, 1.0, 0.01)

// Channel Crosstalk
DEFINE_UI_PARAMS(crosstalk_enable, Enable Crosstalk, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(ct_rg, R to G, DCTLUI_SLIDER_FLOAT, 0.0, -0.2, 0.2, 0.001)
DEFINE_UI_PARAMS(ct_rb, R to B, DCTLUI_SLIDER_FLOAT, 0.0, -0.2, 0.2, 0.001)
DEFINE_UI_PARAMS(ct_gr, G to R, DCTLUI_SLIDER_FLOAT, 0.0, -0.2, 0.2, 0.001)
DEFINE_UI_PARAMS(ct_gb, G to B, DCTLUI_SLIDER_FLOAT, 0.0, -0.2, 0.2, 0.001)
DEFINE_UI_PARAMS(ct_br, B to R, DCTLUI_SLIDER_FLOAT, 0.0, -0.2, 0.2, 0.001)
DEFINE_UI_PARAMS(ct_bg, B to G, DCTLUI_SLIDER_FLOAT, 0.0, -0.2, 0.2, 0.001)

// Overall Hue Rotation
DEFINE_UI_PARAMS(hue_enable, Enable Hue Rotation, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(hue_r, Hue Rotate R, DCTLUI_SLIDER_FLOAT, 0.0, -0.5, 0.5, 0.01)
DEFINE_UI_PARAMS(hue_g, Hue Rotate G, DCTLUI_SLIDER_FLOAT, 0.0, -0.5, 0.5, 0.01)
DEFINE_UI_PARAMS(hue_b, Hue Rotate B, DCTLUI_SLIDER_FLOAT, 0.0, -0.5, 0.5, 0.01)

// Saturation-to-Hue
DEFINE_UI_PARAMS(sat_hue_enable, Enable Sat-Hue, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(sat_hue_str, Sat-Hue Strength, DCTLUI_SLIDER_FLOAT, 0.0, -1.0, 1.0, 0.01)
DEFINE_UI_PARAMS(sat_hue_peak, Sat-Hue Peak, DCTLUI_SLIDER_FLOAT, 0.5, 0.0, 1.0, 0.01)
DEFINE_UI_PARAMS(sat_hue_shape, Sat-Hue Shape, DCTLUI_SLIDER_FLOAT, 0.3, 0.05, 1.0, 0.01)
DEFINE_UI_PARAMS(sat_hue_cyan, Sat-Hue Cyan, DCTLUI_SLIDER_FLOAT, 0.0, -0.5, 0.5, 0.01)
DEFINE_UI_PARAMS(sat_hue_mag, Sat-Hue Magenta, DCTLUI_SLIDER_FLOAT, 0.0, -0.5, 0.5, 0.01)
DEFINE_UI_PARAMS(sat_hue_yel, Sat-Hue Yellow, DCTLUI_SLIDER_FLOAT, 0.0, -0.5, 0.5, 0.01)
DEFINE_UI_PARAMS(sat_hue_red, Sat-Hue Red, DCTLUI_SLIDER_FLOAT, 0.0, -0.5, 0.5, 0.01)
DEFINE_UI_PARAMS(sat_hue_grn, Sat-Hue Green, DCTLUI_SLIDER_FLOAT, 0.0, -0.5, 0.5, 0.01)
DEFINE_UI_PARAMS(sat_hue_blu, Sat-Hue Blue, DCTLUI_SLIDER_FLOAT, 0.0, -0.5, 0.5, 0.01)

// Luminance-to-Hue
DEFINE_UI_PARAMS(lum_hue_enable, Enable Lum-Hue, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(lum_hue_shadow, Shadow Hue Shift, DCTLUI_SLIDER_FLOAT, 0.0, -0.5, 0.5, 0.01)
DEFINE_UI_PARAMS(lum_hue_high, Highlight Hue Shift, DCTLUI_SLIDER_FLOAT, 0.0, -0.5, 0.5, 0.01)
DEFINE_UI_PARAMS(lum_hue_mid, Lum-Hue Midpoint, DCTLUI_SLIDER_FLOAT, 0.18, 0.01, 1.0, 0.01)
DEFINE_UI_PARAMS(lum_hue_smooth, Lum-Hue Smoothness, DCTLUI_SLIDER_FLOAT, 1.0, 0.1, 5.0, 0.1)
DEFINE_UI_PARAMS(lum_hue_cyan, Lum-Hue Cyan, DCTLUI_SLIDER_FLOAT, 0.0, -0.5, 0.5, 0.01)
DEFINE_UI_PARAMS(lum_hue_mag, Lum-Hue Magenta, DCTLUI_SLIDER_FLOAT, 0.0, -0.5, 0.5, 0.01)
DEFINE_UI_PARAMS(lum_hue_yel, Lum-Hue Yellow, DCTLUI_SLIDER_FLOAT, 0.0, -0.5, 0.5, 0.01)
DEFINE_UI_PARAMS(lum_hue_red, Lum-Hue Red, DCTLUI_SLIDER_FLOAT, 0.0, -0.5, 0.5, 0.01)
DEFINE_UI_PARAMS(lum_hue_grn, Lum-Hue Green, DCTLUI_SLIDER_FLOAT, 0.0, -0.5, 0.5, 0.01)
DEFINE_UI_PARAMS(lum_hue_blu, Lum-Hue Blue, DCTLUI_SLIDER_FLOAT, 0.0, -0.5, 0.5, 0.01)

// Purity
DEFINE_UI_PARAMS(purity_enable, Enable Purity, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(purity_r, Purity R, DCTLUI_SLIDER_FLOAT, 0.0, -0.5, 1.0, 0.01)
DEFINE_UI_PARAMS(purity_g, Purity G, DCTLUI_SLIDER_FLOAT, 0.0, -0.5, 1.0, 0.01)
DEFINE_UI_PARAMS(purity_b, Purity B, DCTLUI_SLIDER_FLOAT, 0.0, -0.5, 1.0, 0.01)

// ============================================================================
// MAIN TRANSFORM
// ============================================================================

__DEVICE__ float3 transform(int p_Width, int p_Height, int p_X, int p_Y, float p_R, float p_G, float p_B) {

    float3 rgb = make_float3(p_R, p_G, p_B);

    // Input is DWG Log (DaVinci Intermediate)
    // Convert to linear DWG - stay in DWG for all processing to avoid gamut issues
    float3 work = di_to_linear_f3(rgb);

    // ========== PRESET LOADING ==========
    float _density = density;
    float _r_dens = r_density, _g_dens = g_density, _b_dens = b_density;
    float _ct_rg = ct_rg, _ct_rb = ct_rb, _ct_gr = ct_gr, _ct_gb = ct_gb, _ct_br = ct_br, _ct_bg = ct_bg;
    float _hue_r = hue_r, _hue_g = hue_g, _hue_b = hue_b;
    float _purity_r = purity_r, _purity_g = purity_g, _purity_b = purity_b;
    int _density_en = density_enable, _rgb_dens_en = rgb_density_enable;
    int _crosstalk_en = crosstalk_enable, _hue_en = hue_enable, _purity_en = purity_enable;

    if (preset == p_kodak5219) {
        // Kodak Vision3 5219 500T - warm, rich shadows, cyan-ish highlights
        _density = 0.8f; _density_en = 1;
        _hue_r = 0.05f; _hue_g = 0.02f; _hue_b = 0.15f; _hue_en = 1;
        _ct_rg = 0.02f; _ct_gb = 0.03f; _crosstalk_en = 1;
        _purity_r = 0.2f; _purity_g = 0.1f; _purity_b = 0.15f; _purity_en = 1;
    } else if (preset == p_kodak2383) {
        // Kodak 2383 Print Stock - high contrast, punchy
        _density = 1.2f; _density_en = 1;
        _hue_r = 0.08f; _hue_g = -0.05f; _hue_b = 0.2f; _hue_en = 1;
        _purity_r = 0.3f; _purity_g = 0.15f; _purity_b = 0.1f; _purity_en = 1;
    } else if (preset == p_fuji_eterna) {
        // Fuji Eterna - cooler, more neutral greens
        _density = 0.6f; _density_en = 1;
        _hue_r = -0.02f; _hue_g = -0.08f; _hue_b = 0.1f; _hue_en = 1;
        _ct_gb = 0.02f; _ct_bg = 0.01f; _crosstalk_en = 1;
        _purity_r = 0.1f; _purity_g = 0.2f; _purity_b = 0.25f; _purity_en = 1;
    } else if (preset == p_portra) {
        // Portra 400 - warm skin tones, pastel-ish
        _density = 0.4f; _density_en = 1;
        _hue_r = 0.1f; _hue_g = 0.05f; _hue_b = 0.0f; _hue_en = 1;
        _purity_r = 0.15f; _purity_g = 0.05f; _purity_b = -0.1f; _purity_en = 1;
    } else if (preset == p_cinestill) {
        // Cinestill 800T - tungsten balanced, halation-ready
        _density = 0.7f; _density_en = 1;
        _hue_r = 0.12f; _hue_g = 0.0f; _hue_b = 0.25f; _hue_en = 1;
        _ct_rg = 0.03f; _ct_rb = 0.01f; _crosstalk_en = 1;
        _purity_r = 0.35f; _purity_g = 0.1f; _purity_b = 0.2f; _purity_en = 1;
    }

    // ========== APPLY EFFECTS ==========

    // 1. Global Density (in linear)
    if (_density_en) {
        work = apply_density(work, _density);
    }

    // 2. RGB Density (in log space)
    if (_rgb_dens_en) {
        float3 log_work = linear_to_di_f3(work);
        log_work = apply_rgb_density(log_work, _r_dens, _g_dens, _b_dens);
        work = di_to_linear_f3(log_work);
    }

    // 3. Channel Crosstalk
    if (_crosstalk_en) {
        float3x3 ct = crosstalk_matrix(_ct_rg, _ct_rb, _ct_gr, _ct_gb, _ct_br, _ct_bg);
        work = mv_33_3(ct, work);
    }

    // 4. Overall Hue Rotation
    if (_hue_en) {
        float3x3 hue_mat = hue_rotation_matrix(_hue_r, _hue_g, _hue_b);
        work = mv_33_3(hue_mat, work);
    }

    // 5. Saturation-to-Hue Rotation
    if (sat_hue_enable) {
        work = sat_to_hue_rotate(work, sat_hue_str, sat_hue_peak, sat_hue_shape,
                                  sat_hue_cyan, sat_hue_mag, sat_hue_yel,
                                  sat_hue_red, sat_hue_grn, sat_hue_blu);
    }

    // 6. Luminance-to-Hue Rotation
    if (lum_hue_enable) {
        work = lum_to_hue_rotate(work, lum_hue_shadow, lum_hue_high,
                                  lum_hue_mid, lum_hue_smooth,
                                  lum_hue_cyan, lum_hue_mag, lum_hue_yel,
                                  lum_hue_red, lum_hue_grn, lum_hue_blu);
    }

    // 7. Purity
    if (_purity_en) {
        float3x3 pur = purity_matrix(_purity_r / 10.0f, _purity_g / 10.0f, _purity_b / 10.0f, 1);
        work = mv_33_3(pur, work);
    }

    // Convert back to DWG Log (DaVinci Intermediate) for output
    rgb = linear_to_di_f3(work);

    return rgb;
}
