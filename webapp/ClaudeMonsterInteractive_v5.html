<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Film Emulation Preset Creator v5 - Enhanced DCTL Generator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --ui-scale: 1.0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #0d0d0d;
            color: #e0e0e0;
            padding: calc(20px * var(--ui-scale));
            overflow-x: hidden;
        }

        .container {
            max-width: 2600px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            margin-bottom: 5px;
            color: #fff;
            font-size: calc(28px * var(--ui-scale));
            font-weight: 700;
        }

        .subtitle {
            text-align: center;
            margin-bottom: 20px;
            color: #888;
            font-size: calc(13px * var(--ui-scale));
        }

        .top-controls {
            position: fixed;
            top: 15px;
            right: 15px;
            display: flex;
            gap: 15px;
            z-index: 1000;
        }

        .scale-control {
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            border-radius: 8px;
            padding: 12px 15px;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .undo-redo-control {
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            border-radius: 8px;
            padding: 8px;
            display: flex;
            gap: 8px;
        }

        .undo-redo-btn {
            padding: 8px 12px;
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 6px;
            color: #aaa;
            cursor: pointer;
            font-size: 11px;
            font-weight: 600;
            transition: all 0.15s;
            text-transform: uppercase;
        }

        .undo-redo-btn:hover:not(:disabled) {
            background: #3a3a3a;
            color: #fff;
        }

        .undo-redo-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .scale-label {
            font-size: 11px;
            color: #888;
            font-weight: 600;
        }

        .scale-slider {
            width: 120px;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 580px;
            gap: 20px;
            margin-bottom: 20px;
        }

        .left-panel {
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            border-radius: 12px;
            padding: 20px;
            max-height: 66vh;
            overflow-y: auto;
        }

        .left-panel::-webkit-scrollbar {
            width: 10px;
        }

        .left-panel::-webkit-scrollbar-track {
            background: #0d0d0d;
            border-radius: 5px;
        }

        .left-panel::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 5px;
        }

        .right-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .controls-section {
            background: #0d0d0d;
            border: 1px solid #2a2a2a;
            border-radius: 10px;
            padding: 18px;
            margin-bottom: 18px;
        }

        .vectorscope-panel {
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            border-radius: 12px;
            padding: 20px;
        }

        .test-image-panel {
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            border-radius: 12px;
            padding: 20px;
        }

        .preset-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 15px;
        }

        .preset-btn {
            padding: 10px;
            background: linear-gradient(135deg, #2a2a2a 0%, #1f1f1f 100%);
            border: 1px solid #3a3a3a;
            border-radius: 6px;
            color: #e0e0e0;
            cursor: pointer;
            font-size: 11px;
            font-weight: 600;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .preset-btn:hover {
            background: linear-gradient(135deg, #3a3a3a 0%, #2f2f2f 100%);
            border-color: #4a4a4a;
            transform: translateY(-1px);
        }

        .preset-btn.active {
            background: linear-gradient(135deg, #0066cc 0%, #0055aa 100%);
            border-color: #0077ee;
            color: white;
        }

        .export-section {
            display: grid;
            gap: 8px;
            margin-top: 12px;
        }

        .export-btn {
            padding: 11px;
            background: linear-gradient(135deg, #00aa44 0%, #008833 100%);
            border: none;
            border-radius: 6px;
            color: white;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .export-btn:hover {
            background: linear-gradient(135deg, #00bb55 0%, #009944 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 170, 68, 0.3);
        }

        .export-btn.secondary {
            background: linear-gradient(135deg, #cc6600 0%, #aa5500 100%);
        }

        .export-btn.secondary:hover {
            background: linear-gradient(135deg, #ee7700 0%, #cc6600 100%);
            box-shadow: 0 4px 12px rgba(204, 102, 0, 0.3);
        }

        .export-btn.import {
            background: linear-gradient(135deg, #6600cc 0%, #5500aa 100%);
        }

        .export-btn.import:hover {
            background: linear-gradient(135deg, #7700ee 0%, #6600cc 100%);
            box-shadow: 0 4px 12px rgba(102, 0, 204, 0.3);
        }

        .section-header {
            font-size: 14px;
            font-weight: 700;
            color: #fff;
            margin: 18px 0 12px 0;
            padding-bottom: 8px;
            border-bottom: 2px solid #2a2a2a;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .section-header:first-child {
            margin-top: 0;
        }

        .curve-section {
            background: #0d0d0d;
            border: 1px solid #2a2a2a;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 18px;
        }

        .curve-header {
            margin-bottom: 10px;
        }

        .curve-title {
            font-size: 14px;
            font-weight: 600;
            color: #fff;
            margin-bottom: 6px;
        }

        .curve-description {
            font-size: 10px;
            color: #888;
            line-height: 1.4;
            margin-bottom: 6px;
        }

        .curve-range {
            font-size: 9px;
            color: #666;
            font-family: 'Consolas', 'Monaco', monospace;
            background: #1a1a1a;
            padding: 4px 7px;
            border-radius: 3px;
            display: inline-block;
        }

        .curve-canvas-wrapper {
            position: relative;
            background: #000;
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid #1a1a1a;
        }

        .curve-canvas {
            display: block;
            width: 100%;
            height: auto;
            border-radius: 4px;
            cursor: crosshair;
        }

        .node-controls {
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            border-radius: 6px;
            padding: 10px;
            margin-top: 8px;
        }

        .node-controls-header {
            font-size: 11px;
            font-weight: 600;
            color: #aaa;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .node-select {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }

        .node-btn {
            padding: 6px 10px;
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 5px;
            color: #aaa;
            cursor: pointer;
            font-size: 10px;
            font-weight: 500;
            transition: all 0.15s;
            min-width: 50px;
            text-align: center;
        }

        .node-btn:hover {
            background: #3a3a3a;
            border-color: #4a4a4a;
        }

        .node-btn.active {
            background: #0066cc;
            border-color: #0077ee;
            color: white;
        }

        .node-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .input-label {
            font-size: 9px;
            font-weight: 600;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .input-field {
            padding: 7px 9px;
            background: #0d0d0d;
            border: 1px solid #3a3a3a;
            border-radius: 5px;
            color: #fff;
            font-size: 12px;
            font-weight: 500;
            font-family: 'Consolas', 'Monaco', monospace;
            transition: all 0.2s;
        }

        .input-field:focus {
            outline: none;
            border-color: #0066cc;
            box-shadow: 0 0 0 3px rgba(0, 102, 204, 0.1);
        }

        .input-field:hover {
            border-color: #4a4a4a;
        }

        .node-actions {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            margin-top: 8px;
        }

        .action-btn {
            padding: 6px 10px;
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 5px;
            color: #aaa;
            cursor: pointer;
            font-size: 10px;
            font-weight: 600;
            transition: all 0.15s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .action-btn:hover {
            background: #3a3a3a;
            color: #fff;
        }

        .action-btn.delete {
            background: #aa0000;
            border-color: #cc0000;
            color: #fff;
        }

        .action-btn.delete:hover {
            background: #cc0000;
        }

        .action-btn.add {
            background: #00aa44;
            border-color: #00cc55;
            color: #fff;
        }

        .action-btn.add:hover {
            background: #00cc55;
        }

        .vectorscope-container {
            background: #000;
            border-radius: 8px;
            padding: 12px;
            text-align: center;
            margin-bottom: 12px;
        }

        .vectorscope-title {
            font-size: 12px;
            font-weight: 600;
            color: #aaa;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .vectorscope {
            display: block;
            margin: 0 auto;
            border-radius: 8px;
            background: #000;
        }

        .vectorscope-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 12px;
        }

        .test-image-container {
            position: relative;
        }

        .test-image {
            width: 100%;
            height: auto;
            border-radius: 8px;
            background: #000;
        }

        .image-label {
            font-size: 11px;
            font-weight: 600;
            color: #aaa;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-top: 10px;
        }

        .stat-box {
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            border-radius: 5px;
            padding: 8px;
            text-align: center;
        }

        .stat-label {
            font-size: 8px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 3px;
        }

        .stat-value {
            font-size: 14px;
            font-weight: 700;
            color: #0066cc;
            font-family: 'Consolas', monospace;
        }

        .preset-name-input {
            width: 100%;
            padding: 10px;
            background: #0d0d0d;
            border: 1px solid #3a3a3a;
            border-radius: 6px;
            color: #fff;
            font-size: 12px;
            margin-bottom: 8px;
            font-weight: 500;
        }

        .preset-name-input:focus {
            outline: none;
            border-color: #0066cc;
        }

        .help-text {
            font-size: 9px;
            color: #666;
            line-height: 1.3;
            margin-top: 5px;
            padding: 5px;
            background: #0d0d0d;
            border-radius: 3px;
        }

        .image-upload-section {
            margin-top: 12px;
            padding: 12px;
            background: #0d0d0d;
            border: 1px solid #2a2a2a;
            border-radius: 6px;
        }

        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
            width: 100%;
        }

        .file-input-btn {
            padding: 10px;
            background: linear-gradient(135deg, #0066cc 0%, #0055aa 100%);
            border: none;
            border-radius: 6px;
            color: white;
            cursor: pointer;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            width: 100%;
            transition: all 0.2s;
        }

        .file-input-btn:hover {
            background: linear-gradient(135deg, #0077ee 0%, #0066cc 100%);
        }

        .file-input-wrapper input[type=file] {
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .import-textarea {
            width: 100%;
            min-height: 120px;
            padding: 10px;
            background: #0d0d0d;
            border: 1px solid #3a3a3a;
            border-radius: 6px;
            color: #0f0;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 10px;
            resize: vertical;
            margin-top: 8px;
        }

        .import-textarea:focus {
            outline: none;
            border-color: #0066cc;
        }
    </style>
</head>
<body>
    <div class="top-controls">
        <div class="undo-redo-control">
            <button class="undo-redo-btn" id="undoBtn" onclick="undo()" disabled>‚ü≤ Undo</button>
            <button class="undo-redo-btn" id="redoBtn" onclick="redo()" disabled>‚ü≥ Redo</button>
        </div>
        <div class="scale-control">
            <span class="scale-label">UI Scale:</span>
            <input type="range" class="scale-slider" min="0.7" max="1.3" step="0.1" value="1.0" oninput="setUIScale(this.value)">
            <span class="scale-label" id="scaleValue">100%</span>
        </div>
    </div>

    <div class="container">
        <h1>üé¨ Film Emulation Preset Creator v5</h1>
        <p class="subtitle">Enhanced DCTL Generator with Undo/Redo, Image Upload & LumVsHue Support</p>

        <div class="main-grid">
            <!-- Left Panel: Curve Editors -->
            <div class="left-panel">
                <!-- Controls Section -->
                <div class="controls-section">
                    <div class="section-header" style="margin-top: 0;">Film Presets</div>
                    <div class="preset-buttons">
                        <button class="preset-btn active" onclick="loadPreset('neutral')">Neutral</button>
                        <button class="preset-btn" onclick="loadPreset('velvia')">Fuji Velvia</button>
                        <button class="preset-btn" onclick="loadPreset('portra')">Kodak Portra</button>
                        <button class="preset-btn" onclick="loadPreset('cinestill')">Cinestill 800T</button>
                        <button class="preset-btn" onclick="loadPreset('teal_orange')">Teal & Orange</button>
                        <button class="preset-btn" onclick="loadPreset('agfa')">Agfa Vista</button>
                    </div>

                    <div class="section-header">Export/Import</div>
                    <input type="text" id="presetName" class="preset-name-input" placeholder="Preset Name (e.g., MY_CUSTOM)" value="CUSTOM">
                    <div class="export-section">
                        <button class="export-btn" onclick="exportDCTLPreset()">üìã Export DCTL Preset</button>
                        <button class="export-btn secondary" onclick="exportJSON()">üíæ Export JSON</button>
                        <button class="export-btn import" onclick="toggleImportSection()">üì• Import DCTL</button>
                    </div>

                    <div id="importSection" style="display: none;">
                        <textarea class="import-textarea" id="importTextarea" placeholder="Paste DCTL preset code here (from __CONSTANT__ declarations)..."></textarea>
                        <button class="export-btn" style="margin-top: 8px;" onclick="importDCTL()">Apply Import</button>
                    </div>

                    <div class="section-header">Statistics</div>
                    <div class="stats-grid">
                        <div class="stat-box">
                            <div class="stat-label">Total Nodes</div>
                            <div class="stat-value" id="totalNodes">0</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-label">Active Curve</div>
                            <div class="stat-value" id="activeCurve">-</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-label">Active Node</div>
                            <div class="stat-value" id="activeNode">-</div>
                        </div>
                    </div>
                </div>

                <div class="section-header">Parametric Curve Editors</div>

                <!-- Hue vs Hue -->
                <div class="curve-section">
                    <div class="curve-header">
                        <div class="curve-title">Hue ‚Üí Hue (Color Rotation)</div>
                        <div class="curve-description">
                            Rotates specific hues toward different colors. Essential for film character.
                        </div>
                        <div class="curve-range">Input: 0-360¬∞ | Output: -30 to +30¬∞</div>
                    </div>
                    <div class="curve-canvas-wrapper">
                        <canvas id="hueVsHueCanvas" class="curve-canvas" width="600" height="130"></canvas>
                    </div>
                    <div class="node-controls" id="hueVsHueControls">
                        <div class="node-controls-header">Node Controls</div>
                        <div class="node-select" id="hueVsHueNodeSelect"></div>
                        <div class="node-inputs">
                            <div class="input-group">
                                <label class="input-label">X (Hue ¬∞)</label>
                                <input type="number" class="input-field" id="hueVsHueX" step="1" min="0" max="360">
                            </div>
                            <div class="input-group">
                                <label class="input-label">Y (Shift ¬∞)</label>
                                <input type="number" class="input-field" id="hueVsHueY" step="0.1" min="-30" max="30">
                            </div>
                        </div>
                        <div class="node-actions">
                            <button class="action-btn add" onclick="addNodeToCurve('hueVsHue')">+ Add</button>
                            <button class="action-btn delete" onclick="deleteActiveNode('hueVsHue')">Delete</button>
                        </div>
                    </div>
                </div>

                <!-- Hue vs Saturation -->
                <div class="curve-section">
                    <div class="curve-header">
                        <div class="curve-title">Hue ‚Üí Saturation</div>
                        <div class="curve-description">
                            Makes specific colors more or less saturated.
                        </div>
                        <div class="curve-range">Input: 0-360¬∞ | Output: 0-2x</div>
                    </div>
                    <div class="curve-canvas-wrapper">
                        <canvas id="hueVsSatCanvas" class="curve-canvas" width="600" height="130"></canvas>
                    </div>
                    <div class="node-controls" id="hueVsSatControls">
                        <div class="node-controls-header">Node Controls</div>
                        <div class="node-select" id="hueVsSatNodeSelect"></div>
                        <div class="node-inputs">
                            <div class="input-group">
                                <label class="input-label">X (Hue ¬∞)</label>
                                <input type="number" class="input-field" id="hueVsSatX" step="1" min="0" max="360">
                            </div>
                            <div class="input-group">
                                <label class="input-label">Y (Mult)</label>
                                <input type="number" class="input-field" id="hueVsSatY" step="0.01" min="0" max="2">
                            </div>
                        </div>
                        <div class="node-actions">
                            <button class="action-btn add" onclick="addNodeToCurve('hueVsSat')">+ Add</button>
                            <button class="action-btn delete" onclick="deleteActiveNode('hueVsSat')">Delete</button>
                        </div>
                    </div>
                </div>

                <!-- Hue vs Luminance -->
                <div class="curve-section">
                    <div class="curve-header">
                        <div class="curve-title">Hue ‚Üí Luminance</div>
                        <div class="curve-description">
                            Brightens or darkens specific hues.
                        </div>
                        <div class="curve-range">Input: 0-360¬∞ | Output: -0.2 to +0.2</div>
                    </div>
                    <div class="curve-canvas-wrapper">
                        <canvas id="hueVsLumCanvas" class="curve-canvas" width="600" height="130"></canvas>
                    </div>
                    <div class="node-controls" id="hueVsLumControls">
                        <div class="node-controls-header">Node Controls</div>
                        <div class="node-select" id="hueVsLumNodeSelect"></div>
                        <div class="node-inputs">
                            <div class="input-group">
                                <label class="input-label">X (Hue ¬∞)</label>
                                <input type="number" class="input-field" id="hueVsLumX" step="1" min="0" max="360">
                            </div>
                            <div class="input-group">
                                <label class="input-label">Y (Offset)</label>
                                <input type="number" class="input-field" id="hueVsLumY" step="0.01" min="-0.2" max="0.2">
                            </div>
                        </div>
                        <div class="node-actions">
                            <button class="action-btn add" onclick="addNodeToCurve('hueVsLum')">+ Add</button>
                            <button class="action-btn delete" onclick="deleteActiveNode('hueVsLum')">Delete</button>
                        </div>
                    </div>
                </div>

                <!-- NEW: Luminance vs Hue -->
                <div class="curve-section">
                    <div class="curve-header">
                        <div class="curve-title">Luminance ‚Üí Hue (NEW)</div>
                        <div class="curve-description">
                            Shifts hues differently in shadows vs highlights. Film-accurate color behavior.
                        </div>
                        <div class="curve-range">Input: 0-1 (luminance) | Output: -30 to +30¬∞ (hue shift)</div>
                    </div>
                    <div class="curve-canvas-wrapper">
                        <canvas id="lumVsHueCanvas" class="curve-canvas" width="600" height="130"></canvas>
                    </div>
                    <div class="node-controls" id="lumVsHueControls">
                        <div class="node-controls-header">Node Controls</div>
                        <div class="node-select" id="lumVsHueNodeSelect"></div>
                        <div class="node-inputs">
                            <div class="input-group">
                                <label class="input-label">X (Luminance)</label>
                                <input type="number" class="input-field" id="lumVsHueX" step="0.01" min="0" max="1">
                            </div>
                            <div class="input-group">
                                <label class="input-label">Y (Shift ¬∞)</label>
                                <input type="number" class="input-field" id="lumVsHueY" step="0.1" min="-30" max="30">
                            </div>
                        </div>
                        <div class="node-actions">
                            <button class="action-btn add" onclick="addNodeToCurve('lumVsHue')">+ Add</button>
                            <button class="action-btn delete" onclick="deleteActiveNode('lumVsHue')">Delete</button>
                        </div>
                        <div class="help-text">Example: Warm shadows (0.0, +5) or cool highlights (1.0, -3)</div>
                    </div>
                </div>

                <!-- Saturation vs Saturation -->
                <div class="curve-section">
                    <div class="curve-header">
                        <div class="curve-title">Saturation ‚Üí Saturation</div>
                        <div class="curve-description">
                            S-curves create film-like saturation rolloff.
                        </div>
                        <div class="curve-range">Input: 0-1 | Output: 0-1</div>
                    </div>
                    <div class="curve-canvas-wrapper">
                        <canvas id="satVsSatCanvas" class="curve-canvas" width="600" height="130"></canvas>
                    </div>
                    <div class="node-controls" id="satVsSatControls">
                        <div class="node-controls-header">Node Controls</div>
                        <div class="node-select" id="satVsSatNodeSelect"></div>
                        <div class="node-inputs">
                            <div class="input-group">
                                <label class="input-label">X (In Sat)</label>
                                <input type="number" class="input-field" id="satVsSatX" step="0.01" min="0" max="1">
                            </div>
                            <div class="input-group">
                                <label class="input-label">Y (Out Sat)</label>
                                <input type="number" class="input-field" id="satVsSatY" step="0.01" min="0" max="1">
                            </div>
                        </div>
                        <div class="node-actions">
                            <button class="action-btn add" onclick="addNodeToCurve('satVsSat')">+ Add</button>
                            <button class="action-btn delete" onclick="deleteActiveNode('satVsSat')">Delete</button>
                        </div>
                    </div>
                </div>

                <!-- Saturation vs Luminance -->
                <div class="curve-section">
                    <div class="curve-header">
                        <div class="curve-title">Saturation ‚Üí Luminance</div>
                        <div class="curve-description">
                            Film density effect - saturated colors may appear darker.
                        </div>
                        <div class="curve-range">Input: 0-1 | Output: -0.2 to +0.2</div>
                    </div>
                    <div class="curve-canvas-wrapper">
                        <canvas id="satVsLumCanvas" class="curve-canvas" width="600" height="130"></canvas>
                    </div>
                    <div class="node-controls" id="satVsLumControls">
                        <div class="node-controls-header">Node Controls</div>
                        <div class="node-select" id="satVsLumNodeSelect"></div>
                        <div class="node-inputs">
                            <div class="input-group">
                                <label class="input-label">X (Saturation)</label>
                                <input type="number" class="input-field" id="satVsLumX" step="0.01" min="0" max="1">
                            </div>
                            <div class="input-group">
                                <label class="input-label">Y (Offset)</label>
                                <input type="number" class="input-field" id="satVsLumY" step="0.01" min="-0.2" max="0.2">
                            </div>
                        </div>
                        <div class="node-actions">
                            <button class="action-btn add" onclick="addNodeToCurve('satVsLum')">+ Add</button>
                            <button class="action-btn delete" onclick="deleteActiveNode('satVsLum')">Delete</button>
                        </div>
                    </div>
                </div>

                <!-- Luminance vs Saturation -->
                <div class="curve-section">
                    <div class="curve-header">
                        <div class="curve-title">Luminance ‚Üí Saturation</div>
                        <div class="curve-description">
                            Critical! Desaturates shadows/highlights, keeps color in midtones.
                        </div>
                        <div class="curve-range">Input: 0-1 | Output: 0-2x</div>
                    </div>
                    <div class="curve-canvas-wrapper">
                        <canvas id="lumVsSatCanvas" class="curve-canvas" width="600" height="130"></canvas>
                    </div>
                    <div class="node-controls" id="lumVsSatControls">
                        <div class="node-controls-header">Node Controls</div>
                        <div class="node-select" id="lumVsSatNodeSelect"></div>
                        <div class="node-inputs">
                            <div class="input-group">
                                <label class="input-label">X (Luminance)</label>
                                <input type="number" class="input-field" id="lumVsSatX" step="0.01" min="0" max="1">
                            </div>
                            <div class="input-group">
                                <label class="input-label">Y (Mult)</label>
                                <input type="number" class="input-field" id="lumVsSatY" step="0.01" min="0" max="2">
                            </div>
                        </div>
                        <div class="node-actions">
                            <button class="action-btn add" onclick="addNodeToCurve('lumVsSat')">+ Add</button>
                            <button class="action-btn delete" onclick="deleteActiveNode('lumVsSat')">Delete</button>
                        </div>
                    </div>
                </div>

                <!-- Luminance vs Luminance -->
                <div class="curve-section">
                    <div class="curve-header">
                        <div class="curve-title">Luminance ‚Üí Luminance (Tone Curve)</div>
                        <div class="curve-description">
                            Traditional tone curve. S-curves add contrast.
                        </div>
                        <div class="curve-range">Input: 0-1 | Output: 0-1</div>
                    </div>
                    <div class="curve-canvas-wrapper">
                        <canvas id="lumVsLumCanvas" class="curve-canvas" width="600" height="130"></canvas>
                    </div>
                    <div class="node-controls" id="lumVsLumControls">
                        <div class="node-controls-header">Node Controls</div>
                        <div class="node-select" id="lumVsLumNodeSelect"></div>
                        <div class="node-inputs">
                            <div class="input-group">
                                <label class="input-label">X (In Lum)</label>
                                <input type="number" class="input-field" id="lumVsLumX" step="0.01" min="0" max="1">
                            </div>
                            <div class="input-group">
                                <label class="input-label">Y (Out Lum)</label>
                                <input type="number" class="input-field" id="lumVsLumY" step="0.01" min="0" max="1">
                            </div>
                        </div>
                        <div class="node-actions">
                            <button class="action-btn add" onclick="addNodeToCurve('lumVsLum')">+ Add</button>
                            <button class="action-btn delete" onclick="deleteActiveNode('lumVsLum')">Delete</button>
                        </div>
                    </div>
                </div>

                <!-- Per-Channel Curves -->
                <div class="section-header" style="margin-top: 25px;">Per-Channel Curves</div>
                <p style="color: #666; font-size: 10px; margin-bottom: 15px; line-height: 1.4;">
                    Simulate film dye layers. Usually kept neutral.
                </p>
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px;">
                    <div class="curve-section">
                        <div class="curve-title" style="color: #ff4444; font-size: 12px;">Red</div>
                        <div class="curve-canvas-wrapper">
                            <canvas id="redCurveCanvas" class="curve-canvas" width="200" height="130"></canvas>
                        </div>
                        <div class="node-controls" style="padding: 8px;">
                            <div class="node-select" id="redCurveNodeSelect" style="gap: 4px;"></div>
                        </div>
                    </div>
                    <div class="curve-section">
                        <div class="curve-title" style="color: #44ff44; font-size: 12px;">Green</div>
                        <div class="curve-canvas-wrapper">
                            <canvas id="greenCurveCanvas" class="curve-canvas" width="200" height="130"></canvas>
                        </div>
                        <div class="node-controls" style="padding: 8px;">
                            <div class="node-select" id="greenCurveNodeSelect" style="gap: 4px;"></div>
                        </div>
                    </div>
                    <div class="curve-section">
                        <div class="curve-title" style="color: #4444ff; font-size: 12px;">Blue</div>
                        <div class="curve-canvas-wrapper">
                            <canvas id="blueCurveCanvas" class="curve-canvas" width="200" height="130"></canvas>
                        </div>
                        <div class="node-controls" style="padding: 8px;">
                            <div class="node-select" id="blueCurveNodeSelect" style="gap: 4px;"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right Panel: Vectorscopes and Test Image -->
            <div class="right-panel">
                <div class="vectorscope-panel">
                    <div class="section-header" style="margin-top: 0;">Vectorscopes</div>

                    <!-- Path to White -->
                    <div class="vectorscope-container">
                        <div class="vectorscope-title">Path to White Analysis</div>
                        <canvas id="pathToWhite" class="vectorscope" width="300" height="300"></canvas>
                        <p style="color: #666; font-size: 10px; margin-top: 8px;">Achromatic line behavior</p>
                    </div>

                    <!-- Hue Saturation Response -->
                    <div class="vectorscope-grid">
                        <div class="vectorscope-container">
                            <div class="vectorscope-title">Hue ‚Üí Saturation</div>
                            <canvas id="vectorscope1" class="vectorscope" width="260" height="260"></canvas>
                            <p style="color: #666; font-size: 9px; margin-top: 6px;">Saturation per hue</p>
                        </div>
                        <div class="vectorscope-container">
                            <div class="vectorscope-title">With Hue Loops</div>
                            <canvas id="vectorscope2" class="vectorscope" width="260" height="260"></canvas>
                            <p style="color: #666; font-size: 9px; margin-top: 6px;">Hue rotation effect</p>
                        </div>
                    </div>

                    <!-- Hue Luminance and Lum Saturation -->
                    <div class="vectorscope-grid">
                        <div class="vectorscope-container">
                            <div class="vectorscope-title">Hue ‚Üí Luminance</div>
                            <canvas id="vectorscopeHueLum" class="vectorscope" width="260" height="260"></canvas>
                            <p style="color: #666; font-size: 9px; margin-top: 6px;">Luminance shifts</p>
                        </div>
                        <div class="vectorscope-container">
                            <div class="vectorscope-title">Lum ‚Üí Saturation</div>
                            <canvas id="vectorscopeLumSat" class="vectorscope" width="260" height="260"></canvas>
                            <p style="color: #666; font-size: 9px; margin-top: 6px;">Saturation by lum</p>
                        </div>
                    </div>
                </div>

                <div class="test-image-panel">
                    <div class="section-header" style="margin-top: 0;">Test Image Preview</div>

                    <div class="image-upload-section">
                        <div class="file-input-wrapper">
                            <button class="file-input-btn">üìÅ Upload Your Own Image</button>
                            <input type="file" accept="image/*" onchange="loadUserImage(event)">
                        </div>
                        <button class="export-btn" style="margin-top: 8px;" onclick="resetToGradient()">üîÑ Reset to Gradient</button>
                    </div>

                    <div style="margin-top: 15px;">
                        <div class="image-label">Original</div>
                        <canvas id="testImageOriginal" class="test-image" width="540" height="405"></canvas>
                        <div class="image-label" style="margin-top: 12px;">Processed (Live)</div>
                        <canvas id="testImageProcessed" class="test-image" width="540" height="405"></canvas>
                        <p style="color: #666; font-size: 10px; margin-top: 10px; line-height: 1.4;">
                            Updates in real-time. Upload your own images to test!
                        </p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ====================================================================
        // UNDO/REDO SYSTEM
        // ====================================================================
        let historyStack = [];
        let historyIndex = -1;
        const MAX_HISTORY = 50;

        function saveState() {
            const state = {};
            Object.entries(curves).forEach(([name, curve]) => {
                state[name] = JSON.parse(JSON.stringify(curve.getData()));
            });

            // Remove any redo states
            historyStack = historyStack.slice(0, historyIndex + 1);

            // Add new state
            historyStack.push(state);
            if (historyStack.length > MAX_HISTORY) {
                historyStack.shift();
            } else {
                historyIndex++;
            }

            updateUndoRedoButtons();
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                restoreState(historyStack[historyIndex]);
                updateUndoRedoButtons();
            }
        }

        function redo() {
            if (historyIndex < historyStack.length - 1) {
                historyIndex++;
                restoreState(historyStack[historyIndex]);
                updateUndoRedoButtons();
            }
        }

        function restoreState(state) {
            Object.entries(state).forEach(([name, points]) => {
                if (curves[name]) {
                    curves[name].setData(JSON.parse(JSON.stringify(points)));
                }
            });
            updateVectorscopes();
            updateTestImage();
            updateStats();
        }

        function updateUndoRedoButtons() {
            document.getElementById('undoBtn').disabled = historyIndex <= 0;
            document.getElementById('redoBtn').disabled = historyIndex >= historyStack.length - 1;
        }

        // UI Scale control
        function setUIScale(value) {
            document.documentElement.style.setProperty('--ui-scale', value);
            document.getElementById('scaleValue').textContent = Math.round(value * 100) + '%';
        }

        // Curve Editor Class
        class CurveEditor {
            constructor(canvasId, curveName, xRange, yRange, yLabel) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.curveName = curveName;
                this.xRange = xRange;
                this.yRange = yRange;
                this.yLabel = yLabel;
                this.points = [];
                this.selectedPoint = null;
                this.activeNodeIndex = null;
                this.isDragging = false;

                this.init();
            }

            init() {
                // Initialize with neutral curve
                if (this.yLabel === 'Shift' || this.yLabel === 'Offset') {
                    this.points = [[0, 0], [this.xRange[1], 0]];
                } else if (this.yLabel === 'Mult') {
                    this.points = [[0, 1], [this.xRange[1], 1]];
                } else {
                    this.points = [[0, 0], [this.xRange[1], this.xRange[1]]];
                }

                this.canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
                this.canvas.addEventListener('mousemove', this.onMouseMove.bind(this));
                this.canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
                this.canvas.addEventListener('mouseleave', this.onMouseUp.bind(this));

                this.draw();
                this.updateNodeButtons();
            }

            canvasToValue(cx, cy) {
                const x = (cx / this.canvas.width) * (this.xRange[1] - this.xRange[0]) + this.xRange[0];
                const y = this.yRange[1] - (cy / this.canvas.height) * (this.yRange[1] - this.yRange[0]);
                return [x, y];
            }

            valueToCanvas(x, y) {
                const cx = ((x - this.xRange[0]) / (this.xRange[1] - this.xRange[0])) * this.canvas.width;
                const cy = this.canvas.height - ((y - this.yRange[0]) / (this.yRange[1] - this.yRange[0])) * this.canvas.height;
                return [cx, cy];
            }

            findNearestPoint(mx, my, threshold = 15) {
                let nearest = null;
                let minDist = threshold;

                this.points.forEach((point, idx) => {
                    const [cx, cy] = this.valueToCanvas(point[0], point[1]);
                    const dist = Math.sqrt((mx - cx) ** 2 + (my - cy) ** 2);
                    if (dist < minDist) {
                        minDist = dist;
                        nearest = idx;
                    }
                });

                return nearest;
            }

            onMouseDown(e) {
                const rect = this.canvas.getBoundingClientRect();
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;
                const mx = (e.clientX - rect.left) * scaleX;
                const my = (e.clientY - rect.top) * scaleY;

                const nearest = this.findNearestPoint(mx, my);

                if (nearest !== null) {
                    this.selectedPoint = nearest;
                    this.activeNodeIndex = nearest;
                    this.isDragging = true;
                    this.updateNodeButtons();
                    this.updateInputFields();
                } else {
                    const [x, y] = this.canvasToValue(mx, my);
                    this.addPoint(x, y);
                }

                updateStats();
            }

            onMouseMove(e) {
                if (!this.isDragging || this.selectedPoint === null) return;

                const rect = this.canvas.getBoundingClientRect();
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;
                const mx = (e.clientX - rect.left) * scaleX;
                const my = (e.clientY - rect.top) * scaleY;

                const [x, y] = this.canvasToValue(mx, my);

                const clampedX = Math.max(this.xRange[0], Math.min(this.xRange[1], x));
                const clampedY = Math.max(this.yRange[0], Math.min(this.yRange[1], y));

                if (this.selectedPoint === 0 || this.selectedPoint === this.points.length - 1) {
                    this.points[this.selectedPoint][1] = clampedY;
                } else {
                    this.points[this.selectedPoint] = [clampedX, clampedY];
                }

                this.sortPoints();
                this.draw();
                this.updateInputFields();
                updateVectorscopes();
                updateTestImage();
            }

            onMouseUp(e) {
                if (this.isDragging) {
                    saveState(); // Save to history when drag ends
                }
                this.isDragging = false;
            }

            addPoint(x, y) {
                const clampedX = Math.max(this.xRange[0], Math.min(this.xRange[1], x));
                const clampedY = Math.max(this.yRange[0], Math.min(this.yRange[1], y));
                this.points.push([clampedX, clampedY]);
                this.sortPoints();
                this.activeNodeIndex = this.points.findIndex(p => p[0] === clampedX && p[1] === clampedY);
                this.draw();
                this.updateNodeButtons();
                this.updateInputFields();
                updateStats();
                updateVectorscopes();
                updateTestImage();
                saveState();
            }

            deletePoint(index) {
                if (this.points.length <= 2) {
                    alert('Cannot delete: must have at least 2 points');
                    return;
                }
                if (index === 0 || index === this.points.length - 1) {
                    alert('Cannot delete first or last point');
                    return;
                }
                this.points.splice(index, 1);
                this.activeNodeIndex = null;
                this.draw();
                this.updateNodeButtons();
                this.updateInputFields();
                updateStats();
                updateVectorscopes();
                updateTestImage();
                saveState();
            }

            sortPoints() {
                this.points.sort((a, b) => a[0] - b[0]);
            }

            setActiveNode(index) {
                this.activeNodeIndex = index;
                this.updateNodeButtons();
                this.updateInputFields();
            }

            updateNodeButtons() {
                const container = document.getElementById(this.curveName + 'NodeSelect');
                if (!container) return;

                container.innerHTML = '';
                this.points.forEach((point, idx) => {
                    const btn = document.createElement('button');
                    btn.className = 'node-btn' + (idx === this.activeNodeIndex ? ' active' : '');
                    btn.textContent = `N${idx + 1}`;
                    btn.onclick = () => this.setActiveNode(idx);
                    container.appendChild(btn);
                });
            }

            updateInputFields() {
                const xInput = document.getElementById(this.curveName + 'X');
                const yInput = document.getElementById(this.curveName + 'Y');

                if (!xInput || !yInput) return;

                if (this.activeNodeIndex !== null) {
                    const point = this.points[this.activeNodeIndex];
                    xInput.value = point[0].toFixed(2);
                    yInput.value = point[1].toFixed(2);

                    xInput.onchange = () => {
                        const newX = parseFloat(xInput.value);
                        if (this.activeNodeIndex !== 0 && this.activeNodeIndex !== this.points.length - 1) {
                            this.points[this.activeNodeIndex][0] = Math.max(this.xRange[0], Math.min(this.xRange[1], newX));
                            this.sortPoints();
                        }
                        this.draw();
                        updateVectorscopes();
                        updateTestImage();
                        saveState();
                    };

                    yInput.onchange = () => {
                        const newY = parseFloat(yInput.value);
                        this.points[this.activeNodeIndex][1] = Math.max(this.yRange[0], Math.min(this.yRange[1], newY));
                        this.draw();
                        updateVectorscopes();
                        updateTestImage();
                        saveState();
                    };
                } else {
                    xInput.value = '';
                    yInput.value = '';
                }
            }

            draw() {
                const ctx = this.ctx;
                const w = this.canvas.width;
                const h = this.canvas.height;

                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, w, h);

                // Grid
                ctx.strokeStyle = '#1a1a1a';
                ctx.lineWidth = 1;
                for (let i = 0; i <= 10; i++) {
                    const x = (i / 10) * w;
                    const y = (i / 10) * h;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, h);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(w, y);
                    ctx.stroke();
                }

                // Center/unity line
                if (this.yLabel === 'Shift' || this.yLabel === 'Offset') {
                    const zeroY = this.valueToCanvas(0, 0)[1];
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(0, zeroY);
                    ctx.lineTo(w, zeroY);
                    ctx.stroke();
                }

                if (this.yLabel === 'Mult' || this.yLabel === 'Out') {
                    ctx.strokeStyle = '#222';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    for (let i = 0; i <= 100; i++) {
                        const x = (i / 100) * (this.xRange[1] - this.xRange[0]) + this.xRange[0];
                        const y = (this.yLabel === 'Mult') ? 1 : x;
                        const [cx, cy] = this.valueToCanvas(x, y);
                        if (i === 0) ctx.moveTo(cx, cy);
                        else ctx.lineTo(cx, cy);
                    }
                    ctx.stroke();
                    ctx.setLineDash([]);
                }

                // Curve
                ctx.strokeStyle = '#0088ff';
                ctx.lineWidth = 3;
                ctx.beginPath();
                for (let i = 0; i <= 200; i++) {
                    const x = (i / 200) * (this.xRange[1] - this.xRange[0]) + this.xRange[0];
                    const y = this.interpolate(x);
                    const [cx, cy] = this.valueToCanvas(x, y);
                    if (i === 0) ctx.moveTo(cx, cy);
                    else ctx.lineTo(cx, cy);
                }
                ctx.stroke();

                // Points
                this.points.forEach((point, idx) => {
                    const [cx, cy] = this.valueToCanvas(point[0], point[1]);
                    ctx.fillStyle = idx === this.activeNodeIndex ? '#ff4444' : '#fff';
                    ctx.beginPath();
                    ctx.arc(cx, cy, idx === this.activeNodeIndex ? 8 : 6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                });
            }

            interpolate(x) {
                if (x <= this.points[0][0]) return this.points[0][1];
                if (x >= this.points[this.points.length - 1][0]) return this.points[this.points.length - 1][1];

                for (let i = 0; i < this.points.length - 1; i++) {
                    const x1 = this.points[i][0];
                    const x2 = this.points[i + 1][0];

                    if (x >= x1 && x <= x2) {
                        const y1 = this.points[i][1];
                        const y2 = this.points[i + 1][1];

                        const x0 = i > 0 ? this.points[i - 1][0] : x1;
                        const y0 = i > 0 ? this.points[i - 1][1] : y1;
                        const x3 = i < this.points.length - 2 ? this.points[i + 2][0] : x2;
                        const y3 = i < this.points.length - 2 ? this.points[i + 2][1] : y2;

                        const m1 = i > 0 ? (y2 - y0) / (x2 - x0) : (y2 - y1) / (x2 - x1);
                        const m2 = i < this.points.length - 2 ? (y3 - y1) / (x3 - x1) : (y2 - y1) / (x2 - x1);

                        const t = (x - x1) / (x2 - x1);
                        const t2 = t * t;
                        const t3 = t2 * t;

                        const h00 = 2*t3 - 3*t2 + 1;
                        const h10 = t3 - 2*t2 + t;
                        const h01 = -2*t3 + 3*t2;
                        const h11 = t3 - t2;

                        return h00*y1 + h10*(x2-x1)*m1 + h01*y2 + h11*(x2-x1)*m2;
                    }
                }

                return this.points[this.points.length - 1][1];
            }

            getData() {
                return this.points;
            }

            setData(points) {
                this.points = points;
                this.sortPoints();
                this.draw();
                this.updateNodeButtons();
            }
        }

        // Initialize all curve editors (NOW INCLUDING lumVsHue)
        const curves = {
            hueVsHue: new CurveEditor('hueVsHueCanvas', 'hueVsHue', [0, 360], [-30, 30], 'Shift'),
            hueVsSat: new CurveEditor('hueVsSatCanvas', 'hueVsSat', [0, 360], [0, 2], 'Mult'),
            hueVsLum: new CurveEditor('hueVsLumCanvas', 'hueVsLum', [0, 360], [-0.2, 0.2], 'Offset'),
            lumVsHue: new CurveEditor('lumVsHueCanvas', 'lumVsHue', [0, 1], [-30, 30], 'Shift'),
            satVsSat: new CurveEditor('satVsSatCanvas', 'satVsSat', [0, 1], [0, 1], 'Out'),
            satVsLum: new CurveEditor('satVsLumCanvas', 'satVsLum', [0, 1], [-0.2, 0.2], 'Offset'),
            lumVsSat: new CurveEditor('lumVsSatCanvas', 'lumVsSat', [0, 1], [0, 2], 'Mult'),
            lumVsLum: new CurveEditor('lumVsLumCanvas', 'lumVsLum', [0, 1], [0, 1], 'Out'),
            redCurve: new CurveEditor('redCurveCanvas', 'redCurve', [0, 1], [0, 1], 'Out'),
            greenCurve: new CurveEditor('greenCurveCanvas', 'greenCurve', [0, 1], [0, 1], 'Out'),
            blueCurve: new CurveEditor('blueCurveCanvas', 'blueCurve', [0, 1], [0, 1], 'Out')
        };

        // Save initial state
        saveState();

        // ====================================================================
        // COLOR PROCESSING
        // ====================================================================

        // HSV conversion functions
        function rgbToHsv(r, g, b) {
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            const delta = max - min;

            let h = 0;
            if (delta > 0) {
                if (max === r) h = 60 * (((g - b) / delta) % 6);
                else if (max === g) h = 60 * (((b - r) / delta) + 2);
                else h = 60 * (((r - g) / delta) + 4);
            }
            if (h < 0) h += 360;

            const s = max === 0 ? 0 : delta / max;
            const v = max;

            return [h, s, v];
        }

        function hsvToRgb(h, s, v) {
            const c = v * s;
            const x = c * (1 - Math.abs((h / 60) % 2 - 1));
            const m = v - c;

            let r, g, b;
            if (h >= 0 && h < 60) { r = c; g = x; b = 0; }
            else if (h >= 60 && h < 120) { r = x; g = c; b = 0; }
            else if (h >= 120 && h < 180) { r = 0; g = c; b = x; }
            else if (h >= 180 && h < 240) { r = 0; g = x; b = c; }
            else if (h >= 240 && h < 300) { r = x; g = 0; b = c; }
            else { r = c; g = 0; b = x; }

            return [r + m, g + m, b + m];
        }

        // Apply curves to a color (NOW INCLUDING lumVsHue)
        function processColor(r, g, b) {
            let [h, s, v] = rgbToHsv(r, g, b);

            // Apply curves
            h = h + curves.hueVsHue.interpolate(h);
            h = (h + 360) % 360;

            s = s * curves.hueVsSat.interpolate(h);
            s = Math.max(0, Math.min(1, s));

            v = v + curves.hueVsLum.interpolate(h);
            v = Math.max(0, Math.min(1, v));

            s = curves.satVsSat.interpolate(s);
            v = v + curves.satVsLum.interpolate(s);

            s = s * curves.lumVsSat.interpolate(v);

            // NEW: Apply luminance-dependent hue shift
            h = h + curves.lumVsHue.interpolate(v);
            h = (h + 360) % 360;

            v = curves.lumVsLum.interpolate(v);

            s = Math.max(0, Math.min(1, s));
            v = Math.max(0, Math.min(1, v));

            [r, g, b] = hsvToRgb(h, s, v);

            r = curves.redCurve.interpolate(r);
            g = curves.greenCurve.interpolate(g);
            b = curves.blueCurve.interpolate(b);

            return [
                Math.max(0, Math.min(255, r * 255)),
                Math.max(0, Math.min(255, g * 255)),
                Math.max(0, Math.min(255, b * 255))
            ];
        }

        // ====================================================================
        // VECTORSCOPE RENDERING
        // ====================================================================

        function updateVectorscopes() {
            updatePathToWhite();
            updateHueSatVectorscope();
            updateHueLoopsVectorscope();
            updateHueLumVectorscope();
            updateLumSatVectorscope();
        }

        function updatePathToWhite() {
            const canvas = document.getElementById('pathToWhite');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            const centerX = w / 2;
            const centerY = h / 2;

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, w, h);

            // Grid circles
            ctx.strokeStyle = '#1a1a1a';
            ctx.lineWidth = 1;
            for (let i = 1; i <= 3; i++) {
                ctx.beginPath();
                ctx.arc(centerX, centerY, (w / 2) * (i / 3), 0, Math.PI * 2);
                ctx.stroke();
            }

            // Draw hue spokes
            for (let hue = 0; hue < 360; hue += 30) {
                const angle = (hue - 90) * Math.PI / 180;
                ctx.strokeStyle = hue % 60 === 0 ? '#333' : '#222';
                ctx.lineWidth = hue % 60 === 0 ? 2 : 1;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(centerX + Math.cos(angle) * w / 2, centerY + Math.sin(angle) * h / 2);
                ctx.stroke();
            }

            // Process achromatic line (0-1 luminance, no saturation)
            for (let lum = 0; lum <= 1; lum += 0.005) {
                const [r, g, b] = hsvToRgb(0, 0, lum);
                const [pr, pg, pb] = processColor(r, g, b);
                const [ph, ps, pv] = rgbToHsv(pr / 255, pg / 255, pb / 255);

                const angle = (ph - 90) * Math.PI / 180;
                const radius = ps * (w / 2);
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;

                const brightness = Math.floor(pv * 255);
                ctx.fillStyle = `rgb(${brightness}, ${brightness}, ${brightness})`;
                ctx.fillRect(x - 2, y - 2, 4, 4);
            }
        }

        function updateHueSatVectorscope() {
            const canvas = document.getElementById('vectorscope1');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            const centerX = w / 2;
            const centerY = h / 2;

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, w, h);

            // Grid
            ctx.strokeStyle = '#1a1a1a';
            ctx.lineWidth = 1;
            for (let i = 1; i <= 3; i++) {
                ctx.beginPath();
                ctx.arc(centerX, centerY, (w / 2) * (i / 3), 0, Math.PI * 2);
                ctx.stroke();
            }

            // Hue spokes
            const hueColors = [
                [0, 'R'], [60, 'Y'], [120, 'G'], [180, 'C'], [240, 'B'], [300, 'M']
            ];
            hueColors.forEach(([hue, label]) => {
                const angle = (hue - 90) * Math.PI / 180;
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(centerX + Math.cos(angle) * w / 2, centerY + Math.sin(angle) * h / 2);
                ctx.stroke();

                ctx.fillStyle = '#666';
                ctx.font = '14px monospace';
                ctx.fillText(label, centerX + Math.cos(angle) * (w / 2 - 20), centerY + Math.sin(angle) * (h / 2 - 20));
            });

            // Sample hue response at various saturations
            for (let hue = 0; hue < 360; hue += 2) {
                for (let sat = 0.2; sat <= 1.0; sat += 0.1) {
                    const [r, g, b] = hsvToRgb(hue, sat, 0.5);
                    const [pr, pg, pb] = processColor(r, g, b);
                    const [ph, ps, pv] = rgbToHsv(pr / 255, pg / 255, pb / 255);

                    const angle = (ph - 90) * Math.PI / 180;
                    const radius = ps * (w / 2);
                    const x = centerX + Math.cos(angle) * radius;
                    const y = centerY + Math.sin(angle) * radius;

                    const [dr, dg, db] = hsvToRgb(ph, ps, pv);
                    ctx.fillStyle = `rgb(${dr*255}, ${dg*255}, ${db*255})`;
                    ctx.fillRect(x - 1, y - 1, 2, 2);
                }
            }
        }

        function updateHueLoopsVectorscope() {
            const canvas = document.getElementById('vectorscope2');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            const centerX = w / 2;
            const centerY = h / 2;

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, w, h);

            // Grid
            ctx.strokeStyle = '#1a1a1a';
            ctx.lineWidth = 1;
            for (let i = 1; i <= 3; i++) {
                ctx.beginPath();
                ctx.arc(centerX, centerY, (w / 2) * (i / 3), 0, Math.PI * 2);
                ctx.stroke();
            }

            // Hue spokes
            const hueColors = [
                [0, 'R'], [60, 'Y'], [120, 'G'], [180, 'C'], [240, 'B'], [300, 'M']
            ];
            hueColors.forEach(([hue, label]) => {
                const angle = (hue - 90) * Math.PI / 180;
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(centerX + Math.cos(angle) * w / 2, centerY + Math.sin(angle) * h / 2);
                ctx.stroke();

                ctx.fillStyle = '#666';
                ctx.font = '14px monospace';
                ctx.fillText(label, centerX + Math.cos(angle) * (w / 2 - 20), centerY + Math.sin(angle) * (h / 2 - 20));
            });

            // Sample full saturation range showing hue loop potential
            for (let hue = 0; hue < 360; hue += 1) {
                for (let sat = 0; sat <= 1.0; sat += 0.02) {
                    const [r, g, b] = hsvToRgb(hue, sat, 0.5);
                    const [pr, pg, pb] = processColor(r, g, b);
                    const [ph, ps, pv] = rgbToHsv(pr / 255, pg / 255, pb / 255);

                    const angle = (ph - 90) * Math.PI / 180;
                    const radius = ps * (w / 2);
                    const x = centerX + Math.cos(angle) * radius;
                    const y = centerY + Math.sin(angle) * radius;

                    const [dr, dg, db] = hsvToRgb(ph, Math.min(ps, 1), pv);
                    ctx.fillStyle = `rgb(${dr*255}, ${dg*255}, ${db*255})`;
                    ctx.fillRect(x - 1, y - 1, 2, 2);
                }
            }
        }

        function updateHueLumVectorscope() {
            const canvas = document.getElementById('vectorscopeHueLum');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            const centerX = w / 2;
            const centerY = h / 2;

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, w, h);

            // Grid
            ctx.strokeStyle = '#1a1a1a';
            ctx.lineWidth = 1;
            for (let i = 1; i <= 3; i++) {
                ctx.beginPath();
                ctx.arc(centerX, centerY, (w / 2) * (i / 3), 0, Math.PI * 2);
                ctx.stroke();
            }

            // Hue spokes
            const hueColors = [
                [0, 'R'], [60, 'Y'], [120, 'G'], [180, 'C'], [240, 'B'], [300, 'M']
            ];
            hueColors.forEach(([hue, label]) => {
                const angle = (hue - 90) * Math.PI / 180;
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(centerX + Math.cos(angle) * w / 2, centerY + Math.sin(angle) * h / 2);
                ctx.stroke();

                ctx.fillStyle = '#666';
                ctx.font = '14px monospace';
                ctx.fillText(label, centerX + Math.cos(angle) * (w / 2 - 20), centerY + Math.sin(angle) * (h / 2 - 20));
            });

            // Sample hue vs luminance (showing how luminance changes per hue)
            for (let hue = 0; hue < 360; hue += 2) {
                const sat = 0.7;
                const [r, g, b] = hsvToRgb(hue, sat, 0.5);
                const [pr, pg, pb] = processColor(r, g, b);
                const [ph, ps, pv] = rgbToHsv(pr / 255, pg / 255, pb / 255);

                const angle = (ph - 90) * Math.PI / 180;
                const radius = pv * (w / 2); // Use luminance as radius
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;

                const [dr, dg, db] = hsvToRgb(ph, ps, pv);
                ctx.fillStyle = `rgb(${dr*255}, ${dg*255}, ${db*255})`;
                ctx.fillRect(x - 2, y - 2, 4, 4);
            }
        }

        function updateLumSatVectorscope() {
            const canvas = document.getElementById('vectorscopeLumSat');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, w, h);

            // Grid
            ctx.strokeStyle = '#1a1a1a';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 10; i++) {
                const x = (i / 10) * w;
                const y = (i / 10) * h;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, h);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(w, y);
                ctx.stroke();
            }

            // Labels
            ctx.fillStyle = '#666';
            ctx.font = '12px monospace';
            ctx.fillText('Lum ‚Üí', 5, 15);
            ctx.save();
            ctx.translate(15, h - 5);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Sat ‚Üí', 0, 0);
            ctx.restore();

            // Sample luminance vs saturation
            for (let lum = 0; lum <= 1; lum += 0.02) {
                for (let sat = 0; sat <= 1; sat += 0.02) {
                    const hue = 30; // Sample at a specific hue (yellow-orange)
                    const [r, g, b] = hsvToRgb(hue, sat, lum);
                    const [pr, pg, pb] = processColor(r, g, b);
                    const [ph, ps, pv] = rgbToHsv(pr / 255, pg / 255, pb / 255);

                    const x = lum * w;
                    const y = h - (ps * h); // Inverted Y axis

                    const [dr, dg, db] = hsvToRgb(ph, ps, pv);
                    ctx.fillStyle = `rgb(${dr*255}, ${dg*255}, ${db*255})`;
                    ctx.fillRect(x - 1, y - 1, 2, 2);
                }
            }
        }

        // ====================================================================
        // TEST IMAGE GENERATION AND PROCESSING
        // ====================================================================

        let currentImageData = null;

        function generateTestGradient() {
            const canvas = document.getElementById('testImageOriginal');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;

            const imageData = ctx.createImageData(w, h);
            const data = imageData.data;

            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const hue = (x / w) * 360;
                    const sat = 1.0;
                    const lum = 1.0 - (y / h);

                    const [r, g, b] = hsvToRgb(hue, sat, lum);

                    const idx = (y * w + x) * 4;
                    data[idx] = r * 255;
                    data[idx + 1] = g * 255;
                    data[idx + 2] = b * 255;
                    data[idx + 3] = 255;
                }
            }

            ctx.putImageData(imageData, 0, 0);
            currentImageData = imageData;
            updateTestImage();
        }

        function updateTestImage() {
            if (!currentImageData) return;

            const srcCanvas = document.getElementById('testImageOriginal');
            const dstCanvas = document.getElementById('testImageProcessed');
            const srcCtx = srcCanvas.getContext('2d');
            const dstCtx = dstCanvas.getContext('2d');

            const srcData = srcCtx.getImageData(0, 0, srcCanvas.width, srcCanvas.height);
            const dstData = dstCtx.createImageData(srcCanvas.width, srcCanvas.height);

            const src = srcData.data;
            const dst = dstData.data;

            for (let i = 0; i < src.length; i += 4) {
                const r = src[i] / 255;
                const g = src[i + 1] / 255;
                const b = src[i + 2] / 255;

                const [pr, pg, pb] = processColor(r, g, b);

                dst[i] = pr;
                dst[i + 1] = pg;
                dst[i + 2] = pb;
                dst[i + 3] = src[i + 3];
            }

            dstCtx.putImageData(dstData, 0, 0);
        }

        function loadUserImage(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    const canvas = document.getElementById('testImageOriginal');
                    const ctx = canvas.getContext('2d');

                    // Draw image scaled to canvas
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

                    // Store image data
                    currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

                    // Process it
                    updateTestImage();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function resetToGradient() {
            generateTestGradient();
        }

        // ====================================================================
        // PRESET LOADING
        // ====================================================================

        const presets = {
            neutral: {
                hueVsHue: [[0, 0], [360, 0]],
                hueVsSat: [[0, 1], [360, 1]],
                hueVsLum: [[0, 0], [360, 0]],
                lumVsHue: [[0, 0], [1, 0]],
                satVsSat: [[0, 0], [1, 1]],
                satVsLum: [[0, 0], [1, 0]],
                lumVsSat: [[0, 1], [1, 1]],
                lumVsLum: [[0, 0], [1, 1]],
                redCurve: [[0, 0], [1, 1]],
                greenCurve: [[0, 0], [1, 1]],
                blueCurve: [[0, 0], [1, 1]]
            },
            velvia: {
                hueVsHue: [[0, 0], [30, 5], [60, 3], [120, -2], [180, 0], [240, 2], [300, -3], [360, 0]],
                hueVsSat: [[0, 1.15], [60, 1.25], [120, 1.3], [180, 1.2], [240, 1.1], [300, 1.05], [360, 1.15]],
                hueVsLum: [[0, 0], [60, 0.02], [120, 0.05], [240, -0.03], [360, 0]],
                lumVsHue: [[0, 0], [1, 0]],
                satVsSat: [[0, 0], [0.3, 0.35], [0.7, 0.8], [1, 0.95]],
                satVsLum: [[0, 0], [0.5, -0.02], [1, -0.05]],
                lumVsSat: [[0, 0.6], [0.2, 1.1], [0.5, 1.15], [0.8, 1.05], [1, 0.7]],
                lumVsLum: [[0, 0], [0.25, 0.22], [0.5, 0.55], [0.75, 0.8], [1, 1]],
                redCurve: [[0, 0], [1, 1]],
                greenCurve: [[0, 0], [1, 1]],
                blueCurve: [[0, 0], [1, 1]]
            },
            portra: {
                hueVsHue: [[0, 0], [30, -3], [60, -2], [180, 2], [240, 1], [300, 5], [360, 0]],
                hueVsSat: [[0, 1.1], [30, 0.95], [120, 1.05], [180, 0.98], [240, 1.0], [300, 1.15], [360, 1.1]],
                hueVsLum: [[0, 0.03], [30, 0.05], [60, 0.02], [240, -0.01], [360, 0.03]],
                lumVsHue: [[0, 0], [1, 0]],
                satVsSat: [[0, 0], [0.3, 0.32], [0.7, 0.75], [1, 0.88]],
                satVsLum: [[0, 0], [0.5, 0.01], [1, 0.02]],
                lumVsSat: [[0, 0.5], [0.2, 1.0], [0.5, 1.1], [0.8, 1.0], [1, 0.6]],
                lumVsLum: [[0, 0.02], [0.25, 0.25], [0.5, 0.52], [0.75, 0.78], [1, 0.98]],
                redCurve: [[0, 0], [1, 1]],
                greenCurve: [[0, 0], [1, 1]],
                blueCurve: [[0, 0], [1, 1]]
            },
            cinestill: {
                hueVsHue: [[0, 8], [60, 2], [120, -3], [180, 12], [240, 5], [300, 3], [360, 8]],
                hueVsSat: [[0, 1.2], [60, 1.15], [120, 1.1], [180, 1.35], [240, 1.25], [300, 1.2], [360, 1.2]],
                hueVsLum: [[0, -0.05], [180, -0.08], [240, -0.03], [360, -0.05]],
                lumVsHue: [[0, 0], [1, 0]],
                satVsSat: [[0, 0], [0.3, 0.33], [0.7, 0.78], [1, 0.92]],
                satVsLum: [[0, 0], [0.5, -0.03], [1, -0.06]],
                lumVsSat: [[0, 0.7], [0.2, 1.15], [0.5, 1.2], [0.8, 1.1], [1, 0.8]],
                lumVsLum: [[0, 0.05], [0.25, 0.23], [0.5, 0.5], [0.75, 0.77], [1, 0.95]],
                redCurve: [[0, 0], [1, 1]],
                greenCurve: [[0, 0], [1, 1]],
                blueCurve: [[0, 0], [0.5, 0.48], [1, 1]]
            },
            teal_orange: {
                hueVsHue: [[0, 15], [30, 10], [60, 5], [120, -10], [180, -15], [240, 0], [300, 20], [360, 15]],
                hueVsSat: [[0, 1.3], [30, 1.35], [120, 1.15], [180, 1.4], [240, 1.05], [300, 1.25], [360, 1.3]],
                hueVsLum: [[0, 0.05], [30, 0.08], [180, -0.05], [360, 0.05]],
                lumVsHue: [[0, 0], [1, 0]],
                satVsSat: [[0, 0], [0.3, 0.38], [0.7, 0.82], [1, 0.98]],
                satVsLum: [[0, 0], [0.5, -0.02], [1, -0.04]],
                lumVsSat: [[0, 0.6], [0.2, 1.2], [0.5, 1.25], [0.8, 1.15], [1, 0.7]],
                lumVsLum: [[0, 0.03], [0.25, 0.27], [0.5, 0.53], [0.75, 0.8], [1, 0.97]],
                redCurve: [[0, 0], [1, 1]],
                greenCurve: [[0, 0], [1, 1]],
                blueCurve: [[0, 0], [1, 1]]
            },
            agfa: {
                hueVsHue: [[0, -5], [60, -8], [120, 3], [180, 5], [240, -2], [300, -3], [360, -5]],
                hueVsSat: [[0, 1.05], [60, 1.2], [120, 1.1], [180, 1.15], [240, 1.0], [300, 1.05], [360, 1.05]],
                hueVsLum: [[0, -0.02], [60, 0.03], [120, 0.02], [240, -0.02], [360, -0.02]],
                lumVsHue: [[0, 0], [1, 0]],
                satVsSat: [[0, 0], [0.3, 0.34], [0.7, 0.76], [1, 0.9]],
                satVsLum: [[0, 0], [0.5, 0], [1, 0]],
                lumVsSat: [[0, 0.55], [0.2, 1.05], [0.5, 1.15], [0.8, 1.05], [1, 0.65]],
                lumVsLum: [[0, 0.01], [0.25, 0.26], [0.5, 0.54], [0.75, 0.79], [1, 0.99]],
                redCurve: [[0, 0], [1, 1]],
                greenCurve: [[0, 0], [1, 1]],
                blueCurve: [[0, 0], [1, 1]]
            }
        };

        function loadPreset(presetName) {
            const preset = presets[presetName];
            if (!preset) return;

            Object.entries(preset).forEach(([curveName, points]) => {
                if (curves[curveName]) {
                    curves[curveName].setData(JSON.parse(JSON.stringify(points)));
                }
            });

            // Update active preset button
            document.querySelectorAll('.preset-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');

            updateVectorscopes();
            updateTestImage();
            updateStats();
            saveState();
        }

        // ====================================================================
        // EXPORT FUNCTIONS
        // ====================================================================

        function exportDCTLPreset() {
            const presetName = document.getElementById('presetName').value || 'CUSTOM';

            let dctl = `// ${presetName} Preset - Generated by Film Emulation Preset Creator v5\n\n`;

            Object.entries(curves).forEach(([name, curve]) => {
                const points = curve.getData();
                dctl += `__CONSTANT__ float ${name}_${presetName}[][2] = {\n`;
                points.forEach((point, idx) => {
                    const x = point[0].toFixed(4) + 'f';
                    const y = point[1].toFixed(4) + 'f';
                    dctl += `    {${x}, ${y}}${idx < points.length - 1 ? ',' : ''}\n`;
                });
                dctl += `};\n\n`;
            });

            navigator.clipboard.writeText(dctl).then(() => {
                alert('DCTL preset copied to clipboard!');
            });
        }

        function exportJSON() {
            const data = {};
            Object.entries(curves).forEach(([name, curve]) => {
                data[name] = curve.getData();
            });

            const json = JSON.stringify(data, null, 2);
            navigator.clipboard.writeText(json).then(() => {
                alert('JSON exported to clipboard!');
            });
        }

        function toggleImportSection() {
            const section = document.getElementById('importSection');
            section.style.display = section.style.display === 'none' ? 'block' : 'none';
        }

        function importDCTL() {
            const text = document.getElementById('importTextarea').value;
            if (!text) return;

            try {
                // Parse DCTL curve declarations
                const curveRegex = /__CONSTANT__\s+float\s+(\w+)(?:_\w+)?\[\]\[2\]\s*=\s*\{([^}]+)\}/g;
                let match;

                while ((match = curveRegex.exec(text)) !== null) {
                    const curveName = match[1];
                    const pointsText = match[2];

                    // Parse points
                    const pointMatches = pointsText.matchAll(/\{\s*([\d.+-]+)f?\s*,\s*([\d.+-]+)f?\s*\}/g);
                    const points = [];

                    for (const pm of pointMatches) {
                        points.push([parseFloat(pm[1]), parseFloat(pm[2])]);
                    }

                    if (curves[curveName] && points.length >= 2) {
                        curves[curveName].setData(points);
                    }
                }

                updateVectorscopes();
                updateTestImage();
                updateStats();
                saveState();
                alert('DCTL imported successfully!');
            } catch (e) {
                alert('Error parsing DCTL: ' + e.message);
            }
        }

        // ====================================================================
        // HELPER FUNCTIONS
        // ====================================================================

        function addNodeToCurve(curveName) {
            if (!curves[curveName]) return;

            const curve = curves[curveName];
            const points = curve.getData();

            // Find midpoint between two center points
            const midIdx = Math.floor(points.length / 2);
            const p1 = points[midIdx - 1] || points[0];
            const p2 = points[midIdx] || points[points.length - 1];

            const newX = (p1[0] + p2[0]) / 2;
            const newY = (p1[1] + p2[1]) / 2;

            curve.addPoint(newX, newY);
        }

        function deleteActiveNode(curveName) {
            if (!curves[curveName]) return;

            const curve = curves[curveName];
            if (curve.activeNodeIndex !== null) {
                curve.deletePoint(curve.activeNodeIndex);
            }
        }

        function updateStats() {
            let totalNodes = 0;
            let activeCurve = '-';
            let activeNode = '-';

            Object.entries(curves).forEach(([name, curve]) => {
                totalNodes += curve.getData().length;
                if (curve.activeNodeIndex !== null) {
                    activeCurve = name;
                    activeNode = curve.activeNodeIndex + 1;
                }
            });

            document.getElementById('totalNodes').textContent = totalNodes;
            document.getElementById('activeCurve').textContent = activeCurve;
            document.getElementById('activeNode').textContent = activeNode;
        }

        // ====================================================================
        // INITIALIZATION
        // ====================================================================

        generateTestGradient();
        updateVectorscopes();
        updateStats();

    </script>
</body>
</html>