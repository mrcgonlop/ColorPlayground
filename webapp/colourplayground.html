if (x >= x1 && x <= x2) {
                    const t = (x - x1) / (x2 - x1);
                    
                    const [x0, y0] = i > 0 ? points[i - 1] : [x1, y1];
                    const [x3, y3] = i < points.length - 2 ? points[i + 2] : [x2, y2];
                    
                    const m1 = i > 0 ? (y2 - y0) / (x2 - x0) : (y2 - y1) / (x2 - x1);
                    const m2 = i < points.length - 2 ? (y3 - y1) / (x3 - x1) : (y2 - y1) / (x2 - x1);
                    
                    const t2 = t * t;
                    const t3 = t2 * t;
                    const h00 = 2*t3 - 3*t2 + 1;
                    const h10 = t3 - 2*t2 + t;
                    const h01 = -2*t3 + 3*t2;
                    const h11 = t3 - t2;
                    
                    return h00*y1 + h10*(x2-x1)*m1 + h01*y2 + h11*(x2-x1)*m2;
                }
            }
            return points[points.length - 1][1];
        }
        
        // ========================================================================
        // TRANSFORM STATE
        // ========================================================================
        
        const transform = {
            hueVsHue: [[0, 0], [360, 0]],
            hueVsSat: [[0, 1], [360, 1]],
            hueVsLum: [[0, 0], [360, 0]],
            satVsSat: [[0, 0], [1, 1]],
            satVsLum: [[0, 0], [1, 0]],
            lumVsSat: [[0, 1], [1, 1]],
            lumVsLum: [[0, 0], [1, 1]],
            redCurve: [[0, 0], [1, 1]],
            greenCurve: [[0, 0], [1, 1]],
            blueCurve: [[0, 0], [1, 1]],
            globalExposure: 1.0,
            globalSaturation: 1.0,
            globalContrast: 1.0
        };
        
        function transformColor(r, g, b) {
            let h, s, v;
            
            // Convert based on mode
            if (currentColorMode === 'hsv') {
                [h, s, v] = rgbToHsv(r, g, b);
            } else if (currentColorMode === 'lch') {
                [v, s, h] = rgbToLch(r, g, b); // L, C, H
                v = v / 100; // Normalize L to 0-1
                s = s / 128; // Normalize C (approximate max chroma)
            } else { // ycbcr
                [v, s, h] = rgbToYcbcr(r, g, b); // Y, Cb, Cr
                // Convert Cb, Cr to polar (hue/chroma)
                const cb = s - 0.5;
                const cr = h - 0.5;
                s = Math.sqrt(cb*cb + cr*cr) * 2; // Chroma
                h = Math.atan2(cr, cb) * 180 / Math.PI;
                if (h < 0) h += 360;
            }
            
            // Apply hue shift
            const hueShift = cubicSplineInterpolate(h, transform.hueVsHue);
            h = (h + hueShift) % 360;
            if (h < 0) h += 360;
            
            // Apply hue-dependent saturation
            const satMult = cubicSplineInterpolate(h, transform.hueVsSat);
            s = Math.max(0, Math.min(currentColorMode === 'lch' ? 2 : 1, s * satMult));
            
            // Apply hue-dependent luminance
            const lumOffset = cubicSplineInterpolate(h, transform.hueVsLum);
            v = Math.max(0, Math.min(1, v + lumOffset));
            
            // Apply saturation-dependent saturation (non-linear)
            const satCurve = cubicSplineInterpolate(s, transform.satVsSat);
            s = Math.max(0, Math.min(currentColorMode === 'lch' ? 2 : 1, satCurve));
            
            // Apply saturation-dependent luminance
            const satLumOffset = cubicSplineInterpolate(s, transform.satVsLum);
            v = Math.max(0, Math.min(1, v + satLumOffset));
            
            // Apply luminance-dependent saturation
            const lumSatMult = cubicSplineInterpolate(v, transform.lumVsSat);
            s = Math.max(0, Math.min(currentColorMode === 'lch' ? 2 : 1, s * lumSatMult));
            
            // Apply global saturation
            s = Math.max(0, Math.min(currentColorMode === 'lch' ? 2 : 1, s * transform.globalSaturation));
            
            // Apply tone curve
            v = cubicSplineInterpolate(v, transform.lumVsLum);
            
            // Apply contrast around midpoint
            v = 0.5 + (v - 0.5) * transform.globalContrast;
            
            // Apply exposure
            v = Math.max(0, Math.min(1, v * transform.globalExposure));
            
            // Convert back to RGB
            let rOut, gOut, bOut;
            if (currentColorMode === 'hsv') {
                [rOut, gOut, bOut] = hsvToRgb(h, s, v);
            } else if (currentColorMode === 'lch') {
                [rOut, gOut, bOut] = lchToRgb(v * 100, s * 128, h);
            } else { // ycbcr
                // Convert polar back to Cb, Cr
                const cb = (s / 2) * Math.cos(h * Math.PI / 180) + 0.5;
                const cr = (s / 2) * Math.sin(h * Math.PI / 180) + 0.5;
                [rOut, gOut, bOut] = ycbcrToRgb(v, cb, cr);
            }
            
            // Apply per-channel curves
            rOut = cubicSplineInterpolate(rOut, transform.redCurve);
            gOut = cubicSplineInterpolate(gOut, transform.greenCurve);
            bOut = cubicSplineInterpolate(bOut, transform.blueCurve);
            
            return [
                Math.max(0, Math.min(1, rOut)),
                Math.max(0, Math.min(1, gOut)),
                Math.max(0, Math.min(1, bOut))
            ];
        }
        
        // ========================================================================
        // CURVE EDITOR
        // ========================================================================
        
        class CurveEditor {
            constructor(canvasId, curveName, infoId, xRange, yRange, yLabel) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.curveName = curveName;
                this.infoEl = infoId ? document.getElementById(infoId) : null;
                this.xRange = xRange;
                this.yRange = yRange;
                this.yLabel = yLabel;
                this.draggingPoint = null;
                
                this.canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
                this.canvas.addEventListener('mousemove', this.onMouseMove.bind(this));
                this.canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
                this.canvas.addEventListener('mouseleave', this.onMouseUp.bind(this));
                
                this.draw();
            }
            
            canvasToValue(cx, cy) {
                const x = (cx / this.canvas.width) * this.xRange[1];
                const y = this.yRange[1] - (cy / this.canvas.height) * (this.yRange[1] - this.yRange[0]);
                return [x, y];
            }
            
            valueToCanvas(x, y) {
                const cx = (x / this.xRange[1]) * this.canvas.width;
                const cy = this.canvas.height - ((y - this.yRange[0]) / (this.yRange[1] - this.yRange[0])) * this.canvas.height;
                return [cx, cy];
            }
            
            onMouseDown(e) {
                const rect = this.canvas.getBoundingClientRect();
                const mx = e.clientX - rect.left;
                const my = e.clientY - rect.top;
                
                const points = transform[this.curveName];
                
                // Check if clicking near existing point
                for (let i = 0; i < points.length; i++) {
                    const [cx, cy] = this.valueToCanvas(points[i][0], points[i][1]);
                    const dist = Math.sqrt((mx - cx)**2 + (my - cy)**2);
                    if (dist < 8) {
                        this.draggingPoint = i;
                        return;
                    }
                }
                
                // Add new point
                const [x, y] = this.canvasToValue(mx, my);
                points.push([x, y]);
                points.sort((a, b) => a[0] - b[0]);
                this.draggingPoint = points.findIndex(p => p[0] === x && p[1] === y);
                
                this.draw();
                updateVisualization();
            }
            
            onMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                const mx = e.clientX - rect.left;
                const my = e.clientY - rect.top;
                
                if (this.draggingPoint !== null) {
                    const [x, y] = this.canvasToValue(mx, my);
                    const points = transform[this.curveName];
                    
                    // Clamp values
                    const clampedX = Math.max(this.xRange[0], Math.min(this.xRange[1], x));
                    const clampedY = Math.max(this.yRange[0], Math.min(this.yRange[1], y));
                    
                    points[this.draggingPoint] = [clampedX, clampedY];
                    points.sort((a, b) => a[0] - b[0]);
                    
                    this.draw();
                    updateVisualization();
                }
                
                // Show info
                if (this.infoEl) {
                    const [x, y] = this.canvasToValue(mx, my);
                    this.infoEl.textContent = `x: ${x.toFixed(1)}, y: ${y.toFixed(2)}`;
                }
            }
            
            onMouseUp(e) {
                this.draggingPoint = null;
            }
            
            draw() {
                const ctx = this.ctx;
                const w = this.canvas.width;
                const h = this.canvas.height;
                
                // Clear
                ctx.fillStyle = this.canvas.classList.contains('small-canvas') ? '#0a0a0a' : '#1a1a1a';
                ctx.fillRect(0, 0, w, h);
                
                // Grid
                ctx.strokeStyle = '#2a2a2a';
                ctx.lineWidth = 1;
                for (let i = 0; i <= 4; i++) {
                    const y = (i / 4) * h;
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(w, y);
                    ctx.stroke();
                }
                
                // Zero line or unity line
                if (this.yRange[0] < 0 && this.yRange[1] > 0) {
                    const [_, cy] = this.valueToCanvas(0, 0);
                    ctx.strokeStyle = '#444';
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(0, cy);
                    ctx.lineTo(w, cy);
                    ctx.stroke();
                    ctx.setLineDash([]);
                } else if (this.yRange[0] === 0 && this.yRange[1] === 1) {
                    ctx.strokeStyle = '#333';
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(0, h);
                    ctx.lineTo(w, 0);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                
                // Draw curve
                const points = transform[this.curveName];
                
                // Determine color based on curve name
                let strokeColor = '#0088ff';
                if (this.curveName === 'redCurve') strokeColor = '#ff6666';
                else if (this.curveName === 'greenCurve') strokeColor = '#66ff66';
                else if (this.curveName === 'blueCurve') strokeColor = '#6666ff';
                
                ctx.strokeStyle = strokeColor;
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                for (let px = 0; px < w; px++) {
                    const [x, _] = this.canvasToValue(px, 0);
                    const y = cubicSplineInterpolate(x, points);
                    const [cx, cy] = this.valueToCanvas(x, y);
                    
                    if (px === 0) ctx.moveTo(cx, cy);
                    else ctx.lineTo(cx, cy);
                }
                ctx.stroke();
                
                // Draw points
                ctx.fillStyle = '#fff';
                ctx.strokeStyle = strokeColor;
                ctx.lineWidth = 2;
                const pointSize = this.canvas.classList.contains('small-canvas') ? 4 : 5;
                for (const [x, y] of points) {
                    const [cx, cy] = this.valueToCanvas(x, y);
                    ctx.beginPath();
                    ctx.arc(cx, cy, pointSize, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                }
            }
        }
        
        // Initialize curve editors
        const editors = {
            hueVsHue: new CurveEditor('hueVsHueCanvas', 'hueVsHue', 'hueVsHueInfo', [0, 360], [-30, 30], 'Shift'),
            hueVsSat: new CurveEditor('hueVsSatCanvas', 'hueVsSat', 'hueVsSatInfo', [0, 360], [0, 2], 'Mult'),
            hueVsLum: new CurveEditor('hueVsLumCanvas', 'hueVsLum', 'hueVsLumInfo', [0, 360], [-0.2, 0.2], 'Offset'),
            satVsSat: new CurveEditor('satVsSatCanvas', 'satVsSat', 'satVsSatInfo', [0, 1], [0, 1], 'Out'),
            satVsLum: new CurveEditor('satVsLumCanvas', 'satVsLum', 'satVsLumInfo', [0, 1], [-0.2, 0.2], 'Offset'),
            lumVsSat: new CurveEditor('lumVsSatCanvas', 'lumVsSat', 'lumVsSatInfo', [0, 1], [0, 2], 'Mult'),
            lumVsLum: new CurveEditor('lumVsLumCanvas', 'lumVsLum', 'lumVsLumInfo', [0, 1], [0, 1], 'Out'),
            redCurve: new CurveEditor('redCurveCanvas', 'redCurve', null, [0, 1], [0, 1], 'Out'),
            greenCurve: new CurveEditor('greenCurveCanvas', 'greenCurve', null, [0, 1], [0, 1], 'Out'),
            blueCurve: new CurveEditor('blueCurveCanvas', 'blueCurve', null, [0, 1], [0, 1], 'Out')
        };
        
        // ========================================================================
        // COLOR MODE
        // ========================================================================
        
        function setColorMode(mode) {
            currentColorMode = mode;
            
            // Update button states
            document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            // Update info text
            const infoTexts = {
                hsv: 'HSV: Hue, Saturation, Value - intuitive for color grading',
                lch: 'LCH: Lightness, Chroma, Hue - perceptually uniform (best for skin tones)',
                ycbcr: 'YCbCr: Luma, Blue-diff, Red-diff - broadcast standard (good for vintage)'
            };
            document.getElementById('modeInfo').textContent = infoTexts[mode];
            
            updateVisualization();
        }
        
        // ========================================================================
        // TEST IMAGE GENERATION
        // ========================================================================
        
        function generateHueSatChart(width, height) {
            const data = new Uint8ClampedArray(width * height * 4);
            for (let y = 0; y < height; y++) {
                const sat = 1 - (y / height);
                for (let x = 0; x < width; x++) {
                    const hue = (x / width) * 360;
                    const [r, g, b] = hsvToRgb(hue, sat, 0.7);
                    const idx = (y * width + x) * 4;
                    data[idx] = r * 255;
                    data[idx + 1] = g * 255;
                    data[idx + 2] = b * 255;
                    data[idx + 3] = 255;
                }
            }
            return new ImageData(data, width, height);
        }
        
        function generateHueLumChart(width, height) {
            const data = new Uint8ClampedArray(width * height * 4);
            for (let y = 0; y < height; y++) {
                const lum = 1 - (y / height);
                for (let x = 0; x < width; x++) {
                    const hue = (x / width) * 360;
                    const [r, g, b] = hsvToRgb(hue, 0.8, lum);
                    const idx = (y * width + x) * 4;
                    data[idx] = r * 255;
                    data[idx + 1] = g * 255;
                    data[idx + 2] = b * 255;
                    data[idx + 3] = 255;
                }
            }
            return new ImageData(data, width, height);
        }
        
        function generateMacbethChart(width, height) {
            const colors = [
                [0.44, 0.31, 0.24], [0.77, 0.57, 0.48], [0.36, 0.45, 0.60],
                [0.33, 0.42, 0.27], [0.54, 0.51, 0.73], [0.47, 0.75, 0.67],
                [0.93, 0.60, 0.12], [0.36, 0.40, 0.70], [0.76, 0.37, 0.42],
                [0.36, 0.22, 0.43], [0.64, 0.83, 0.36], [0.98, 0.73, 0.20],
                [0.27, 0.29, 0.75], [0.41, 0.71, 0.43], [0.75, 0.24, 0.26],
                [0.96, 0.92, 0.20], [0.82, 0.38, 0.70], [0.17, 0.62, 0.73],
                [0.95, 0.95, 0.95], [0.78, 0.78, 0.78], [0.63, 0.63, 0.63],
                [0.47, 0.47, 0.47], [0.31, 0.31, 0.31], [0.12, 0.12, 0.12]
            ];
            
            const data = new Uint8ClampedArray(width * height * 4);
            const patchW = width / 6;
            const patchH = height / 4;
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const col = Math.floor(x / patchW);
                    const row = Math.floor(y / patchH);
                    const colorIdx = row * 6 + col;
                    
                    if (colorIdx < colors.length) {
                        const [r, g, b] = colors[colorIdx];
                        const idx = (y * width + x) * 4;
                        data[idx] = r * 255;
                        data[idx + 1] = g * 255;
                        data[idx + 2] = b * 255;
                        data[idx + 3] = 255;
                    }
                }
            }
            return new ImageData(data, width, height);
        }
        
        function generateSatGradient(width, height) {
            const data = new Uint8ClampedArray(width * height * 4);
            for (let y = 0; y < height; y++) {
                const lum = 1 - (y / height);
                for (let x = 0; x < width; x++) {
                    const sat = x / width;
                    const [r, g, b] = hsvToRgb(30, sat, lum);
                    const idx = (y * width + x) * 4;
                    data[idx] = r * 255;
                    data[idx + 1] = g * 255;
                    data[idx + 2] = b * 255;
                    data[idx + 3] = 255;
                }
            }
            return new ImageData(data, width, height);
        }
        
        function processImageData(imageData) {
            const processed = new ImageData(
                new Uint8ClampedArray(imageData.data),
                imageData.width,
                imageData.height
            );
            
            for (let i = 0; i < processed.data.length; i += 4) {
                const r = processed.data[i] / 255;
                const g = processed.data[i + 1] / 255;
                const b = processed.data[i + 2] / 255;
                
                const [rOut, gOut, bOut] = transformColor(r, g, b);
                
                processed.data[i] = Math.max(0, Math.min(255, rOut * 255));
                processed.data[i + 1] = Math.max(0, Math.min(255, gOut * 255));
                processed.data[i + 2] = Math.max(0, Math.min(255, bOut * 255));
            }
            
            return processed;
        }
        
        // ========================================================================
        // VECTORSCOPE
        // ========================================================================
        
        function drawVectorscope() {
            const canvas = document.getElementById('vectorscope');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            const cx = w / 2;
            const cy = h / 2;
            const radius = Math.min(w, h) / 2 - 30;
            
            // Clear
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, w, h);
            
            // Draw graticule circles
            ctx.strokeStyle = '#2a2a2a';
            ctx.lineWidth = 1;
            for (let i = 1; i <= 4; i++) {
                ctx.beginPath();
                ctx.arc(cx, cy, radius * i / 4, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // 6 primary hues
            const hues = [0, 60, 120, 180, 240, 300];
            const hueColors = ['#ff4444', '#ffff44', '#44ff44', '#44ffff', '#4444ff', '#ff44ff'];
            const hueLabels = ['R', 'Yl', 'G', 'Cy', 'B', 'Mg'];
            
            // Draw hue lines
            ctx.lineWidth = 1;
            for (let i = 0; i < hues.length; i++) {
                const angle = (hues[i] - 90) * Math.PI / 180;
                const x = cx + Math.cos(angle) * radius;
                const y = cy + Math.sin(angle) * radius;
                
                // Line
                ctx.strokeStyle = '#333';
                ctx.beginPath();
                ctx.moveTo(cx, cy);
                ctx.lineTo(x, y);
                ctx.stroke();
                
                // Target box
                ctx.strokeStyle = hueColors[i];
                ctx.lineWidth = 2;
                const boxSize = 10;
                ctx.strokeRect(x - boxSize/2, y - boxSize/2, boxSize, boxSize);
                
                // Label
                ctx.fillStyle = '#aaa';
                ctx.font = '13px monospace';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const labelDist = radius + 18;
                const lx = cx + Math.cos(angle) * labelDist;
                const ly = cy + Math.sin(angle) * labelDist;
                ctx.fillText(hueLabels[i], lx, ly);
            }
            
            // Plot the 6 reference colors at 3 saturation levels
            const satLevels = [0.33, 0.66, 1.0];
            
            for (let i = 0; i < hues.length; i++) {
                for (let s = 0; s < satLevels.length; s++) {
                    const sat = satLevels[s];
                    
                    // Original color
                    const [r, g, b] = hsvToRgb(hues[i], sat, 0.8);
                    const [h, sOrig, v] = rgbToHsv(r, g, b);
                    
                    // Transformed color
                    const [rOut, gOut, bOut] = transformColor(r, g, b);
                    const [hOut, sOut, vOut] = rgbToHsv(rOut, gOut, bOut);
                    
                    // Draw line from original to transformed
                    const angle1 = (h - 90) * Math.PI / 180;
                    const dist1 = sOrig * radius;
                    const px1 = cx + Math.cos(angle1) * dist1;
                    const py1 = cy + Math.sin(angle1) * dist1;
                    
                    const angle2 = (hOut - 90) * Math.PI / 180;
                    const dist2 = sOut * radius;
                    const px2 = cx + Math.cos(angle2) * dist2;
                    const py2 = cy + Math.sin(angle2) * dist2;
                    
                    // Draw trajectory line
                    ctx.strokeStyle = `rgba(${hueColors[i].substring(1,3)}, ${hueColors[i].substring(3,5)}, ${hueColors[i].substring(5,7)}, 0.3)`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(px1, py1);
                    ctx.lineTo(px2, py2);
                    ctx.stroke();
                    
                    // Draw original point (box)
                    ctx.strokeStyle = hueColors[i];
                    ctx.fillStyle = `rgb(${r*255}, ${g*255}, ${b*255})`;
                    ctx.lineWidth = 2;
                    const boxSize = 6;
                    ctx.fillRect(px1 - boxSize/2, py1 - boxSize/2, boxSize, boxSize);
                    ctx.strokeRect(px1 - boxSize/2, py1 - boxSize/2, boxSize, boxSize);
                    
                    // Draw transformed point (circle)
                    ctx.fillStyle = `rgb(${rOut*255}, ${gOut*255}, ${bOut*255})`;
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(px2, py2, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                }
            }
            
            // Draw center point
            ctx.fillStyle = '#666';
            ctx.beginPath();
            ctx.arc(cx, cy, 4, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // ========================================================================
        // VISUALIZATION UPDATE
        // ========================================================================
        
        let originalImages = {};
        
        function initializeOriginalImages() {
            originalImages.hueSat = generateHueSatChart(256, 256);
            originalImages.hueLum = generateHueLumChart(256, 256);
            originalImages.macbeth = generateMacbethChart(256, 170);
            originalImages.satGrad = generateSatGradient(256, 256);
            
            // Draw originals
            document.getElementById('hueSatOriginal').getContext('2d').putImageData(originalImages.hueSat, 0, 0);
            document.getElementById('hueLumOriginal').getContext('2d').putImageData(originalImages.hueLum, 0, 0);
            document.getElementById('macbethOriginal').getContext('2d').putImageData(originalImages.macbeth, 0, 0);
            document.getElementById('satGradOriginal').getContext('2d').putImageData(originalImages.satGrad, 0, 0);
        }
        
        function updateVisualization() {
            // Process and display
            const hueSatProcessed = processImageData(originalImages.hueSat);
            const hueLumProcessed = processImageData(originalImages.hueLum);
            const macbethProcessed = processImageData(originalImages.macbeth);
            const satGradProcessed = processImageData(originalImages.satGrad);
            
            document.getElementById('hueSatProcessed').getContext('2d').putImageData(hueSatProcessed, 0, 0);
            document.getElementById('hueLumProcessed').getContext('2d').putImageData(hueLumProcessed, 0, 0);
            document.getElementById('macbethProcessed').getContext('2d').putImageData(macbethProcessed, 0, 0);
            document.getElementById('satGradProcessed').getContext('2d').putImageData(satGradProcessed, 0, 0);
            
            // Update vectorscope
            drawVectorscope();
        }
        
        // ========================================================================
        // PRESETS
        // ========================================================================
        
        function loadPreset(preset) {
            // Update active button
            document.querySelectorAll('.preset-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            if (preset === 'neutral') {
                transform.hueVsHue = [[0, 0], [360, 0]];
                transform.hueVsSat = [[0, 1], [360, 1]];
                transform.hueVsLum = [[0, 0], [360, 0]];
                transform.satVsSat = [[0, 0], [1, 1]];
                transform.satVsLum = [[0, 0], [1, 0]];
                transform.lumVsSat = [[0, 1], [1, 1]];
                transform.lumVsLum = [[0, 0], [1, 1]];
                transform.redCurve = [[0, 0], [1, 1]];
                transform.greenCurve = [[0, 0], [1, 1]];
                transform.blueCurve = [[0, 0], [1, 1]];
                transform.globalExposure = 1.0;
                transform.globalSaturation = 1.0;
                transform.globalContrast = 1.0;
            } else if (preset === 'velvia') {
                transform.hueVsHue = [[0, 5], [60, 10], [120, -5], [180, 0], [240, 5], [300, 0], [360, 5]];
                transform.hueVsSat = [[0, 1.2], [60, 1.4], [120, 1.5], [180, 1.3], [240, 1.4], [300, 1.1], [360, 1.2]];
                transform.hueVsLum = [[0, 0], [60, 0.05], [120, 0], [180, -0.02], [240, -0.03], [300, 0], [360, 0]];
                transform.satVsSat = [[0, 0], [0.3, 0.35], [0.6, 0.7], [0.9, 0.95], [1, 1]];
                transform.satVsLum = [[0, 0], [0.5, -0.02], [1, -0.05]];
                transform.lumVsSat = [[0, 0.7], [0.2, 1.0], [0.5, 1.2], [0.8, 1.1], [1, 0.9]];
                transform.lumVsLum = [[0, 0], [0.1, 0.15], [0.3, 0.35], [0.5, 0.5], [0.7, 0.68], [0.9, 0.88], [1, 1]];
                transform.redCurve = [[0, 0], [0.5, 0.52], [1, 1]];
                transform.greenCurve = [[0, 0], [0.5, 0.48], [1, 0.98]];
                transform.blueCurve = [[0, 0], [0.5, 0.5], [1, 1]];
                transform.globalSaturation = 1.2;
                transform.globalContrast = 1.15;
                transform.globalExposure = 1.0;
            } else if (preset === 'portra') {
                transform.hueVsHue = [[0, -3], [30, 5], [60, 5], [120, 0], [180, -5], [240, -5], [300, 0], [360, -3]];
                transform.hueVsSat = [[0, 0.9], [30, 1.0], [60, 0.95], [120, 0.85], [180, 0.9], [240, 0.85], [300, 0.9], [360, 0.9]];
                transform.hueVsLum = [[0, 0], [30, 0.03], [60, 0.02], [120, 0], [180, 0], [240, 0], [300, 0], [360, 0]];
                transform.satVsSat = [[0, 0], [0.4, 0.35], [0.7, 0.65], [1, 0.9]];
                transform.satVsLum = [[0, 0], [0.5, -0.01], [1, -0.03]];
                transform.lumVsSat = [[0, 0.6], [0.2, 0.85], [0.5, 1.0], [0.8, 0.95], [1, 0.8]];
                transform.lumVsLum = [[0, 0.02], [0.1, 0.12], [0.3, 0.32], [0.5, 0.5], [0.7, 0.7], [0.9, 0.92], [1, 0.98]];
                transform.redCurve = [[0, 0], [0.5, 0.48], [1, 0.98]];
                transform.greenCurve = [[0, 0.02], [0.5, 0.5], [1, 1]];
                transform.blueCurve = [[0, 0], [0.5, 0.52], [1, 1]];
                transform.globalSaturation = 0.9;
                transform.globalContrast = 0.95;
                transform.globalExposure = 1.0;
            } else if (preset === 'cinestill') {
                transform.hueVsHue = [[0, 10], [60, 10], [120, -5], [180, -10], [240, -8], [300, 5], [360, 10]];
                transform.hueVsSat = [[0, 1.2], [60, 1.1], [120, 0.95], [180, 1.1], [240, 1.3], [300, 1.15], [360, 1.2]];
                transform.hueVsLum = [[0, 0.05], [60, 0.03], [120, 0], [180, -0.05], [240, -0.03], [300, 0], [360, 0.05]];
                transform.satVsSat = [[0, 0], [0.25, 0.27], [0.5, 0.55], [0.75, 0.78], [1, 1]];
                transform.satVsLum = [[0, 0], [0.7, 0.02], [1, 0.05]];
                transform.lumVsSat = [[0, 0.8], [0.2, 1.0], [0.5, 1.1], [0.8, 1.2], [1, 1.3]];
                transform.lumVsLum = [[0, 0], [0.15, 0.18], [0.35, 0.4], [0.5, 0.52], [0.7, 0.73], [0.85, 0.9], [1, 1]];
                transform.redCurve = [[0, 0], [0.5, 0.52], [1, 1]];
                transform.greenCurve = [[0, 0], [0.5, 0.5], [1, 1]];
                transform.blueCurve = [[0, 0], [0.5, 0.48], [1, 0.98]];
                transform.globalSaturation = 1.05;
                transform.globalContrast = 1.1;
                transform.globalExposure = 1.0;
            } else if (preset === 'teal_orange') {
                transform.hueVsHue = [[0, 15], [30, 20], [60, 10], [120, 0], [180, -15], [200, -20], [240, -10], [300, 5], [360, 15]];
                transform.hueVsSat = [[0, 1.3], [30, 1.4], [60, 1.2], [120, 0.9], [180, 1.4], [200, 1.5], [240, 1.2], [300, 1.0], [360, 1.3]];
                transform.hueVsLum = [[0, 0.02], [60, 0.03], [120, -0.02], [180, 0], [240, -0.03], [300, 0], [360, 0.02]];
                transform.satVsSat = [[0, 0], [0.3, 0.35], [0.6, 0.68], [0.9, 0.92], [1, 1]];
                transform.satVsLum = [[0, 0], [0.6, -0.01], [1, -0.02]];
                transform.lumVsSat = [[0, 0.7], [0.3, 1.1], [0.6, 1.2], [0.9, 0.9], [1, 0.7]];
                transform.lumVsLum = [[0, 0.05], [0.2, 0.22], [0.5, 0.5], [0.8, 0.82], [1, 0.95]];
                transform.redCurve = [[0, 0], [0.5, 0.51], [1, 1]];
                transform.greenCurve = [[0, 0], [0.5, 0.5], [1, 1]];
                transform.blueCurve = [[0, 0], [0.5, 0.49], [1, 1]];
                transform.globalSaturation = 1.2;
                transform.globalContrast = 1.15;
                transform.globalExposure = 1.0;
            } else if (preset === 'agfa') {
                transform.hueVsHue = [[0, 8], [60, 12], [120, 5], [180, -5], [240, -3], [300, 5], [360, 8]];
                transform.hueVsSat = [[0, 1.1], [60, 1.25], [120, 1.2], [180, 1.0], [240, 0.95], [300, 1.05], [360, 1.1]];
                transform.hueVsLum = [[0, 0.02], [60, 0.04], [120, 0.01], [180, 0], [240, -0.01], [300, 0], [360, 0.02]];
                transform.satVsSat = [[0, 0], [0.4, 0.43], [0.7, 0.75], [1, 1]];
                transform.satVsLum = [[0, 0], [0.5, 0], [1, 0.01]];
                transform.lumVsSat = [[0, 0.75], [0.3, 1.05], [0.6, 1.1], [1, 0.9]];
                transform.lumVsLum = [[0, 0], [0.25, 0.25], [0.5, 0.5], [0.75, 0.75], [1, 1]];
                transform.redCurve = [[0, 0], [0.5, 0.48], [1, 0.98]];
                transform.greenCurve = [[0, 0], [0.5, 0.5], [1, 1]];
                transform.blueCurve = [[0, 0.01], [0.5, 0.52], [1, 1]];
                transform.globalSaturation = 1.1;
                transform.globalContrast = 1.0;
                transform.globalExposure = 1.0;
            }
            
            // Update sliders
            document.getElementById('exposureSlider').value = transform.globalExposure;
            document.getElementById('exposureValue').textContent = transform.globalExposure.toFixed(2);
            document.getElementById('saturationSlider').value = transform.globalSaturation;
            document.getElementById('saturationValue').textContent = transform.globalSaturation.toFixed(2);
            document.getElementById('contrastSlider').value = transform.globalContrast;
            document.getElementById('contrastValue').textContent = transform.globalContrast.toFixed(2);
            
            // Redraw curves and update visualization
            Object.values(editors).forEach(editor => editor.draw());
            updateVisualization();
        }
        
        function resetAll() {
            loadPreset('neutral');
            document.querySelectorAll('.preset-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelector('.preset-btn').classList.add('active');
        }
        
        // ========================================================================
        // GLOBAL CONTROLS
        // ========================================================================
        
        document.getElementById('exposureSlider').addEventListener('input', (e) => {
            transform.globalExposure = parseFloat(e.target.value);
            document.getElementById('exposureValue').textContent = transform.globalExposure.toFixed(2);
            updateVisualization();
        });
        
        document.getElementById('saturationSlider').addEventListener('input', (e) => {
            transform.globalSaturation = parseFloat(e.target.value);
            document.getElementById('saturationValue').textContent = transform.globalSaturation.toFixed(2);
            updateVisualization();
        });
        
        document.getElementById('contrastSlider').addEventListener('input', (e) => {
            transform.globalContrast = parseFloat(e.target.value);
            document.getElementById('contrastValue').textContent = transform.globalContrast.toFixed(2);
            updateVisualization();
        });
        
        // ========================================================================
        // INITIALIZE
        // ========================================================================
        
        initializeOriginalImages();
        updateVisualization();
        document.querySelector('.preset-btn').classList.add('active');
    </script>
</body>
</html><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Professional Film Emulation System</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            padding: 20px;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 2200px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 10px;
            color: #fff;
            font-size: 28px;
        }
        
        .subtitle {
            text-align: center;
            margin-bottom: 30px;
            color: #888;
            font-size: 14px;
        }
        
        .main-grid {
            display: grid;
            grid-template-columns: 450px 1fr 500px;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .controls-panel {
            background: #252525;
            border-radius: 8px;
            padding: 20px;
            height: fit-content;
            max-height: calc(100vh - 100px);
            overflow-y: auto;
            position: sticky;
            top: 20px;
        }
        
        .controls-panel::-webkit-scrollbar {
            width: 8px;
        }
        
        .controls-panel::-webkit-scrollbar-track {
            background: #1a1a1a;
            border-radius: 4px;
        }
        
        .controls-panel::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 4px;
        }
        
        .visualization-panel {
            background: #252525;
            border-radius: 8px;
            padding: 20px;
        }
        
        .scope-panel {
            background: #252525;
            border-radius: 8px;
            padding: 20px;
            height: fit-content;
            position: sticky;
            top: 20px;
        }
        
        .preset-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .preset-btn {
            padding: 12px;
            background: #333;
            border: 2px solid #444;
            border-radius: 6px;
            color: #e0e0e0;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 13px;
            font-weight: 500;
        }
        
        .preset-btn:hover {
            background: #3a3a3a;
            border-color: #666;
        }
        
        .preset-btn.active {
            background: #0066cc;
            border-color: #0077ee;
            color: white;
        }
        
        .curve-editor {
            margin-bottom: 20px;
        }
        
        .curve-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .curve-title {
            font-size: 13px;
            font-weight: 600;
            color: #fff;
        }
        
        .curve-canvas {
            width: 100%;
            height: 100px;
            background: #1a1a1a;
            border-radius: 6px;
            cursor: crosshair;
            border: 1px solid #333;
        }
        
        .global-controls {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #333;
        }
        
        .slider-group {
            margin-bottom: 15px;
        }
        
        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 12px;
        }
        
        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #333;
            outline: none;
            -webkit-appearance: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #0066cc;
            cursor: pointer;
        }
        
        .slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #0066cc;
            cursor: pointer;
            border: none;
        }
        
        .test-images {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        
        .image-pair {
            background: #1a1a1a;
            border-radius: 6px;
            padding: 10px;
        }
        
        .image-label {
            font-size: 12px;
            font-weight: 600;
            margin-bottom: 8px;
            color: #aaa;
            text-align: center;
        }
        
        .image-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        
        .test-image {
            width: 100%;
            height: auto;
            border-radius: 4px;
        }
        
        .image-subtitle {
            font-size: 11px;
            color: #666;
            text-align: center;
            margin-top: 5px;
        }
        
        .reset-btn {
            width: 100%;
            padding: 10px;
            background: #444;
            border: none;
            border-radius: 6px;
            color: #fff;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            margin-top: 15px;
        }
        
        .reset-btn:hover {
            background: #555;
        }
        
        .point-indicator {
            font-size: 10px;
            color: #666;
            margin-top: 5px;
        }
        
        .section-header {
            font-size: 15px;
            font-weight: 600;
            color: #fff;
            margin: 20px 0 12px 0;
            padding-bottom: 8px;
            border-bottom: 1px solid #333;
        }
        
        .mode-toggle {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .mode-btn {
            flex: 1;
            padding: 10px;
            background: #333;
            border: 2px solid #444;
            border-radius: 6px;
            color: #e0e0e0;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.2s;
        }
        
        .mode-btn.active {
            background: #0066cc;
            border-color: #0077ee;
            color: white;
        }
        
        .mode-btn:hover:not(.active) {
            background: #3a3a3a;
        }
        
        .channel-curves {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }
        
        .channel-curve-small {
            background: #1a1a1a;
            border-radius: 4px;
            padding: 8px;
        }
        
        .channel-label {
            font-size: 11px;
            font-weight: 600;
            margin-bottom: 5px;
            text-align: center;
        }
        
        .channel-label.red { color: #ff6666; }
        .channel-label.green { color: #66ff66; }
        .channel-label.blue { color: #6666ff; }
        
        .small-canvas {
            width: 100%;
            height: 80px;
            background: #0a0a0a;
            border-radius: 4px;
            cursor: crosshair;
            border: 1px solid #333;
        }
        
        .vectorscope-container {
            position: relative;
            width: 100%;
            aspect-ratio: 1;
        }
        
        .vectorscope {
            width: 100%;
            height: 100%;
            background: #1a1a1a;
            border-radius: 8px;
            border: 1px solid #333;
        }
        
        .scope-label {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 15px;
            color: #fff;
            text-align: center;
        }
        
        .scope-legend {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 15px;
            font-size: 11px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
            border: 1px solid #333;
        }
        
        .mode-info {
            font-size: 11px;
            color: #888;
            margin-bottom: 15px;
            line-height: 1.4;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Professional Film Emulation System</h1>
        <p class="subtitle">Tier 1+2 Implementation • HSV/LCH/YCbCr modes • Per-channel curves • Real-time vectorscope</p>
        
        <div class="main-grid">
            <!-- Controls Panel -->
            <div class="controls-panel">
                <h3 style="margin-bottom: 15px; font-size: 16px;">Film Presets</h3>
                <div class="preset-buttons">
                    <button class="preset-btn" onclick="loadPreset('neutral')">Neutral</button>
                    <button class="preset-btn" onclick="loadPreset('velvia')">Fuji Velvia</button>
                    <button class="preset-btn" onclick="loadPreset('portra')">Kodak Portra</button>
                    <button class="preset-btn" onclick="loadPreset('cinestill')">Cinestill 800T</button>
                    <button class="preset-btn" onclick="loadPreset('teal_orange')">Teal & Orange</button>
                    <button class="preset-btn" onclick="loadPreset('agfa')">Agfa Vista</button>
                </div>
                
                <div class="section-header">Color Space Mode</div>
                <div class="mode-toggle">
                    <button class="mode-btn active" onclick="setColorMode('hsv')">HSV</button>
                    <button class="mode-btn" onclick="setColorMode('lch')">LCH</button>
                    <button class="mode-btn" onclick="setColorMode('ycbcr')">YCbCr</button>
                </div>
                <div class="mode-info" id="modeInfo">
                    HSV: Hue, Saturation, Value - intuitive for color grading
                </div>
                
                <div class="section-header">Hue Transforms</div>
                
                <div class="curve-editor">
                    <div class="curve-header">
                        <span class="curve-title">Hue → Hue Shift</span>
                    </div>
                    <canvas id="hueVsHueCanvas" class="curve-canvas" width="410" height="100"></canvas>
                    <div class="point-indicator" id="hueVsHueInfo">Click to add/drag points</div>
                </div>
                
                <div class="curve-editor">
                    <div class="curve-header">
                        <span class="curve-title">Hue → Saturation</span>
                    </div>
                    <canvas id="hueVsSatCanvas" class="curve-canvas" width="410" height="100"></canvas>
                    <div class="point-indicator" id="hueVsSatInfo">Click to add/drag points</div>
                </div>
                
                <div class="curve-editor">
                    <div class="curve-header">
                        <span class="curve-title">Hue → Luminance</span>
                    </div>
                    <canvas id="hueVsLumCanvas" class="curve-canvas" width="410" height="100"></canvas>
                    <div class="point-indicator" id="hueVsLumInfo">Click to add/drag points</div>
                </div>
                
                <div class="section-header">Saturation Transforms</div>
                
                <div class="curve-editor">
                    <div class="curve-header">
                        <span class="curve-title">Saturation → Saturation</span>
                    </div>
                    <canvas id="satVsSatCanvas" class="curve-canvas" width="410" height="100"></canvas>
                    <div class="point-indicator" id="satVsSatInfo">Click to add/drag points</div>
                </div>
                
                <div class="curve-editor">
                    <div class="curve-header">
                        <span class="curve-title">Saturation → Luminance</span>
                    </div>
                    <canvas id="satVsLumCanvas" class="curve-canvas" width="410" height="100"></canvas>
                    <div class="point-indicator" id="satVsLumInfo">Click to add/drag points</div>
                </div>
                
                <div class="section-header">Luminance Transforms</div>
                
                <div class="curve-editor">
                    <div class="curve-header">
                        <span class="curve-title">Luminance → Saturation</span>
                    </div>
                    <canvas id="lumVsSatCanvas" class="curve-canvas" width="410" height="100"></canvas>
                    <div class="point-indicator" id="lumVsSatInfo">Click to add/drag points</div>
                </div>
                
                <div class="curve-editor">
                    <div class="curve-header">
                        <span class="curve-title">Luminance → Luminance</span>
                    </div>
                    <canvas id="lumVsLumCanvas" class="curve-canvas" width="410" height="100"></canvas>
                    <div class="point-indicator" id="lumVsLumInfo">Click to add/drag points</div>
                </div>
                
                <div class="section-header">Per-Channel Tone Curves</div>
                <div style="font-size: 11px; color: #888; margin-bottom: 10px;">
                    Individual curves per channel (replaces/enhances crosstalk)
                </div>
                <div class="channel-curves">
                    <div class="channel-curve-small">
                        <div class="channel-label red">Red</div>
                        <canvas id="redCurveCanvas" class="small-canvas" width="120" height="80"></canvas>
                    </div>
                    <div class="channel-curve-small">
                        <div class="channel-label green">Green</div>
                        <canvas id="greenCurveCanvas" class="small-canvas" width="120" height="80"></canvas>
                    </div>
                    <div class="channel-curve-small">
                        <div class="channel-label blue">Blue</div>
                        <canvas id="blueCurveCanvas" class="small-canvas" width="120" height="80"></canvas>
                    </div>
                </div>
                
                <div class="global-controls">
                    <h3 style="margin-bottom: 15px; font-size: 16px;">Global Adjustments</h3>
                    
                    <div class="slider-group">
                        <div class="slider-label">
                            <span>Exposure</span>
                            <span id="exposureValue">1.0</span>
                        </div>
                        <input type="range" class="slider" id="exposureSlider" min="0.5" max="2" step="0.01" value="1">
                    </div>
                    
                    <div class="slider-group">
                        <div class="slider-label">
                            <span>Saturation</span>
                            <span id="saturationValue">1.0</span>
                        </div>
                        <input type="range" class="slider" id="saturationSlider" min="0" max="2" step="0.01" value="1">
                    </div>
                    
                    <div class="slider-group">
                        <div class="slider-label">
                            <span>Contrast</span>
                            <span id="contrastValue">1.0</span>
                        </div>
                        <input type="range" class="slider" id="contrastSlider" min="0.5" max="2" step="0.01" value="1">
                    </div>
                    
                    <button class="reset-btn" onclick="resetAll()">Reset All</button>
                </div>
            </div>
            
            <!-- Visualization Panel -->
            <div class="visualization-panel">
                <h3 style="margin-bottom: 15px; font-size: 16px;">Color Response Visualization</h3>
                <div class="test-images">
                    <div class="image-pair">
                        <div class="image-label">HUE vs SATURATION</div>
                        <div class="image-container">
                            <div>
                                <canvas id="hueSatOriginal" width="256" height="256"></canvas>
                                <div class="image-subtitle">Original</div>
                            </div>
                            <div>
                                <canvas id="hueSatProcessed" width="256" height="256"></canvas>
                                <div class="image-subtitle">Processed</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="image-pair">
                        <div class="image-label">HUE vs LUMINANCE</div>
                        <div class="image-container">
                            <div>
                                <canvas id="hueLumOriginal" width="256" height="256"></canvas>
                                <div class="image-subtitle">Original</div>
                            </div>
                            <div>
                                <canvas id="hueLumProcessed" width="256" height="256"></canvas>
                                <div class="image-subtitle">Processed</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="image-pair">
                        <div class="image-label">MACBETH COLORCHECKER</div>
                        <div class="image-container">
                            <div>
                                <canvas id="macbethOriginal" width="256" height="170"></canvas>
                                <div class="image-subtitle">Original</div>
                            </div>
                            <div>
                                <canvas id="macbethProcessed" width="256" height="170"></canvas>
                                <div class="image-subtitle">Processed</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="image-pair">
                        <div class="image-label">SATURATION GRADIENT</div>
                        <div class="image-container">
                            <div>
                                <canvas id="satGradOriginal" width="256" height="256"></canvas>
                                <div class="image-subtitle">Original</div>
                            </div>
                            <div>
                                <canvas id="satGradProcessed" width="256" height="256"></canvas>
                                <div class="image-subtitle">Processed</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Vectorscope Panel -->
            <div class="scope-panel">
                <div class="scope-label">VECTORSCOPE</div>
                <div class="vectorscope-container">
                    <canvas id="vectorscope" class="vectorscope" width="460" height="460"></canvas>
                </div>
                <div class="scope-legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #ff0000;"></div>
                        <span>Red (0°)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #ffff00;"></div>
                        <span>Yellow (60°)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #00ff00;"></div>
                        <span>Green (120°)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #00ffff;"></div>
                        <span>Cyan (180°)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #0000ff;"></div>
                        <span>Blue (240°)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #ff00ff;"></div>
                        <span>Magenta (300°)</span>
                    </div>
                </div>
                <div style="margin-top: 15px; font-size: 11px; color: #888; text-align: center; line-height: 1.5;">
                    <strong>6 color paths at 3 saturation levels</strong><br>
                    Boxes = original position<br>
                    Circles = transformed position<br>
                    Lines show transformation trajectory
                </div>
            </div>
        </div>
    </div>

    <script>
        // ========================================================================
        // COLOR SPACE CONVERSIONS
        // ========================================================================
        
        let currentColorMode = 'hsv';
        
        // HSV
        function rgbToHsv(r, g, b) {
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            const delta = max - min;
            
            let h = 0;
            if (delta !== 0) {
                if (max === r) h = 60 * (((g - b) / delta) % 6);
                else if (max === g) h = 60 * (((b - r) / delta) + 2);
                else h = 60 * (((r - g) / delta) + 4);
            }
            if (h < 0) h += 360;
            
            const s = max === 0 ? 0 : delta / max;
            const v = max;
            
            return [h, s, v];
        }
        
        function hsvToRgb(h, s, v) {
            const c = v * s;
            const x = c * (1 - Math.abs((h / 60) % 2 - 1));
            const m = v - c;
            
            let r, g, b;
            if (h < 60) [r, g, b] = [c, x, 0];
            else if (h < 120) [r, g, b] = [x, c, 0];
            else if (h < 180) [r, g, b] = [0, c, x];
            else if (h < 240) [r, g, b] = [0, x, c];
            else if (h < 300) [r, g, b] = [x, 0, c];
            else [r, g, b] = [c, 0, x];
            
            return [r + m, g + m, b + m];
        }
        
        // LCH (via Lab)
        function rgbToLch(r, g, b) {
            // RGB → XYZ
            let rLin = r <= 0.04045 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4);
            let gLin = g <= 0.04045 ? g / 12.92 : Math.pow((g + 0.055) / 1.055, 2.4);
            let bLin = b <= 0.04045 ? b / 12.92 : Math.pow((b + 0.055) / 1.055, 2.4);
            
            let x = rLin * 0.4124 + gLin * 0.3576 + bLin * 0.1805;
            let y = rLin * 0.2126 + gLin * 0.7152 + bLin * 0.0722;
            let z = rLin * 0.0193 + gLin * 0.1192 + bLin * 0.9505;
            
            // XYZ → Lab (D65 white point)
            x = x / 0.95047;
            y = y / 1.00000;
            z = z / 1.08883;
            
            x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + 16/116;
            y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + 16/116;
            z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + 16/116;
            
            const L = (116 * y) - 16;
            const a = 500 * (x - y);
            const bLab = 200 * (y - z);
            
            // Lab → LCH
            const C = Math.sqrt(a * a + bLab * bLab);
            let H = Math.atan2(bLab, a) * 180 / Math.PI;
            if (H < 0) H += 360;
            
            return [L, C, H];
        }
        
        function lchToRgb(L, C, H) {
            // LCH → Lab
            const a = C * Math.cos(H * Math.PI / 180);
            const bLab = C * Math.sin(H * Math.PI / 180);
            
            // Lab → XYZ
            let y = (L + 16) / 116;
            let x = a / 500 + y;
            let z = y - bLab / 200;
            
            x = x > 0.206897 ? Math.pow(x, 3) : (x - 16/116) / 7.787;
            y = y > 0.206897 ? Math.pow(y, 3) : (y - 16/116) / 7.787;
            z = z > 0.206897 ? Math.pow(z, 3) : (z - 16/116) / 7.787;
            
            x *= 0.95047;
            y *= 1.00000;
            z *= 1.08883;
            
            // XYZ → RGB
            let r =  x *  3.2406 + y * -1.5372 + z * -0.4986;
            let g =  x * -0.9689 + y *  1.8758 + z *  0.0415;
            let b =  x *  0.0557 + y * -0.2040 + z *  1.0570;
            
            r = r > 0.0031308 ? 1.055 * Math.pow(r, 1/2.4) - 0.055 : 12.92 * r;
            g = g > 0.0031308 ? 1.055 * Math.pow(g, 1/2.4) - 0.055 : 12.92 * g;
            b = b > 0.0031308 ? 1.055 * Math.pow(b, 1/2.4) - 0.055 : 12.92 * b;
            
            return [
                Math.max(0, Math.min(1, r)),
                Math.max(0, Math.min(1, g)),
                Math.max(0, Math.min(1, b))
            ];
        }
        
        // YCbCr
        function rgbToYcbcr(r, g, b) {
            const y  =  0.299 * r + 0.587 * g + 0.114 * b;
            const cb = -0.169 * r - 0.331 * g + 0.500 * b + 0.5;
            const cr =  0.500 * r - 0.419 * g - 0.081 * b + 0.5;
            return [y, cb, cr];
        }
        
        function ycbcrToRgb(y, cb, cr) {
            cb -= 0.5;
            cr -= 0.5;
            const r = y + 1.402 * cr;
            const g = y - 0.344 * cb - 0.714 * cr;
            const b = y + 1.772 * cb;
            return [
                Math.max(0, Math.min(1, r)),
                Math.max(0, Math.min(1, g)),
                Math.max(0, Math.min(1, b))
            ];
        }
        
        function cubicSplineInterpolate(x, points) {
            points.sort((a, b) => a[0] - b[0]);
            
            if (x <= points[0][0]) return points[0][1];
            if (x >= points[points.length - 1][0]) return points[points.length - 1][1];
            
            for (let i = 0; i < points.length - 1; i++) {
                const [x1, y1] = points[i];
                const [x2, y2] = points[i + 1];
                
                if (x >= x1 && x <= x2) {
                    const t = (x - x1) / (x2 - x1);
                    
                    const