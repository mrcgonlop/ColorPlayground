// ============================================================================
// FILM EMULATION DCTL - COMPLETE SYSTEM
// ============================================================================
// Professional parametric film emulation with:
// - DaVinci Wide Gamut / Rec.709 input/output handling
// - 3 color space modes (HSV, LCH, YCbCr)
// - 7 parametric curves + per-channel curves
// - 6 film presets + custom slot
// - Organic highlight/shadow desaturation
// ============================================================================
// Input settings
DEFINE_UI_PARAMS(in_gamut, Input Gamut, DCTLUI_COMBO_BOX, 15, {i_xyz, i_ap0, i_ap1, i_p3d65, i_rec2020, i_rec709, i_awg3, i_awg4, i_rwg, i_sgamut3, i_sgamut3cine, i_vgamut, i_bmdwg, i_egamut, i_egamut2, i_davinciwg}, {XYZ, ACES 2065-1, ACEScg, P3D65, Rec.2020, Rec.709, Arri Wide Gamut 3, Arri Wide Gamut 4, Red Wide Gamut RGB, Sony SGamut3, Sony SGamut3Cine, Panasonic V-Gamut, Blackmagic Wide Gamut, Filmlight E-Gamut, Filmlight E-Gamut2, DaVinci Wide Gamut})
DEFINE_UI_PARAMS(in_oetf, Input Transfer Function, DCTLUI_COMBO_BOX, 1, {ioetf_linear, ioetf_davinci_intermediate, ioetf_filmlight_tlog, ioetf_acescct, ioetf_arri_logc3, ioetf_arri_logc4, ioetf_redlog3g10, ioetf_panasonic_vlog, ioetf_sony_slog3, ioetf_fuji_flog}, {Linear, Davinci Intermediate, Filmlight T-Log, ACEScct, Arri LogC3, Arri LogC4, RedLog3G10, Panasonic V-Log, Sony S-Log3, Fuji F-Log2})
DEFINE_UI_PARAMS(display_encoding_preset, Display Encoding Preset, DCTLUI_COMBO_BOX, 0, {rec1886, srgb, displayp3, p3d60, p3dci, xyz, rec2100pq, rec2100hlg, dolbypq}, {Rec.1886 - 2.4 Power / Rec.709, sRGB Display - 2.2 Power / Rec.709, Display P3 - 2.2 Power / P3-D65, DCI - 2.6 Power / P3-D60, DCI - 2.6 Power / P3-DCI, DCI - 2.6 Power / XYZ, Rec.2100 - PQ / Rec.2020 (P3 Limited), Rec.2100 - HLG / Rec.2020 (P3 Limited), Dolby - PQ / P3-D65})
DEFINE_UI_PARAMS(crv_enable, Tonescale Overlay, DCTLUI_CHECK_BOX, 0)

DEFINE_UI_PARAMS(working_colorspace, Working Color Space, DCTLUI_COMBO_BOX, 0, {HSV, LCH, YCBCR}, {HSV, LCH, YCbCr})
DEFINE_UI_PARAMS(preset, Film Preset, DCTLUI_COMBO_BOX, 0, {NEUTRAL, VELVIA, PORTRA, CINESTILL, TEAL_ORANGE, AGFA, CUSTOM}, {Neutral, Fuji Velvia, Kodak Portra, Cinestill 800T, Teal & Orange, Agfa Vista, Custom})
DEFINE_UI_PARAMS(global_exposure, Exposure, DCTLUI_SLIDER_FLOAT, 1.0, 0.5, 2.0, 0.01)
DEFINE_UI_PARAMS(global_saturation, Saturation, DCTLUI_SLIDER_FLOAT, 1.0, 0.0, 2.0, 0.01)
DEFINE_UI_PARAMS(global_contrast, Contrast, DCTLUI_SLIDER_FLOAT, 1.0, 0.5, 2.0, 0.01)
DEFINE_UI_PARAMS(hue_shift, Hue Shift, DCTLUI_SLIDER_FLOAT, 0.0, -180.0, 180.0, 1.0)
DEFINE_UI_PARAMS(highlight_desat, Highlight Desaturation, DCTLUI_SLIDER_FLOAT, 0.7, 0.0, 1.0, 0.01)
DEFINE_UI_PARAMS(shadow_desat, Shadow Desaturation, DCTLUI_SLIDER_FLOAT, 0.3, 0.0, 1.0, 0.01)

// Hue Loops (Saturation-based hue rotation)
DEFINE_UI_PARAMS(enable_hue_loops, Enable Hue Loops, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(hue_loop_red, Red Hue Loop, DCTLUI_SLIDER_FLOAT, 0.0, -30.0, 30.0, 0.1)
DEFINE_UI_PARAMS(hue_loop_green, Green Hue Loop, DCTLUI_SLIDER_FLOAT, 0.0, -30.0, 30.0, 0.1)
DEFINE_UI_PARAMS(hue_loop_blue, Blue Hue Loop, DCTLUI_SLIDER_FLOAT, 0.0, -30.0, 30.0, 0.1)
DEFINE_UI_PARAMS(hue_loop_cyan, Cyan Hue Loop, DCTLUI_SLIDER_FLOAT, 0.0, -30.0, 30.0, 0.1)
DEFINE_UI_PARAMS(hue_loop_magenta, Magenta Hue Loop, DCTLUI_SLIDER_FLOAT, 0.0, -30.0, 30.0, 0.1)
DEFINE_UI_PARAMS(hue_loop_yellow, Yellow Hue Loop, DCTLUI_SLIDER_FLOAT, 0.0, -30.0, 30.0, 0.1)
DEFINE_UI_PARAMS(hue_loop_strength, Hue Loop Saturation Threshold, DCTLUI_SLIDER_FLOAT, 0.7, 0.0, 1.0, 0.01)

typedef struct {
  float3 x, y, z;
} float3x3;

// Helper function to create a float3x3
__DEVICE__ float3x3 make_float3x3(float3 a, float3 b, float3 c) {
  float3x3 d;
  d.x = a, d.y = b, d.z = c;
  return d;
}
// ============================================================================
// COLOR SPACE MATRICES
// ============================================================================

// DaVinci Wide Gamut to XYZ (D65)
__CONSTANT__ float DWG_TO_XYZ[3][3] = {
    {0.700622320175f, 0.148774802685f, 0.101058728993f},
    {0.274118483067f, 0.873631775379f, -0.147750422359f},
    {-0.098962903023f, -0.137895315886f, 1.325916051865f}
};

// XYZ to DaVinci Wide Gamut
__CONSTANT__ float XYZ_TO_DWG[3][3] = {
    {1.512205958366f, -0.236214995384f, -0.095667056739f},
    {-0.461994469166f, 1.204409718513f, 0.025726420060f},
    {0.077355667949f, 0.109971389174f, 0.764165461063f}
};

// Rec.709 to XYZ (D65)
__CONSTANT__ float REC709_TO_XYZ[3][3] = {
    {0.412391f, 0.357584f, 0.180481f},
    {0.212639f, 0.715169f, 0.072192f},
    {0.019331f, 0.119195f, 0.950532f}
};

// XYZ to Rec.709
__CONSTANT__ float XYZ_TO_REC709[3][3] = {
    {3.240970f, -1.537383f, -0.498611f},
    {-0.969244f, 1.875968f, 0.041555f},
    {0.055630f, -0.203977f, 1.056972f}
};

/******************************************************************
  Gamut Conversion Matrices
 ******************************************************************/
// Input gamut conversion matrices
#define matrix_ap0_to_xyz make_float3x3(make_float3(0.938630948750273197f, -0.00574192055037397141f, 0.017566898851772296f), make_float3(0.338093594922021567f, 0.72721390281143572f, -0.0653074977334571899f), make_float3(0.000723121511341165988f, 0.000818441849244731985f, 1.08751618739929268f))
#define matrix_ap1_to_xyz make_float3x3(make_float3(0.652418717671912951f, 0.127179925537538263f, 0.170857283842220459f), make_float3(0.268064059194271287f, 0.672464478992617742f, 0.0594714618131108388f), make_float3(-0.0054699285104975676f, 0.00518279997697511721f, 1.08934487929340107f))
#define matrix_rec2020_to_xyz make_float3x3(make_float3(0.636958048301290991f, 0.144616903586208406f, 0.168880975164172054f), make_float3(0.26270021201126692f, 0.677998071518871148f, 0.0593017164698619384f), make_float3(4.9999999999999999e-17f, 0.0280726930490874452f, 1.06098505771079066f))
#define matrix_arriwg3_to_xyz make_float3x3(make_float3(0.638007619284f, 0.214703856337f, 0.097744451431f), make_float3(0.291953779f, 0.823841041511f, -0.11579482051f), make_float3(0.002798279032f, -0.067034235689f, 1.15329370742f))
#define matrix_arriwg4_to_xyz make_float3x3(make_float3(0.704858320407231953f, 0.129760295170463003f, 0.115837311473976537f), make_float3(0.254524176404026969f, 0.781477732712002049f, -0.0360019091160290391f), make_float3(0.0f, 0.0f, 1.08905775075987843f))
#define matrix_redwg_to_xyz make_float3x3(make_float3(0.735275245905858799f, 0.0686094106139610721f, 0.14657127053185201f), make_float3(0.286694099499934962f, 0.842979134016975662f, -0.129673233516910319f), make_float3(-0.0796808568783676785f, -0.347343216994429771f, 1.51608182463267593f))
#define matrix_sonysgamut3_to_xyz make_float3x3(make_float3(0.706482713192318812f, 0.12880104979055762f, 0.115172164068795255f), make_float3(0.270979670813492168f, 0.786606411220905466f, -0.0575860820343976273f), make_float3(-0.00967784538619615754f, 0.00460003749251991934f, 1.09413555865355483f))
#define matrix_sonysgamut3cine_to_xyz make_float3x3(make_float3(0.599083920758327171f, 0.248925516115423628f, 0.102446490177920776f), make_float3(0.215075820115587457f, 0.88506850174372842f, -0.100144321859315821f), make_float3(-0.0320658495445057951f, -0.0276583906794915374f, 1.1487819909838759f))
#define matrix_vgamut_to_xyz make_float3x3(make_float3(0.679644469878f, 0.15221141244f, 0.118600044733), make_float3(0.26068555009f, 0.77489446333f, -0.03558001342), make_float3(-0.009310198218f, -0.004612467044f, 1.10298041602))
#define matrix_bmdwg_to_xyz make_float3x3(make_float3(0.606538368282783846f, 0.220412735329269888f, 0.12350482343961787f), make_float3(0.2679929400567444f, 0.832748409123375777f, -0.100741349180120274f), make_float3(-0.029442554160109307f, -0.0866124302772565829f, 1.20511273519724438f))
#define matrix_egamut_to_xyz make_float3x3(make_float3(0.705396850087770755f, 0.164041328309919021f, 0.0810177486539819941f), make_float3(0.280130724091105898f, 0.820206641549595106f, -0.100337365640700782f), make_float3(-0.103781511569163279f, -0.0729072570266306313f, 1.26574651935567273f))
#define matrix_egamut2_to_xyz make_float3x3(make_float3(0.736477700183697404f, 0.130739651086660136f, 0.0832385757813140781f), make_float3(0.275069984405959256f, 0.828017790215514138f, -0.103087774621473588f), make_float3(-0.124225154247852534f, -0.0871597673911067433f, 1.30044267239883782f))
#define matrix_davinciwg_to_xyz make_float3x3(make_float3(0.700622392093671609f, 0.148774815123196763f, 0.101058719834803246f), make_float3(0.274118510906649016f, 0.873631895940436665f, -0.147750406847085763f), make_float3(-0.0989629128832311411f, -0.137895325075543307f, 1.32591598871865268f))

// P3D65 to XYZ D65
#define matrix_p3d65_to_xyz make_float3x3(make_float3(0.486570948648216151f, 0.265667693169093f, 0.198217285234362467f), make_float3(0.228974564069748754f, 0.691738521836506193f, 0.079286914093744984f), make_float3(-4.00000000000000029e-17f, 0.0451133818589026167f, 1.04394436890097575f))
// XYZ D65 to P3D65
#define matrix_xyz_to_p3d65 make_float3x3(make_float3(2.49349691194142542f, -0.93138361791912383f, -0.402710784450716841f), make_float3(-0.829488969561574696f, 1.76266406031834655f, 0.0236246858419435941f), make_float3(0.0358458302437844531f, -0.0761723892680418041f, 0.956884524007687309f))
// Rec709 to XYZ D65
#define matrix_rec709_to_xyz make_float3x3(make_float3(0.412390799265959229f, 0.357584339383878125f, 0.180480788401834347f), make_float3(0.212639005871510217f, 0.71516867876775625f, 0.0721923153607337414f), make_float3(0.0193308187155918181f, 0.119194779794626018f, 0.950532152249661033f))
// XYZ D65 to Rec709
#define matrix_xyz_to_rec709 make_float3x3(make_float3(3.24096994190452348f, -1.53738317757009435f, -0.498610760293003552f), make_float3(-0.969243636280879506f, 1.87596750150771996f, 0.0415550574071755843f), make_float3(0.0556300796969936354f, -0.20397695888897649f, 1.05697151424287816f))
// P3D65 to Rec2020
#define matrix_p3_to_rec2020 make_float3x3(make_float3(0.753833034361722221f, 0.198597369052616435f, 0.0475695965856618441f), make_float3(0.0457438489653582137f, 0.9417772198116936f, 0.0124789312229481135f), make_float3(-0.0012103403545183941f, 0.0176017173010899926f, 0.983608623053428777f))
// P3DCI to XYZ DCI (NPM Matrix)
#define matrix_p3dci_to_xyz make_float3x3(make_float3(0.445169815564552429f, 0.27713440920677751f, 0.172282669815564504f), make_float3(0.209491677912730545f, 0.721595254161043309f, 0.0689130679262257989f), make_float3(-3.59999999999999995e-17f, 0.0470605600539811264f, 0.9073553943619731f))

/******************************************************************
  CAT02 Chromatic Adaptation Matrices
 ******************************************************************/

// DCI to D93 : [0.314, 0.351] to [0.283, 0.297]
#define matrix_cat_dci_to_d93 make_float3x3(make_float3(0.965685009956359863f, 0.00183745240792632103f, 0.0912967324256896973f), make_float3(0.000514572137035429044f, 0.965166747570037842f, 0.036014653742313385f), make_float3(0.00154250487685203596f, 0.00702651776373386383f, 1.47287476062774658f))
// DCI to D75 : [0.314, 0.351] to [0.29903, 0.31488]
#define matrix_cat_dci_to_d75 make_float3x3(make_float3(0.990120768547058105f, 0.0151389474049210548f, 0.0511047691106796265f), make_float3(0.0102197211235761642f, 0.971718132495880127f, 0.0200536623597145081f), make_float3(0.000743072712793946049f, 0.0042176349088549614f, 1.27959656715393066f))
// DCI to D65 : [0.314, 0.351] to [0.3127, 0.329]
#define matrix_cat_dci_to_d65 make_float3x3(make_float3(1.00951600074768066f, 0.0269675441086292267f, 0.0213620811700820923f), make_float3(0.0187991037964820862f, 0.975330352783203125f, 0.0082273334264755249f), make_float3(0.000134543282911180989f, 0.00217903498560190201f, 1.138663649559021f))
// DCI to D60 : [0.314, 0.351] to [0.32162624, 0.337737]
#define matrix_cat_dci_to_d60 make_float3x3(make_float3(1.02159523963928223f, 0.034848678857088089f, 0.00371252000331878705f), make_float3(0.0244968775659799576f, 0.976937234401702881f, 0.00120301544666290305f), make_float3(-0.00023391586728393999f, 0.000986687839031219049f, 1.05594265460968018f))
// DCI to D55 : [0.314, 0.351] to [0.33243, 0.34744]
#define matrix_cat_dci_to_d55 make_float3x3(make_float3(1.03594577312469482f, 0.0450937561690807343f, -0.0157573819160461426f), make_float3(0.0318740680813789368f, 0.977744519710540771f, -0.00655744969844818115f), make_float3(-0.000653609400615095984f, -0.000297372229397297014f, 0.966327786445617676f))
// DCI to D50 : [0.314, 0.351] to [0.3457, 0.3585]
#define matrix_cat_dci_to_d50 make_float3x3(make_float3(1.05306875705718994f, 0.0581297315657138824f, -0.0376100838184356689f), make_float3(0.0412359423935413361f, 0.977693676948547363f, -0.0152792222797870636f), make_float3(-0.00113777676597237609f, -0.00170759297907352404f, 0.867368340492248535f))

// D65 to D93 : [0.3127, 0.329] to [0.283, 0.297]
#define matrix_cat_d65_to_d93 make_float3x3(make_float3(0.95703423023223877f, -0.0247171502560377121f, 0.0624028593301773071f), make_float3(-0.0179296955466270447f, 0.990019857883453369f, 0.0248119533061981201f), make_float3(0.00127589143812656403f, 0.00427919067442417058f, 1.29345715045928955f))
// D65 to D75 : [0.3127, 0.329] to [0.29903, 0.31488]
#define matrix_cat_d65_to_d75 make_float3x3(make_float3(0.981001079082489014f, -0.0116619253531098366f, 0.0265614092350006104f), make_float3(-0.00843488052487373352f, 0.996506094932556152f, 0.0105696544051170349f), make_float3(0.000552809564396739006f, 0.00179840810596942902f, 1.12374722957611084f))
// D65 to D60 : [0.3127, 0.329] to [0.32162624, 0.337737]
#define matrix_cat_d65_to_d60 make_float3x3(make_float3(1.01182246208190918f, 0.00778879318386316299f, -0.0157783031463623047f), make_float3(0.00561682833358645439f, 1.00150644779205322f, -0.00628517568111419678f), make_float3(-0.000335735734552145004f, -0.0010509500280022619f, 0.927366673946380615f))
// D65 to D55 : [0.3127, 0.329] to [0.33243, 0.34744]
#define matrix_cat_d65_to_d55 make_float3x3(make_float3(1.02585089206695557f, 0.0179439820349216461f, -0.0332137793302536011f), make_float3(0.0129133854061365128f, 1.00214779376983643f, -0.0132421031594276428f), make_float3(-0.000719940289855003032f, -0.00218106806278228803f, 0.84868013858795166f))
// D65 to D50 : [0.3127, 0.329] to [0.3457, 0.3585]
#define matrix_cat_d65_to_d50 make_float3x3(make_float3(1.04257404804229736f, 0.03089117631316185f, -0.052812620997428894f), make_float3(0.0221935361623764038f, 1.00185668468475342f, -0.0210737623274326324f), make_float3(-0.00116488314233720303f, -0.00342052709311246915f, 0.761789083480834961f))
// D65 to DCI-P3 : [0.3127, 0.329] to [0.314, 0.351]
#define matrix_cat_d65_to_dci make_float3x3(make_float3(0.991085588932037354f, -0.0273622870445251465f, -0.0183956623077392578f), make_float3(-0.0191021915525197983f, 1.02583777904510498f, -0.00705372542142868042f), make_float3(-8.05503223091359977e-05f, -0.00195988826453685804f, 0.878238439559936523f))

// D60 to D93 : [0.32162624, 0.337737] to [0.283, 0.297]
#define matrix_cat_d60_to_d93 make_float3x3(make_float3(0.946056902408599854f, -0.0319503024220466614f, 0.0831701457500457764f), make_float3(-0.0231979694217443466f, 0.988745808601379395f, 0.0330617502331733704f), make_float3(0.00169203430414199807f, 0.00572328735142946243f, 1.39483106136322021f))
// D60 to D75 : [0.32162624, 0.337737] to [0.29903, 0.31488]
#define matrix_cat_d60_to_d75 make_float3x3(make_float3(0.969659984111785889f, -0.019138311967253685f, 0.0450099557638168335f), make_float3(-0.0138545772060751915f, 0.995133817195892334f, 0.0179062262177467346f), make_float3(0.000931452261283994046f, 0.00306008197367191315f, 1.21179807186126709f))
// D60 to D65 : [0.32162624, 0.337737] to [0.3127, 0.329]
#define matrix_cat_d60_to_d65 make_float3x3(make_float3(0.988363921642303467f, -0.00766910053789615631f, 0.0167641639709472656f), make_float3(-0.0055409618653357029f, 0.998546123504638672f, 0.00667332112789154139f), make_float3(0.000351537019014359008f, 0.00112883746623992898f, 1.07833576202392578f))
// D60 to D55 : [0.32162624, 0.337737] to [0.33243, 0.34744]
#define matrix_cat_d60_to_d55 make_float3x3(make_float3(1.01380288600921631f, 0.0100131509825587273f, -0.018498346209526062f), make_float3(0.00720565160736441612f, 1.00057685375213623f, -0.00737529993057250977f), make_float3(-0.000401133671402930997f, -0.00121434964239597299f, 0.915135681629180908f))
// D60 to D50 : [0.32162624, 0.337737] to [0.3457, 0.3585]
#define matrix_cat_d60_to_d50 make_float3x3(make_float3(1.03025269508361816f, 0.0227910466492176056f, -0.0392656922340393066f), make_float3(0.0163766480982303619f, 1.00020599365234375f, -0.0156668238341808319f), make_float3(-0.000864576781168579947f, -0.00254668481647968292f, 0.821422040462493896f))


// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

__DEVICE__ float fmod_positive(float a, float b) {
    float result = _fmod(a, b);
    return (result < 0.0f) ? result + b : result;
}

__DEVICE__ float clamp(float x, float min_val, float max_val) {
    return _fmaxf(min_val, _fminf(max_val, x));
}

// Gaussian window function for hue loops
// Returns a weight from 0.0 to 1.0 based on distance from center hue
__DEVICE__ float gauss_window(float hue, float center, float width) {
    float diff = hue - center;
    // Handle hue wraparound at 0/360 degrees
    if (diff > 180.0f) diff -= 360.0f;
    if (diff < -180.0f) diff += 360.0f;
    return _expf(-(diff * diff) / (2.0f * width * width));
}

// Matrix 3x3 inversion function
// ADDED: For proper LCH color space conversions with any input gamut
__DEVICE__ float3x3 inv_f33(float3x3 m) {
    float d = m.x.x * (m.y.y * m.z.z - m.z.y * m.y.z) -
              m.x.y * (m.y.x * m.z.z - m.y.z * m.z.x) +
              m.x.z * (m.y.x * m.z.y - m.y.y * m.z.x);

    float id = 1.0f / d;

    float3x3 c;
    c.x.x = id * (m.y.y * m.z.z - m.z.y * m.y.z);
    c.x.y = id * (m.x.z * m.z.y - m.x.y * m.z.z);
    c.x.z = id * (m.x.y * m.y.z - m.x.z * m.y.y);
    c.y.x = id * (m.y.z * m.z.x - m.y.x * m.z.z);
    c.y.y = id * (m.x.x * m.z.z - m.x.z * m.z.x);
    c.y.z = id * (m.y.x * m.x.z - m.x.x * m.y.z);
    c.z.x = id * (m.y.x * m.z.y - m.z.x * m.y.y);
    c.z.y = id * (m.z.x * m.x.y - m.x.x * m.z.y);
    c.z.z = id * (m.x.x * m.y.y - m.y.x * m.x.y);

    return c;
}

__DEVICE__ float3 matrix_multiply(float mat[3][3], float3 vec) {
    return make_float3(
        mat[0][0] * vec.x + mat[0][1] * vec.y + mat[0][2] * vec.z,
        mat[1][0] * vec.x + mat[1][1] * vec.y + mat[1][2] * vec.z,
        mat[2][0] * vec.x + mat[2][1] * vec.y + mat[2][2] * vec.z
    );
}

/* Math helper functions ----------------------------*/

__CONSTANT__ float SQRT3 = 1.73205080756887729353f;
__CONSTANT__ float PI =  3.14159265358979323846;


// Return identity 3x3 matrix
__DEVICE__ float3x3 identity() {
  return make_float3x3(make_float3(1.0f, 0.0f, 0.0f), make_float3(0.0f, 1.0f, 0.0f), make_float3(0.0f, 0.0f, 1.0f));
}

// Multiply 3x3 matrix m and float3 vector v
__DEVICE__ float3 vdot(float3x3 m, float3 v) {
  return make_float3(m.x.x*v.x + m.x.y*v.y + m.x.z*v.z, m.y.x*v.x + m.y.y*v.y + m.y.z*v.z, m.z.x*v.x + m.z.y*v.y + m.z.z*v.z);
}

// Safe division of float a by float b
__DEVICE__ float sdivf(float a, float b) {
  if (b == 0.0f) return 0.0f;
  else return a/b;
}

// Safe division of float3 a by float b
__DEVICE__ float3 sdivf3f(float3 a, float b) {
  return make_float3(sdivf(a.x, b), sdivf(a.y, b), sdivf(a.z, b));
}

// Safe element-wise division of float3 a by float3 b
__DEVICE__ float3 sdivf3f3(float3 a, float3 b) {
  return make_float3(sdivf(a.x, b.x), sdivf(a.y, b.y), sdivf(a.z, b.z));
}

// Safe power function raising float a to power float b
__DEVICE__ float spowf(float a, float b) {
  if (a <= 0.0f) return a;
  else return _powf(a, b);
}

// Safe power function raising float3 a to power float b
__DEVICE__ float3 spowf3(float3 a, float b) {
  return make_float3(spowf(a.x, b), spowf(a.y, b), spowf(a.z, b));
}
// Return the hypot or vector length of float2 v
__DEVICE__ float hypotf2(float2 v) { return _sqrtf(_fmaxf(0.0f, v.x*v.x + v.y*v.y)); }

// Return the hypot or vector length of float3 v
__DEVICE__ float hypotf3(float3 v) { return _sqrtf(_fmaxf(0.0f, v.x*v.x + v.y*v.y + v.z*v.z)); }

// Return the min of float3 a
__DEVICE__ float fmaxf3(float3 a) { return _fmaxf(a.x, _fmaxf(a.y, a.z)); }

// Return the max of float3 a
__DEVICE__ float fminf3(float3 a) { return _fminf(a.x, _fminf(a.y, a.z)); }

// Clamp float3 a to max value mx
__DEVICE__ float3 clampmaxf3(float3 a, float mx) { return make_float3(_fminf(a.x, mx), _fminf(a.y, mx), _fminf(a.z, mx)); }

// Clamp float3 a to min value mn
__DEVICE__ float3 clampminf3(float3 a, float mn) { return make_float3(_fmaxf(a.x, mn), _fmaxf(a.y, mn), _fmaxf(a.z, mn)); }

// Clamp float3 a to min value mn and max value mx
__DEVICE__ float clampf(float a, float mn, float mx) { return _fminf(_fmaxf(a, mn), mx); }
__DEVICE__ float3 clampf3(float3 a, float mn, float mx) { return make_float3(clampf(a.x, mn, mx), clampf(a.y, mn, mx), clampf(a.z, mn, mx)); }


/* OETF Linearization Transfer Functions ---------------------------------------- */

__DEVICE__ float oetf_davinci_intermediate(float x) {
    return x <= 0.02740668f ? x/10.44426855f : _exp2f(x/0.07329248f - 7.0f) - 0.0075f;
}
__DEVICE__ float oetf_filmlight_tlog(float x) {
  return x < 0.075f ? (x-0.075f)/16.184376489665897f : _expf((x - 0.5520126568606655f)/0.09232902596577353f) - 0.0057048244042473785f;
}
__DEVICE__ float oetf_acescct(float x) {
  return x <= 0.155251141552511f ? (x - 0.0729055341958355f)/10.5402377416545f : _exp2f(x*17.52f - 9.72f);
}
__DEVICE__ float oetf_arri_logc3(float x) {
  return x < 5.367655f*0.010591f + 0.092809f ? (x - 0.092809f)/5.367655f : (_exp10f((x - 0.385537f)/0.247190f) - 0.052272f)/5.555556f;
}
__DEVICE__ float oetf_arri_logc4(float x) {
  return x < -0.7774983977293537f ? x*0.3033266726886969f - 0.7774983977293537f : (_exp2f(14.0f*(x - 0.09286412512218964f)/0.9071358748778103f + 6.0f) - 64.0f)/2231.8263090676883f;
}
__DEVICE__ float oetf_red_log3g10(float x) {
  return x < 0.0f ? (x/15.1927f) - 0.01f : (_exp10f(x/0.224282f) - 1.0f)/155.975327f - 0.01f;
}
__DEVICE__ float oetf_panasonic_vlog(float x) {
  return x < 0.181f ? (x - 0.125f)/5.6f : _exp10f((x - 0.598206f)/0.241514f) - 0.00873f;
}
__DEVICE__ float oetf_sony_slog3(float x) {
  return x < 171.2102946929f/1023.0f ? (x*1023.0f - 95.0f)*0.01125f/(171.2102946929f - 95.0f) : (_exp10f(((x*1023.0f - 420.0f)/261.5f))*(0.18f + 0.01f) - 0.01f);
}
__DEVICE__ float oetf_fujifilm_flog2(float x) {
  return x < 0.100686685370811f ? (x - 0.092864f)/8.799461f : (_exp10f(((x - 0.384316f)/0.245281f))/5.555556f - 0.064829f/5.555556f);
}


__DEVICE__ float3 linearize(float3 rgb, int tf) {
  if (tf==0) { // Linear
    return rgb;
  } else if (tf==1) { // Davinci Intermediate
    rgb.x = oetf_davinci_intermediate(rgb.x);
    rgb.y = oetf_davinci_intermediate(rgb.y);
    rgb.z = oetf_davinci_intermediate(rgb.z);
  } else if (tf==2) { // Filmlight T-Log
    rgb.x = oetf_filmlight_tlog(rgb.x);
    rgb.y = oetf_filmlight_tlog(rgb.y);
    rgb.z = oetf_filmlight_tlog(rgb.z);
  } else if (tf==3) { // ACEScct
    rgb.x = oetf_acescct(rgb.x);
    rgb.y = oetf_acescct(rgb.y);
    rgb.z = oetf_acescct(rgb.z);
  } else if (tf==4) { // Arri LogC3
    rgb.x = oetf_arri_logc3(rgb.x);
    rgb.y = oetf_arri_logc3(rgb.y);
    rgb.z = oetf_arri_logc3(rgb.z);
  } else if (tf==5) { // Arri LogC4
    rgb.x = oetf_arri_logc4(rgb.x);
    rgb.y = oetf_arri_logc4(rgb.y);
    rgb.z = oetf_arri_logc4(rgb.z);
  } else if (tf==6) { // RedLog3G10
    rgb.x = oetf_red_log3g10(rgb.x);
    rgb.y = oetf_red_log3g10(rgb.y);
    rgb.z = oetf_red_log3g10(rgb.z);
  } else if (tf==7) { // Panasonic V-Log
    rgb.x = oetf_panasonic_vlog(rgb.x);
    rgb.y = oetf_panasonic_vlog(rgb.y);
    rgb.z = oetf_panasonic_vlog(rgb.z);
  } else if (tf==8) { // Sony S-Log3
    rgb.x = oetf_sony_slog3(rgb.x);
    rgb.y = oetf_sony_slog3(rgb.y);
    rgb.z = oetf_sony_slog3(rgb.z);
  } else if (tf==9) { // Fuji F-Log2
    rgb.x = oetf_fujifilm_flog2(rgb.x);
    rgb.y = oetf_fujifilm_flog2(rgb.y);
    rgb.z = oetf_fujifilm_flog2(rgb.z);
  }  return rgb;
}



/* EOTF Transfer Functions ---------------------------------------- */

__DEVICE__ float3 eotf_hlg(float3 rgb, int inverse) {
  /* Apply the HLG Forward or Inverse EOTF for 1000 nits.
      ITU-R Rec BT.2100-2 https://www.itu.int/rec/R-REC-BT.2100
      ITU-R Rep BT.2390-8: https://www.itu.int/pub/R-REP-BT.2390
  */

  if (inverse == 1) {
    float Yd = 0.2627f*rgb.x + 0.6780f*rgb.y + 0.0593f*rgb.z;
    rgb = rgb*spowf(Yd, (1.0f - 1.2f)/1.2f);
    rgb.x = rgb.x <= 1.0f/12.0f ? _sqrtf(3.0f*rgb.x) : 0.17883277f*_logf(12.0f*rgb.x - 0.28466892f) + 0.55991073f;
    rgb.y = rgb.y <= 1.0f/12.0f ? _sqrtf(3.0f*rgb.y) : 0.17883277f*_logf(12.0f*rgb.y - 0.28466892f) + 0.55991073f;
    rgb.z = rgb.z <= 1.0f/12.0f ? _sqrtf(3.0f*rgb.z) : 0.17883277f*_logf(12.0f*rgb.z - 0.28466892f) + 0.55991073f;
  } else {
    rgb.x = rgb.x <= 0.5f ? rgb.x*rgb.x/3.0f : (_expf((rgb.x - 0.55991073f)/0.17883277f) + 0.28466892f)/12.0f;
    rgb.y = rgb.y <= 0.5f ? rgb.y*rgb.y/3.0f : (_expf((rgb.y - 0.55991073f)/0.17883277f) + 0.28466892f)/12.0f;
    rgb.z = rgb.z <= 0.5f ? rgb.z*rgb.z/3.0f : (_expf((rgb.z - 0.55991073f)/0.17883277f) + 0.28466892f)/12.0f;
    float Ys = 0.2627f*rgb.x + 0.6780f*rgb.y + 0.0593f*rgb.z;
    rgb = rgb*spowf(Ys, 1.2f - 1.0f);
  }
  return rgb;
}


__DEVICE__ float3 eotf_pq(float3 rgb, int inverse) {
  /* Apply the ST-2084 PQ Forward or Inverse EOTF
      ITU-R Rec BT.2100-2 https://www.itu.int/rec/R-REC-BT.2100
      ITU-R Rep BT.2390-9 https://www.itu.int/pub/R-REP-BT.2390
      Note: in the spec there is a normalization for peak display luminance.
      For this function we assume the input is already normalized such that 1.0 = 10,000 nits
  */

  const float m1 = 2610.0f/16384.0f;
  const float m2 = 2523.0f/32.0f;
  const float c1 = 107.0f/128.0f;
  const float c2 = 2413.0f/128.0f;
  const float c3 = 2392.0f/128.0f;

  if (inverse == 1) {
    rgb = spowf3(rgb, m1);
    rgb = spowf3((c1 + c2*rgb)/(1.0f + c3*rgb), m2);
  } else {
    rgb = spowf3(rgb, 1.0f/m2);
    rgb = spowf3((rgb - c1)/(c2 - c3*rgb), 1.0f/m1);
  }
  return rgb;
}

// ============================================================================
// COLOR SPACE CONVERSIONS - INPUT/OUTPUT
// ============================================================================

// __DEVICE__ float3 input_transform(float3 rgb, int input_cs) {
//     // Transform input to linear working space
//     if (input_cs == 0) { // DWG - already linear
//         return rgb;
//     } else { // Rec.709 or sRGB - apply gamma
//         float r = (rgb.x <= 0.04045f) ? rgb.x / 12.92f : _powf((rgb.x + 0.055f) / 1.055f, 2.4f);
//         float g = (rgb.y <= 0.04045f) ? rgb.y / 12.92f : _powf((rgb.y + 0.055f) / 1.055f, 2.4f);
//         float b = (rgb.z <= 0.04045f) ? rgb.z / 12.92f : _powf((rgb.z + 0.055f) / 1.055f, 2.4f);
//         return make_float3(r, g, b);
//     }
// }

// __DEVICE__ float3 output_transform(float3 rgb_linear, int input_cs, int output_cs) {
//     // If output is "same as input", just reverse input transform
//     if (output_cs == 0) { // SAME
//         if (input_cs == 0) { // DWG - stay linear
//             return rgb_linear;
//         } else { // Rec.709/sRGB - apply gamma
//             float r = (rgb_linear.x <= 0.0031308f) ? rgb_linear.x * 12.92f : 1.055f * _powf(rgb_linear.x, 1.0f/2.4f) - 0.055f;
//             float g = (rgb_linear.y <= 0.0031308f) ? rgb_linear.y * 12.92f : 1.055f * _powf(rgb_linear.y, 1.0f/2.4f) - 0.055f;
//             float b = (rgb_linear.z <= 0.0031308f) ? rgb_linear.z * 12.92f : 1.055f * _powf(rgb_linear.z, 1.0f/2.4f) - 0.055f;
//             return make_float3(r, g, b);
//         }
//     } else { // REC709_OUT
//         // Convert to Rec.709 with gamma
//         float r = (rgb_linear.x <= 0.0031308f) ? rgb_linear.x * 12.92f : 1.055f * _powf(rgb_linear.x, 1.0f/2.4f) - 0.055f;
//         float g = (rgb_linear.y <= 0.0031308f) ? rgb_linear.y * 12.92f : 1.055f * _powf(rgb_linear.y, 1.0f/2.4f) - 0.055f;
//         float b = (rgb_linear.z <= 0.0031308f) ? rgb_linear.z * 12.92f : 1.055f * _powf(rgb_linear.z, 1.0f/2.4f) - 0.055f;
//         return make_float3(r, g, b);
//     }
// }

// ============================================================================
// COLOR SPACE CONVERSIONS - WORKING SPACES
// ============================================================================

// RGB to HSV
__DEVICE__ float3 rgb_to_hsv(float3 rgb) {
    float r = rgb.x;
    float g = rgb.y;
    float b = rgb.z;
    
    float cmax = _fmaxf(r, _fmaxf(g, b));
    float cmin = _fminf(r, _fminf(g, b));
    float delta = cmax - cmin;
    
    float h = 0.0f;
    if (delta > 0.0f) {
        if (cmax == r) {
            h = 60.0f * fmod_positive((g - b) / delta, 6.0f);
        } else if (cmax == g) {
            h = 60.0f * (((b - r) / delta) + 2.0f);
        } else {
            h = 60.0f * (((r - g) / delta) + 4.0f);
        }
    }
    
    float s = (cmax == 0.0f) ? 0.0f : delta / cmax;
    float v = cmax;
    
    return make_float3(h, s, v);
}

// HSV to RGB
__DEVICE__ float3 hsv_to_rgb(float3 hsv) {
    float h = hsv.x;
    float s = hsv.y;
    float v = hsv.z;
    
    float c = v * s;
    float x = c * (1.0f - _fabs(fmod_positive(h / 60.0f, 2.0f) - 1.0f));
    float m = v - c;
    
    float r, g, b;
    
    if (h >= 0.0f && h < 60.0f) {
        r = c; g = x; b = 0.0f;
    } else if (h >= 60.0f && h < 120.0f) {
        r = x; g = c; b = 0.0f;
    } else if (h >= 120.0f && h < 180.0f) {
        r = 0.0f; g = c; b = x;
    } else if (h >= 180.0f && h < 240.0f) {
        r = 0.0f; g = x; b = c;
    } else if (h >= 240.0f && h < 300.0f) {
        r = x; g = 0.0f; b = c;
    } else {
        r = c; g = 0.0f; b = x;
    }
    
    return make_float3(r + m, g + m, b + m);
}

// RGB to LCH (via XYZ and Lab)
// FIXED: Now uses the input gamut matrix instead of hardcoded Rec.709
__DEVICE__ float3 rgb_to_lch(float3 rgb, float3x3 rgb_to_xyz_matrix) {
    // RGB is already linear, convert to XYZ using the correct input gamut matrix
    float3 xyz = vdot(rgb_to_xyz_matrix, rgb);
    float x = xyz.x;
    float y = xyz.y;
    float z = xyz.z;

    // XYZ to Lab (D65 white point)
    x = x / 0.95047f;
    y = y / 1.00000f;
    z = z / 1.08883f;

    x = (x > 0.008856f) ? _powf(x, 1.0f/3.0f) : (7.787f * x) + 16.0f/116.0f;
    y = (y > 0.008856f) ? _powf(y, 1.0f/3.0f) : (7.787f * y) + 16.0f/116.0f;
    z = (z > 0.008856f) ? _powf(z, 1.0f/3.0f) : (7.787f * z) + 16.0f/116.0f;

    float L = (116.0f * y) - 16.0f;
    float a = 500.0f * (x - y);
    float b_lab = 200.0f * (y - z);

    // Lab to LCH
    float C = _sqrtf(a * a + b_lab * b_lab);
    float H = _atan2f(b_lab, a) * 180.0f / 3.14159265359f;
    if (H < 0.0f) H += 360.0f;

    return make_float3(L / 100.0f, C / 128.0f, H); // Normalize L and C
}

// LCH to RGB
// FIXED: Now uses the input gamut matrix instead of hardcoded Rec.709
__DEVICE__ float3 lch_to_rgb(float3 lch, float3x3 xyz_to_rgb_matrix) {
    float L = lch.x * 100.0f;
    float C = lch.y * 128.0f;
    float H = lch.z;

    // LCH to Lab
    float a = C * _cosf(H * 3.14159265359f / 180.0f);
    float b_lab = C * _sinf(H * 3.14159265359f / 180.0f);

    // Lab to XYZ
    float y = (L + 16.0f) / 116.0f;
    float x = a / 500.0f + y;
    float z = y - b_lab / 200.0f;

    x = (x > 0.206897f) ? _powf(x, 3.0f) : (x - 16.0f/116.0f) / 7.787f;
    y = (y > 0.206897f) ? _powf(y, 3.0f) : (y - 16.0f/116.0f) / 7.787f;
    z = (z > 0.206897f) ? _powf(z, 3.0f) : (z - 16.0f/116.0f) / 7.787f;

    x *= 0.95047f;
    y *= 1.00000f;
    z *= 1.08883f;

    // XYZ to RGB using the correct input gamut matrix
    float3 xyz = make_float3(x, y, z);
    float3 rgb = vdot(xyz_to_rgb_matrix, xyz);

    return make_float3(clamp(rgb.x, 0.0f, 1.0f), clamp(rgb.y, 0.0f, 1.0f), clamp(rgb.z, 0.0f, 1.0f));
}

// RGB to YCbCr
// FIXED: Now uses BT.709 coefficients instead of BT.601 for HD/UHD content
__DEVICE__ float3 rgb_to_ycbcr(float3 rgb) {
    // BT.709 coefficients (for HD/UHD)
    float y  =  0.2126f * rgb.x + 0.7152f * rgb.y + 0.0722f * rgb.z;
    float cb = -0.1146f * rgb.x - 0.3854f * rgb.y + 0.5000f * rgb.z + 0.5f;
    float cr =  0.5000f * rgb.x - 0.4542f * rgb.y - 0.0458f * rgb.z + 0.5f;
    return make_float3(y, cb, cr);
}

// YCbCr to RGB
// FIXED: Now uses BT.709 inverse coefficients
__DEVICE__ float3 ycbcr_to_rgb(float3 ycbcr) {
    float y = ycbcr.x;
    float cb = ycbcr.y - 0.5f;
    float cr = ycbcr.z - 0.5f;

    // BT.709 inverse coefficients
    float r = y + 1.5748f * cr;
    float g = y - 0.1873f * cb - 0.4681f * cr;
    float b = y + 1.8556f * cb;

    return make_float3(clamp(r, 0.0f, 1.0f), clamp(g, 0.0f, 1.0f), clamp(b, 0.0f, 1.0f));
}

// ============================================================================
// CUBIC SPLINE INTERPOLATION
// ============================================================================

__DEVICE__ float cubic_spline_interpolate(float x, const float curve[][2], int size) {
    if (x <= curve[0][0]) return curve[0][1];
    if (x >= curve[size-1][0]) return curve[size-1][1];
    
    for (int i = 0; i < size - 1; i++) {
        float x1 = curve[i][0];
        float y1 = curve[i][1];
        float x2 = curve[i+1][0];
        float y2 = curve[i+1][1];
        
        if (x >= x1 && x <= x2) {
            float t = (x - x1) / (x2 - x1);
            
            float x0 = (i > 0) ? curve[i-1][0] : x1;
            float y0 = (i > 0) ? curve[i-1][1] : y1;
            float x3 = (i < size - 2) ? curve[i+2][0] : x2;
            float y3 = (i < size - 2) ? curve[i+2][1] : y2;
            
            float m1 = (i > 0) ? (y2 - y0) / (x2 - x0) : (y2 - y1) / (x2 - x1);
            float m2 = (i < size - 2) ? (y3 - y1) / (x3 - x1) : (y2 - y1) / (x2 - x1);
            
            float t2 = t * t;
            float t3 = t2 * t;
            float h00 = 2.0f * t3 - 3.0f * t2 + 1.0f;
            float h10 = t3 - 2.0f * t2 + t;
            float h01 = -2.0f * t3 + 3.0f * t2;
            float h11 = t3 - t2;
            
            return h00 * y1 + h10 * (x2 - x1) * m1 + h01 * y2 + h11 * (x2 - x1) * m2;
        }
    }
    
    return curve[size-1][1];
}

// ============================================================================
// ORGANIC HIGHLIGHT/SHADOW DESATURATION
// ============================================================================

__DEVICE__ float organic_lum_desat(float luminance, float shadow_desat, float highlight_desat) {
    float shadow_factor = 1.0f;
    if (luminance < 0.3f) {
        float t = luminance / 0.3f;
        float shadow_curve = t * t * (3.0f - 2.0f * t);
        shadow_factor = 1.0f - shadow_desat * (1.0f - shadow_curve);
    }
    
    float highlight_factor = 1.0f;
    if (luminance > 0.7f) {
        float t = (luminance - 0.7f) / 0.3f;
        float highlight_curve = t * t * (3.0f - 2.0f * t);
        highlight_factor = 1.0f - highlight_desat * highlight_curve;
    }
    
    return shadow_factor * highlight_factor;
}

// ============================================================================
// PRESET CURVE DATA
// ============================================================================

// Include all preset data here (Neutral, Velvia, Portra, Cinestill, Teal&Orange, Agfa, Custom)
// [I'll add complete presets in next message to keep this readable]

// NEUTRAL PRESET
__CONSTANT__ float hueVsHue_NEUTRAL[][2] = {{0.0f, 0.0f}, {360.0f, 0.0f}};
__CONSTANT__ float hueVsSat_NEUTRAL[][2] = {{0.0f, 1.0f}, {360.0f, 1.0f}};
__CONSTANT__ float hueVsLum_NEUTRAL[][2] = {{0.0f, 0.0f}, {360.0f, 0.0f}};
__CONSTANT__ float satVsSat_NEUTRAL[][2] = {{0.0f, 0.0f}, {1.0f, 1.0f}};
__CONSTANT__ float satVsLum_NEUTRAL[][2] = {{0.0f, 0.0f}, {1.0f, 0.0f}};
__CONSTANT__ float lumVsSat_NEUTRAL[][2] = {{0.0f, 1.0f}, {1.0f, 1.0f}};
__CONSTANT__ float lumVsLum_NEUTRAL[][2] = {{0.0f, 0.0f}, {1.0f, 1.0f}};
__CONSTANT__ float redCurve_NEUTRAL[][2] = {{0.0f, 0.0f}, {1.0f, 1.0f}};
__CONSTANT__ float greenCurve_NEUTRAL[][2] = {{0.0f, 0.0f}, {1.0f, 1.0f}};
__CONSTANT__ float blueCurve_NEUTRAL[][2] = {{0.0f, 0.0f}, {1.0f, 1.0f}};

// FUJI VELVIA PRESET
__CONSTANT__ float hueVsHue_VELVIA[][2] = {
    {0.0f, 5.0f}, {60.0f, 10.0f}, {120.0f, -5.0f}, {180.0f, 0.0f}, 
    {240.0f, 5.0f}, {300.0f, 0.0f}, {360.0f, 5.0f}
};
__CONSTANT__ float hueVsSat_VELVIA[][2] = {
    {0.0f, 1.15f}, {60.0f, 1.25f}, {120.0f, 1.35f}, {180.0f, 1.2f}, 
    {240.0f, 1.3f}, {300.0f, 1.1f}, {360.0f, 1.15f}
};
__CONSTANT__ float hueVsLum_VELVIA[][2] = {
    {0.0f, 0.0f}, {60.0f, 0.03f}, {120.0f, 0.0f}, {180.0f, -0.02f}, 
    {240.0f, -0.02f}, {300.0f, 0.0f}, {360.0f, 0.0f}
};
__CONSTANT__ float satVsSat_VELVIA[][2] = {
    {0.0f, 0.0f}, {0.3f, 0.32f}, {0.6f, 0.65f}, {0.85f, 0.88f}, {1.0f, 0.95f}
};
__CONSTANT__ float satVsLum_VELVIA[][2] = {
    {0.0f, 0.0f}, {0.5f, -0.01f}, {1.0f, -0.03f}
};
__CONSTANT__ float lumVsSat_VELVIA[][2] = {
    {0.0f, 0.8f}, {0.2f, 1.0f}, {0.5f, 1.0f}, {0.8f, 0.95f}, {1.0f, 0.85f}
};
__CONSTANT__ float lumVsLum_VELVIA[][2] = {
    {0.0f, 0.0f}, {0.15f, 0.18f}, {0.35f, 0.38f}, {0.5f, 0.5f}, 
    {0.7f, 0.68f}, {0.88f, 0.88f}, {1.0f, 1.0f}
};
__CONSTANT__ float redCurve_VELVIA[][2] = {{0.0f, 0.0f}, {0.5f, 0.52f}, {1.0f, 1.0f}};
__CONSTANT__ float greenCurve_VELVIA[][2] = {{0.0f, 0.0f}, {0.5f, 0.49f}, {1.0f, 0.99f}};
__CONSTANT__ float blueCurve_VELVIA[][2] = {{0.0f, 0.0f}, {0.5f, 0.50f}, {1.0f, 1.0f}};

// KODAK PORTRA PRESET
__CONSTANT__ float hueVsHue_PORTRA[][2] = {
    {0.0f, -2.0f}, {30.0f, 3.0f}, {60.0f, 3.0f}, {120.0f, 0.0f}, 
    {180.0f, -3.0f}, {240.0f, -3.0f}, {300.0f, 0.0f}, {360.0f, -2.0f}
};
__CONSTANT__ float hueVsSat_PORTRA[][2] = {
    {0.0f, 0.95f}, {30.0f, 1.0f}, {60.0f, 0.98f}, {120.0f, 0.9f}, 
    {180.0f, 0.93f}, {240.0f, 0.9f}, {300.0f, 0.95f}, {360.0f, 0.95f}
};
__CONSTANT__ float hueVsLum_PORTRA[][2] = {
    {0.0f, 0.0f}, {30.0f, 0.02f}, {60.0f, 0.015f}, {120.0f, 0.0f}, 
    {180.0f, 0.0f}, {240.0f, 0.0f}, {300.0f, 0.0f}, {360.0f, 0.0f}
};
__CONSTANT__ float satVsSat_PORTRA[][2] = {
    {0.0f, 0.0f}, {0.4f, 0.38f}, {0.7f, 0.68f}, {1.0f, 0.92f}
};
__CONSTANT__ float satVsLum_PORTRA[][2] = {
    {0.0f, 0.0f}, {0.5f, -0.005f}, {1.0f, -0.015f}
};
__CONSTANT__ float lumVsSat_PORTRA[][2] = {
    {0.0f, 0.7f}, {0.2f, 0.9f}, {0.5f, 1.0f}, {0.8f, 0.95f}, {1.0f, 0.8f}
};
__CONSTANT__ float lumVsLum_PORTRA[][2] = {
    {0.0f, 0.01f}, {0.15f, 0.16f}, {0.35f, 0.36f}, {0.5f, 0.5f}, 
    {0.7f, 0.71f}, {0.88f, 0.91f}, {1.0f, 0.99f}
};
__CONSTANT__ float redCurve_PORTRA[][2] = {{0.0f, 0.0f}, {0.5f, 0.49f}, {1.0f, 0.99f}};
__CONSTANT__ float greenCurve_PORTRA[][2] = {{0.0f, 0.01f}, {0.5f, 0.50f}, {1.0f, 1.0f}};
__CONSTANT__ float blueCurve_PORTRA[][2] = {{0.0f, 0.0f}, {0.5f, 0.51f}, {1.0f, 1.0f}};

// CINESTILL 800T PRESET
__CONSTANT__ float hueVsHue_CINESTILL[][2] = {
    {0.0f, 10.0f}, {60.0f, 10.0f}, {120.0f, -5.0f}, {180.0f, -10.0f}, 
    {240.0f, -8.0f}, {300.0f, 5.0f}, {360.0f, 10.0f}
};
__CONSTANT__ float hueVsSat_CINESTILL[][2] = {
    {0.0f, 1.15f}, {60.0f, 1.1f}, {120.0f, 0.98f}, {180.0f, 1.1f}, 
    {240.0f, 1.25f}, {300.0f, 1.12f}, {360.0f, 1.15f}
};
__CONSTANT__ float hueVsLum_CINESTILL[][2] = {
    {0.0f, 0.03f}, {60.0f, 0.02f}, {120.0f, 0.0f}, {180.0f, -0.03f}, 
    {240.0f, -0.02f}, {300.0f, 0.0f}, {360.0f, 0.03f}
};
__CONSTANT__ float satVsSat_CINESTILL[][2] = {
    {0.0f, 0.0f}, {0.3f, 0.31f}, {0.6f, 0.63f}, {0.85f, 0.88f}, {1.0f, 0.96f}
};
__CONSTANT__ float satVsLum_CINESTILL[][2] = {
    {0.0f, 0.0f}, {0.6f, 0.01f}, {1.0f, 0.02f}
};
__CONSTANT__ float lumVsSat_CINESTILL[][2] = {
    {0.0f, 0.85f}, {0.2f, 1.0f}, {0.5f, 1.05f}, {0.8f, 1.1f}, {1.0f, 1.0f}
};
__CONSTANT__ float lumVsLum_CINESTILL[][2] = {
    {0.0f, 0.0f}, {0.18f, 0.21f}, {0.38f, 0.42f}, {0.5f, 0.52f}, 
    {0.7f, 0.73f}, {0.88f, 0.91f}, {1.0f, 1.0f}
};
__CONSTANT__ float redCurve_CINESTILL[][2] = {{0.0f, 0.0f}, {0.5f, 0.52f}, {1.0f, 1.0f}};
__CONSTANT__ float greenCurve_CINESTILL[][2] = {{0.0f, 0.0f}, {0.5f, 0.50f}, {1.0f, 1.0f}};
__CONSTANT__ float blueCurve_CINESTILL[][2] = {{0.0f, 0.0f}, {0.5f, 0.48f}, {1.0f, 0.98f}};

// TEAL & ORANGE PRESET
__CONSTANT__ float hueVsHue_TEAL_ORANGE[][2] = {
    {0.0f, 12.0f}, {30.0f, 18.0f}, {60.0f, 8.0f}, {120.0f, 0.0f}, 
    {180.0f, -12.0f}, {200.0f, -18.0f}, {240.0f, -8.0f}, {300.0f, 5.0f}, {360.0f, 12.0f}
};
__CONSTANT__ float hueVsSat_TEAL_ORANGE[][2] = {
    {0.0f, 1.25f}, {30.0f, 1.35f}, {60.0f, 1.15f}, {120.0f, 0.92f}, 
    {180.0f, 1.35f}, {200.0f, 1.4f}, {240.0f, 1.15f}, {300.0f, 1.0f}, {360.0f, 1.25f}
};
__CONSTANT__ float hueVsLum_TEAL_ORANGE[][2] = {
    {0.0f, 0.015f}, {60.0f, 0.02f}, {120.0f, -0.015f}, {180.0f, 0.0f}, 
    {240.0f, -0.02f}, {300.0f, 0.0f}, {360.0f, 0.015f}
};
__CONSTANT__ float satVsSat_TEAL_ORANGE[][2] = {
    {0.0f, 0.0f}, {0.35f, 0.38f}, {0.65f, 0.7f}, {0.9f, 0.93f}, {1.0f, 0.98f}
};
__CONSTANT__ float satVsLum_TEAL_ORANGE[][2] = {
    {0.0f, 0.0f}, {0.55f, -0.008f}, {1.0f, -0.015f}
};
__CONSTANT__ float lumVsSat_TEAL_ORANGE[][2] = {
    {0.0f, 0.75f}, {0.3f, 1.05f}, {0.6f, 1.15f}, {0.85f, 0.95f}, {1.0f, 0.75f}
};
__CONSTANT__ float lumVsLum_TEAL_ORANGE[][2] = {
    {0.0f, 0.03f}, {0.22f, 0.24f}, {0.5f, 0.5f}, {0.8f, 0.83f}, {1.0f, 0.96f}
};
__CONSTANT__ float redCurve_TEAL_ORANGE[][2] = {{0.0f, 0.0f}, {0.5f, 0.51f}, {1.0f, 1.0f}};
__CONSTANT__ float greenCurve_TEAL_ORANGE[][2] = {{0.0f, 0.0f}, {0.5f, 0.50f}, {1.0f, 1.0f}};
__CONSTANT__ float blueCurve_TEAL_ORANGE[][2] = {{0.0f, 0.0f}, {0.5f, 0.49f}, {1.0f, 1.0f}};

// AGFA VISTA PRESET
__CONSTANT__ float hueVsHue_AGFA[][2] = {
    {0.0f, 6.0f}, {60.0f, 10.0f}, {120.0f, 4.0f}, {180.0f, -4.0f}, 
    {240.0f, -2.0f}, {300.0f, 4.0f}, {360.0f, 6.0f}
};
__CONSTANT__ float hueVsSat_AGFA[][2] = {
    {0.0f, 1.08f}, {60.0f, 1.2f}, {120.0f, 1.15f}, {180.0f, 1.0f}, 
    {240.0f, 0.98f}, {300.0f, 1.05f}, {360.0f, 1.08f}
};
__CONSTANT__ float hueVsLum_AGFA[][2] = {
    {0.0f, 0.015f}, {60.0f, 0.03f}, {120.0f, 0.008f}, {180.0f, 0.0f}, 
    {240.0f, -0.008f}, {300.0f, 0.0f}, {360.0f, 0.015f}
};
__CONSTANT__ float satVsSat_AGFA[][2] = {
    {0.0f, 0.0f}, {0.4f, 0.42f}, {0.72f, 0.76f}, {1.0f, 0.98f}
};
__CONSTANT__ float satVsLum_AGFA[][2] = {
    {0.0f, 0.0f}, {0.5f, 0.0f}, {1.0f, 0.005f}
};
__CONSTANT__ float lumVsSat_AGFA[][2] = {
    {0.0f, 0.78f}, {0.3f, 1.02f}, {0.6f, 1.08f}, {1.0f, 0.92f}
};
__CONSTANT__ float lumVsLum_AGFA[][2] = {
    {0.0f, 0.0f}, {0.25f, 0.26f}, {0.5f, 0.5f}, {0.75f, 0.76f}, {1.0f, 1.0f}
};
__CONSTANT__ float redCurve_AGFA[][2] = {{0.0f, 0.0f}, {0.5f, 0.49f}, {1.0f, 0.99f}};
__CONSTANT__ float greenCurve_AGFA[][2] = {{0.0f, 0.0f}, {0.5f, 0.50f}, {1.0f, 1.0f}};
__CONSTANT__ float blueCurve_AGFA[][2] = {{0.0f, 0.008f}, {0.5f, 0.51f}, {1.0f, 1.0f}};

// CUSTOM PRESET - Paste exported curve data here
__CONSTANT__ float hueVsHue_CUSTOM[][2] = {{0.0f, 0.0f}, {360.0f, 0.0f}};
__CONSTANT__ float hueVsSat_CUSTOM[][2] = {{0.0f, 1.0f}, {360.0f, 1.0f}};
__CONSTANT__ float hueVsLum_CUSTOM[][2] = {{0.0f, 0.0f}, {360.0f, 0.0f}};
__CONSTANT__ float satVsSat_CUSTOM[][2] = {{0.0f, 0.0f}, {1.0f, 1.0f}};
__CONSTANT__ float satVsLum_CUSTOM[][2] = {{0.0f, 0.0f}, {1.0f, 0.0f}};
__CONSTANT__ float lumVsSat_CUSTOM[][2] = {{0.0f, 1.0f}, {1.0f, 1.0f}};
__CONSTANT__ float lumVsLum_CUSTOM[][2] = {{0.0f, 0.0f}, {1.0f, 1.0f}};
__CONSTANT__ float redCurve_CUSTOM[][2] = {{0.0f, 0.0f}, {1.0f, 1.0f}};
__CONSTANT__ float greenCurve_CUSTOM[][2] = {{0.0f, 0.0f}, {1.0f, 1.0f}};
__CONSTANT__ float blueCurve_CUSTOM[][2] = {{0.0f, 0.0f}, {1.0f, 1.0f}};

// ============================================================================
// MAIN TRANSFORM
// ============================================================================

__DEVICE__ float3 transform(int p_Width, int p_Height, int p_X, int p_Y, float p_R, float p_G, float p_B) {
    float3 rgb = make_float3(p_R, p_G, p_B);
    
    // ========================================================================
    // INPUT COLOR SPACE HANDLING
    // ========================================================================
    /*----------- DISPLAY ENCODING PRESETS -----------------
        display gamut:
        0. Rec.709
        1. P3D65
        2. Rec.2020
        3. P3-D60
        4. P3-DCI
        5. XYZ
        
        display eotf:
        0. Linear
        1. 2.2 Power sRGB Display
        2. 2.4 Power Rec.1886
        3. 2.6 Power DCI
        4. ST 2084 PQ
        5. HLG
    */
    // Init look preset variables
    int tn_su, display_gamut, eotf;

    if (display_encoding_preset==0) { // Rec.1886
        tn_su = 1;
        display_gamut = 0;
        eotf = 2;
    }
    else if (display_encoding_preset==1) { // sRGB Display
        tn_su = 2;
        display_gamut = 0;
        eotf = 1;
    }
    else if (display_encoding_preset==2) { // Display P3
        tn_su = 2;
        display_gamut = 1;
        eotf = 1;
    }
    else if (display_encoding_preset==3) { // P3-D60
        tn_su = 0;
        display_gamut = 3;
        eotf = 3;
    }
    else if (display_encoding_preset==4) { // P3-DCI
        tn_su = 0;
        display_gamut = 4;
        eotf = 3;
    }
    else if (display_encoding_preset==5) { // DCI P3 XYZ
        tn_su = 0;
        display_gamut = 5;
        eotf = 3;
    }
    else if (display_encoding_preset==6) { // Rec.2100 PQ
        tn_su = 0;
        display_gamut = 2;
        eotf = 4;
    }
    else if (display_encoding_preset==7) { // Rec.2100 HLG
        tn_su = 0;
        display_gamut = 2;
        eotf = 5;
    }
    else if (display_encoding_preset==8) { // Dolby PQ
        tn_su = 0;
        display_gamut = 1;
        eotf = 4;
    }

    float3x3 in_to_xyz;
    if (in_gamut==0) in_to_xyz = identity();
    else if (in_gamut==1) in_to_xyz = matrix_ap0_to_xyz;
    else if (in_gamut==2) in_to_xyz = matrix_ap1_to_xyz;
    else if (in_gamut==3) in_to_xyz = matrix_p3d65_to_xyz;
    else if (in_gamut==4) in_to_xyz = matrix_rec2020_to_xyz;
    else if (in_gamut==5) in_to_xyz = matrix_rec709_to_xyz;
    else if (in_gamut==6) in_to_xyz = matrix_arriwg3_to_xyz;
    else if (in_gamut==7) in_to_xyz = matrix_arriwg4_to_xyz;
    else if (in_gamut==8) in_to_xyz = matrix_redwg_to_xyz;
    else if (in_gamut==9) in_to_xyz = matrix_sonysgamut3_to_xyz;
    else if (in_gamut==10) in_to_xyz = matrix_sonysgamut3cine_to_xyz;
    else if (in_gamut==11) in_to_xyz = matrix_vgamut_to_xyz;
    else if (in_gamut==12) in_to_xyz = matrix_bmdwg_to_xyz;
    else if (in_gamut==13) in_to_xyz = matrix_egamut_to_xyz;
    else if (in_gamut==14) in_to_xyz = matrix_egamut2_to_xyz;
    else if (in_gamut==15) in_to_xyz = matrix_davinciwg_to_xyz;

    float crv_tsn = 0.0f;
    float2 pos = make_float2(p_X, p_Y);
    float2 res = make_float2(p_Width, p_Height);

    // x-position based input value for tonescale overlay
    if (crv_enable == 1) crv_tsn = oetf_filmlight_tlog(pos.x/res.x);

    // Linearize if a non-linear input oetf / transfer function is selected
    rgb = linearize(rgb, in_oetf);
    
    // ========================================================================
    // SELECT PRESET CURVES
    // ========================================================================
    const float (*hueVsHue)[2];
    const float (*hueVsSat)[2];
    const float (*hueVsLum)[2];
    const float (*satVsSat)[2];
    const float (*satVsLum)[2];
    const float (*lumVsSat)[2];
    const float (*lumVsLum)[2];
    const float (*redCurve)[2];
    const float (*greenCurve)[2];
    const float (*blueCurve)[2];
    
    int size_hueVsHue, size_hueVsSat, size_hueVsLum;
    int size_satVsSat, size_satVsLum, size_lumVsSat, size_lumVsLum;
    int size_redCurve, size_greenCurve, size_blueCurve;
    
    float preset_saturation = 1.0f;
    float preset_contrast = 1.0f;
    
    if (preset == 0) { // NEUTRAL
        hueVsHue = hueVsHue_NEUTRAL; size_hueVsHue = 2;
        hueVsSat = hueVsSat_NEUTRAL; size_hueVsSat = 2;
        hueVsLum = hueVsLum_NEUTRAL; size_hueVsLum = 2;
        satVsSat = satVsSat_NEUTRAL; size_satVsSat = 2;
        satVsLum = satVsLum_NEUTRAL; size_satVsLum = 2;
        lumVsSat = lumVsSat_NEUTRAL; size_lumVsSat = 2;
        lumVsLum = lumVsLum_NEUTRAL; size_lumVsLum = 2;
        redCurve = redCurve_NEUTRAL; size_redCurve = 2;
        greenCurve = greenCurve_NEUTRAL; size_greenCurve = 2;
        blueCurve = blueCurve_NEUTRAL; size_blueCurve = 2;
    } else if (preset == 1) { // VELVIA
        hueVsHue = hueVsHue_VELVIA; size_hueVsHue = 7;
        hueVsSat = hueVsSat_VELVIA; size_hueVsSat = 7;
        hueVsLum = hueVsLum_VELVIA; size_hueVsLum = 7;
        satVsSat = satVsSat_VELVIA; size_satVsSat = 5;
        satVsLum = satVsLum_VELVIA; size_satVsLum = 3;
        lumVsSat = lumVsSat_VELVIA; size_lumVsSat = 5;
        lumVsLum = lumVsLum_VELVIA; size_lumVsLum = 7;
        redCurve = redCurve_VELVIA; size_redCurve = 3;
        greenCurve = greenCurve_VELVIA; size_greenCurve = 3;
        blueCurve = blueCurve_VELVIA; size_blueCurve = 3;
        preset_saturation = 1.08f;
        preset_contrast = 1.12f;
    } else if (preset == 2) { // PORTRA
        hueVsHue = hueVsHue_PORTRA; size_hueVsHue = 8;
        hueVsSat = hueVsSat_PORTRA; size_hueVsSat = 8;
        hueVsLum = hueVsLum_PORTRA; size_hueVsLum = 8;
        satVsSat = satVsSat_PORTRA; size_satVsSat = 4;
        satVsLum = satVsLum_PORTRA; size_satVsLum = 3;
        lumVsSat = lumVsSat_PORTRA; size_lumVsSat = 5;
        lumVsLum = lumVsLum_PORTRA; size_lumVsLum = 7;
        redCurve = redCurve_PORTRA; size_redCurve = 3;
        greenCurve = greenCurve_PORTRA; size_greenCurve = 3;
        blueCurve = blueCurve_PORTRA; size_blueCurve = 3;
        preset_saturation = 0.95f;
        preset_contrast = 0.98f;
    } else if (preset == 3) { // CINESTILL
        hueVsHue = hueVsHue_CINESTILL; size_hueVsHue = 7;
        hueVsSat = hueVsSat_CINESTILL; size_hueVsSat = 7;
        hueVsLum = hueVsLum_CINESTILL; size_hueVsLum = 7;
        satVsSat = satVsSat_CINESTILL; size_satVsSat = 5;
        satVsLum = satVsLum_CINESTILL; size_satVsLum = 3;
        lumVsSat = lumVsSat_CINESTILL; size_lumVsSat = 5;
        lumVsLum = lumVsLum_CINESTILL; size_lumVsLum = 7;
        redCurve = redCurve_CINESTILL; size_redCurve = 3;
        greenCurve = greenCurve_CINESTILL; size_greenCurve = 3;
        blueCurve = blueCurve_CINESTILL; size_blueCurve = 3;
        preset_saturation = 1.05f;
        preset_contrast = 1.08f;
    } else if (preset == 4) { // TEAL_ORANGE
        hueVsHue = hueVsHue_TEAL_ORANGE; size_hueVsHue = 9;
        hueVsSat = hueVsSat_TEAL_ORANGE; size_hueVsSat = 9;
        hueVsLum = hueVsLum_TEAL_ORANGE; size_hueVsLum = 7;
        satVsSat = satVsSat_TEAL_ORANGE; size_satVsSat = 5;
        satVsLum = satVsLum_TEAL_ORANGE; size_satVsLum = 3;
        lumVsSat = lumVsSat_TEAL_ORANGE; size_lumVsSat = 5;
        lumVsLum = lumVsLum_TEAL_ORANGE; size_lumVsLum = 5;
        redCurve = redCurve_TEAL_ORANGE; size_redCurve = 3;
        greenCurve = greenCurve_TEAL_ORANGE; size_greenCurve = 3;
        blueCurve = blueCurve_TEAL_ORANGE; size_blueCurve = 3;
        preset_saturation = 1.15f;
        preset_contrast = 1.12f;
    } else if (preset == 5) { // AGFA
        hueVsHue = hueVsHue_AGFA; size_hueVsHue = 7;
        hueVsSat = hueVsSat_AGFA; size_hueVsSat = 7;
        hueVsLum = hueVsLum_AGFA; size_hueVsLum = 7;
        satVsSat = satVsSat_AGFA; size_satVsSat = 4;
        satVsLum = satVsLum_AGFA; size_satVsLum = 3;
        lumVsSat = lumVsSat_AGFA; size_lumVsSat = 4;
        lumVsLum = lumVsLum_AGFA; size_lumVsLum = 5;
        redCurve = redCurve_AGFA; size_redCurve = 3;
        greenCurve = greenCurve_AGFA; size_greenCurve = 3;
        blueCurve = blueCurve_AGFA; size_blueCurve = 3;
        preset_saturation = 1.08f;
        preset_contrast = 1.0f;
    } else { // CUSTOM
        hueVsHue = hueVsHue_CUSTOM; size_hueVsHue = 2;
        hueVsSat = hueVsSat_CUSTOM; size_hueVsSat = 2;
        hueVsLum = hueVsLum_CUSTOM; size_hueVsLum = 2;
        satVsSat = satVsSat_CUSTOM; size_satVsSat = 2;
        satVsLum = satVsLum_CUSTOM; size_satVsLum = 2;
        lumVsSat = lumVsSat_CUSTOM; size_lumVsSat = 2;
        lumVsLum = lumVsLum_CUSTOM; size_lumVsLum = 2;
        redCurve = redCurve_CUSTOM; size_redCurve = 2;
        greenCurve = greenCurve_CUSTOM; size_greenCurve = 2;
        blueCurve = blueCurve_CUSTOM; size_blueCurve = 2;
    }
    
    // Combine preset and user parameters
    float final_saturation = global_saturation * preset_saturation;
    float final_contrast = global_contrast * preset_contrast;
    
    // ========================================================================
    // CONVERT TO WORKING COLOR SPACE
    // ========================================================================
    float h, s, v;
    
    if (working_colorspace == 0) { // HSV
        float3 hsv = rgb_to_hsv(rgb);
        h = hsv.x; s = hsv.y; v = hsv.z;
    } else if (working_colorspace == 1) { // LCH
        // FIXED: Now passes the correct input gamut matrix
        float3 lch = rgb_to_lch(rgb, in_to_xyz);
        v = lch.x; s = lch.y; h = lch.z;
    } else { // YCbCr
        float3 ycbcr = rgb_to_ycbcr(rgb);
        v = ycbcr.x;
        float cb = ycbcr.y - 0.5f;
        float cr = ycbcr.z - 0.5f;
        s = _sqrtf(cb * cb + cr * cr) * 2.0f;
        h = _atan2f(cr, cb) * 180.0f / 3.14159265359f;
        if (h < 0.0f) h += 360.0f;
    }
    
    // ========================================================================
    // PARAMETRIC TRANSFORM PIPELINE
    // ========================================================================
    
    // 1. Hue  Hue shift (+ global hue shift)
    float hue_shift_curve = cubic_spline_interpolate(h, hueVsHue, size_hueVsHue);
    h = fmod_positive(h + hue_shift_curve + hue_shift, 360.0f);
    
    // 2. Hue  Saturation
    float sat_mult_hue = cubic_spline_interpolate(h, hueVsSat, size_hueVsSat);
    s = clamp(s * sat_mult_hue, 0.0f, (working_colorspace == 1) ? 2.0f : 1.0f);
    
    // 3. Hue  Luminance
    float lum_offset_hue = cubic_spline_interpolate(h, hueVsLum, size_hueVsLum);
    v = clamp(v + lum_offset_hue, 0.0f, 1.0f);
    
    // 4. Saturation  Saturation (non-linear compression)
    float sat_mapped = cubic_spline_interpolate(s, satVsSat, size_satVsSat);
    s = clamp(sat_mapped, 0.0f, (working_colorspace == 1) ? 2.0f : 1.0f);

    // 4b. HUE LOOPS: Saturation  Hue (advanced color grading)
    // This creates "spiral" paths in color space where hue rotates as saturation increases
    // Different for each primary/secondary hue region
    if (enable_hue_loops) {
        // Calculate saturation factor (0.0 at low sat, 1.0 at high sat)
        // Uses hue_loop_strength as the threshold
        float sat_factor = _fmaxf(0.0f, (s - hue_loop_strength) / (1.0f - hue_loop_strength));
        sat_factor = sat_factor * sat_factor; // Quadratic easing for smooth transition

        // Calculate hue region weights using Gaussian windows
        // Primary hues (60 width for broader influence)
        float weight_red = gauss_window(h, 0.0f, 60.0f);
        float weight_green = gauss_window(h, 120.0f, 60.0f);
        float weight_blue = gauss_window(h, 240.0f, 60.0f);

        // Secondary hues (45 width for tighter control)
        float weight_yellow = gauss_window(h, 60.0f, 45.0f);
        float weight_cyan = gauss_window(h, 180.0f, 45.0f);
        float weight_magenta = gauss_window(h, 300.0f, 45.0f);

        // Calculate weighted hue shift for this saturation level
        float hue_loop_shift = sat_factor * (
            hue_loop_red * weight_red +
            hue_loop_green * weight_green +
            hue_loop_blue * weight_blue +
            hue_loop_yellow * weight_yellow +
            hue_loop_cyan * weight_cyan +
            hue_loop_magenta * weight_magenta
        );

        // Apply the saturation-based hue rotation
        h = fmod_positive(h + hue_loop_shift, 360.0f);
    }

    // 5. Saturation  Luminance (film density)
    float lum_offset_sat = cubic_spline_interpolate(s, satVsLum, size_satVsLum);
    v = clamp(v + lum_offset_sat, 0.0f, 1.0f);
    
    // 6. Luminance  Saturation
    float sat_mult_lum = cubic_spline_interpolate(v, lumVsSat, size_lumVsSat);
    s = clamp(s * sat_mult_lum, 0.0f, (working_colorspace == 1) ? 2.0f : 1.0f);
    
    // Apply organic highlight/shadow desaturation
    float desat_factor = organic_lum_desat(v, shadow_desat, highlight_desat);
    s = clamp(s * desat_factor, 0.0f, (working_colorspace == 1) ? 2.0f : 1.0f);
    
    // Apply global saturation
    s = clamp(s * final_saturation, 0.0f, (working_colorspace == 1) ? 2.0f : 1.0f);
    
    // 7. Luminance  Luminance (tone curve)
    v = cubic_spline_interpolate(v, lumVsLum, size_lumVsLum);
    
    // Apply contrast around midpoint
    v = 0.5f + (v - 0.5f) * final_contrast;
    
    // Apply exposure
    v = clamp(v * global_exposure, 0.0f, 1.0f);
    
    // ========================================================================
    // CONVERT BACK TO RGB
    // ========================================================================
    float3 rgb_out;
    
    if (working_colorspace == 0) { // HSV
        rgb_out = hsv_to_rgb(make_float3(h, s, v));
    } else if (working_colorspace == 1) { // LCH
        // FIXED: Now passes the inverse matrix for correct conversion
        float3x3 xyz_to_rgb = inv_f33(in_to_xyz);
        rgb_out = lch_to_rgb(make_float3(v, s, h), xyz_to_rgb);
    } else { // YCbCr
        float cb = (s / 2.0f) * _cosf(h * 3.14159265359f / 180.0f) + 0.5f;
        float cr = (s / 2.0f) * _sinf(h * 3.14159265359f / 180.0f) + 0.5f;
        rgb_out = ycbcr_to_rgb(make_float3(v, cb, cr));
    }
    
    // Per-channel curves (simulate film dye layers)
    rgb_out.x = cubic_spline_interpolate(rgb_out.x, redCurve, size_redCurve);
    rgb_out.y = cubic_spline_interpolate(rgb_out.y, greenCurve, size_greenCurve);
    rgb_out.z = cubic_spline_interpolate(rgb_out.z, blueCurve, size_blueCurve);
    
    // Clamp to valid range
    rgb_out.x = clamp(rgb_out.x, 0.0f, 1.0f);
    rgb_out.y = clamp(rgb_out.y, 0.0f, 1.0f);
    rgb_out.z = clamp(rgb_out.z, 0.0f, 1.0f);
    
    // ========================================================================
    // OUTPUT COLOR SPACE HANDLING
    // ========================================================================
    //rgb_out = output_transform(rgb_out, input_colorspace, output_colorspace);
    
    return rgb_out;
}