// ============================================================================
// FILM EMULATION - MODULE 1: HSV COLOR SPACE TEST
// ============================================================================
// Ultra-minimal test DCTL to verify basic color space operations work
// If this works, we can build up the full system modularly
// ============================================================================

DEFINE_UI_PARAMS(hue_shift, Hue Shift, DCTLUI_SLIDER_FLOAT, 0.0, -180.0, 180.0, 1.0)
DEFINE_UI_PARAMS(saturation, Saturation, DCTLUI_SLIDER_FLOAT, 1.0, 0.0, 2.0, 0.01)
DEFINE_UI_PARAMS(value, Value, DCTLUI_SLIDER_FLOAT, 1.0, 0.0, 2.0, 0.01)

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

__DEVICE__ float fmod_positive(float a, float b) {
    float result = _fmod(a, b);
    return (result < 0.0f) ? result + b : result;
}

// ============================================================================
// RGB TO HSV
// ============================================================================

__DEVICE__ float3 rgb_to_hsv(float3 rgb) {
    float r = rgb.x;
    float g = rgb.y;
    float b = rgb.z;
    
    float cmax = _fmaxf(r, _fmaxf(g, b));
    float cmin = _fminf(r, _fminf(g, b));
    float delta = cmax - cmin;
    
    // Hue calculation
    float h = 0.0f;
    if (delta > 0.0f) {
        if (cmax == r) {
            h = 60.0f * fmod_positive((g - b) / delta, 6.0f);
        } else if (cmax == g) {
            h = 60.0f * (((b - r) / delta) + 2.0f);
        } else {
            h = 60.0f * (((r - g) / delta) + 4.0f);
        }
    }
    
    // Saturation
    float s = (cmax == 0.0f) ? 0.0f : delta / cmax;
    
    // Value
    float v = cmax;
    
    return make_float3(h, s, v);
}

// ============================================================================
// HSV TO RGB
// ============================================================================

__DEVICE__ float3 hsv_to_rgb(float3 hsv) {
    float h = hsv.x;
    float s = hsv.y;
    float v = hsv.z;
    
    float c = v * s;
    float x = c * (1.0f - _fabs(fmod_positive(h / 60.0f, 2.0f) - 1.0f));
    float m = v - c;
    
    float r, g, b;
    
    if (h >= 0.0f && h < 60.0f) {
        r = c; g = x; b = 0.0f;
    } else if (h >= 60.0f && h < 120.0f) {
        r = x; g = c; b = 0.0f;
    } else if (h >= 120.0f && h < 180.0f) {
        r = 0.0f; g = c; b = x;
    } else if (h >= 180.0f && h < 240.0f) {
        r = 0.0f; g = x; b = c;
    } else if (h >= 240.0f && h < 300.0f) {
        r = x; g = 0.0f; b = c;
    } else {
        r = c; g = 0.0f; b = x;
    }
    
    return make_float3(r + m, g + m, b + m);
}

// ============================================================================
// MAIN TRANSFORM
// ============================================================================

__DEVICE__ float3 transform(int p_Width, int p_Height, int p_X, int p_Y, float p_R, float p_G, float p_B) {
    // Input RGB
    float3 rgb = make_float3(p_R, p_G, p_B);
    
    // Convert to HSV
    float3 hsv = rgb_to_hsv(rgb);
    
    // Apply transforms
    hsv.x = fmod_positive(hsv.x + hue_shift, 360.0f);  // Hue shift
    hsv.y = _fmaxf(0.0f, _fminf(1.0f, hsv.y * saturation));  // Saturation
    hsv.z = _fmaxf(0.0f, _fminf(1.0f, hsv.z * value));      // Value
    
    // Convert back to RGB
    float3 rgb_out = hsv_to_rgb(hsv);
    
    // Clamp output
    rgb_out.x = _fmaxf(0.0f, _fminf(1.0f, rgb_out.x));
    rgb_out.y = _fmaxf(0.0f, _fminf(1.0f, rgb_out.y));
    rgb_out.z = _fmaxf(0.0f, _fminf(1.0f, rgb_out.z));
    
    return rgb_out;
}