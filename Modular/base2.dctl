// ============================================================================
// FILM EMULATION - MODULE 2: CUBIC SPLINE INTERPOLATION TEST
// ============================================================================
// Tests parametric curve system with simple hue-dependent transforms
// This is the foundation for the full parametric system
// ============================================================================

DEFINE_UI_PARAMS(enable_hue_shift_curve, Enable Hue Shift Curve, DCTLUI_CHECK_BOX, 1)
DEFINE_UI_PARAMS(enable_hue_sat_curve, Enable Hue→Sat Curve, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(global_saturation, Global Saturation, DCTLUI_SLIDER_FLOAT, 1.0, 0.0, 2.0, 0.01)

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

__DEVICE__ float fmod_positive(float a, float b) {
    float result = _fmod(a, b);
    return (result < 0.0f) ? result + b : result;
}

__DEVICE__ float clamp(float x, float min_val, float max_val) {
    return _fmaxf(min_val, _fminf(max_val, x));
}

// ============================================================================
// CUBIC SPLINE INTERPOLATION
// ============================================================================

__DEVICE__ float cubic_spline_interpolate(float x, float curve[][2], int size) {
    // Handle edge cases
    if (x <= curve[0][0]) return curve[0][1];
    if (x >= curve[size-1][0]) return curve[size-1][1];
    
    // Find the segment containing x
    for (int i = 0; i < size - 1; i++) {
        float x1 = curve[i][0];
        float y1 = curve[i][1];
        float x2 = curve[i+1][0];
        float y2 = curve[i+1][1];
        
        if (x >= x1 && x <= x2) {
            // Linear parameter t in [0,1]
            float t = (x - x1) / (x2 - x1);
            
            // Get neighboring points for tangent calculation (Catmull-Rom)
            float x0 = (i > 0) ? curve[i-1][0] : x1;
            float y0 = (i > 0) ? curve[i-1][1] : y1;
            float x3 = (i < size - 2) ? curve[i+2][0] : x2;
            float y3 = (i < size - 2) ? curve[i+2][1] : y2;
            
            // Calculate tangents
            float m1 = (i > 0) ? (y2 - y0) / (x2 - x0) : (y2 - y1) / (x2 - x1);
            float m2 = (i < size - 2) ? (y3 - y1) / (x3 - x1) : (y2 - y1) / (x2 - x1);
            
            // Hermite basis functions
            float t2 = t * t;
            float t3 = t2 * t;
            float h00 = 2.0f * t3 - 3.0f * t2 + 1.0f;
            float h10 = t3 - 2.0f * t2 + t;
            float h01 = -2.0f * t3 + 3.0f * t2;
            float h11 = t3 - t2;
            
            // Hermite interpolation
            return h00 * y1 + h10 * (x2 - x1) * m1 + h01 * y2 + h11 * (x2 - x1) * m2;
        }
    }
    
    return curve[size-1][1];
}

// ============================================================================
// TEST CURVE DATA - Simple Velvia-style curves
// ============================================================================

// Hue vs Hue shift curve (color rotation)
// Makes reds warmer, greens cooler (typical Velvia behavior)
__CONSTANT__ float test_hue_vs_hue[][2] = {
    {0.0f, 5.0f},      // Red: shift +5° (toward orange)
    {60.0f, 10.0f},    // Yellow: shift +10° (warmer)
    {120.0f, -5.0f},   // Green: shift -5° (toward cyan)
    {180.0f, 0.0f},    // Cyan: neutral
    {240.0f, 5.0f},    // Blue: shift +5° (toward purple)
    {300.0f, 0.0f},    // Magenta: neutral
    {360.0f, 5.0f}     // Back to red
};
#define TEST_HUE_VS_HUE_SIZE 7

// Hue vs Saturation curve
// Boosts greens and blues (Velvia signature)
__CONSTANT__ float test_hue_vs_sat[][2] = {
    {0.0f, 1.2f},      // Red: 20% more saturated
    {60.0f, 1.4f},     // Yellow: 40% more saturated
    {120.0f, 1.5f},    // Green: 50% more saturated (Velvia!)
    {180.0f, 1.3f},    // Cyan: 30% more saturated
    {240.0f, 1.4f},    // Blue: 40% more saturated (Velvia!)
    {300.0f, 1.1f},    // Magenta: 10% more saturated
    {360.0f, 1.2f}     // Back to red
};
#define TEST_HUE_VS_SAT_SIZE 7

// ============================================================================
// RGB TO HSV
// ============================================================================

__DEVICE__ float3 rgb_to_hsv(float3 rgb) {
    float r = rgb.x;
    float g = rgb.y;
    float b = rgb.z;
    
    float cmax = _fmaxf(r, _fmaxf(g, b));
    float cmin = _fminf(r, _fminf(g, b));
    float delta = cmax - cmin;
    
    // Hue
    float h = 0.0f;
    if (delta > 0.0f) {
        if (cmax == r) {
            h = 60.0f * fmod_positive((g - b) / delta, 6.0f);
        } else if (cmax == g) {
            h = 60.0f * (((b - r) / delta) + 2.0f);
        } else {
            h = 60.0f * (((r - g) / delta) + 4.0f);
        }
    }
    
    // Saturation
    float s = (cmax == 0.0f) ? 0.0f : delta / cmax;
    
    // Value
    float v = cmax;
    
    return make_float3(h, s, v);
}

// ============================================================================
// HSV TO RGB
// ============================================================================

__DEVICE__ float3 hsv_to_rgb(float3 hsv) {
    float h = hsv.x;
    float s = hsv.y;
    float v = hsv.z;
    
    float c = v * s;
    float x = c * (1.0f - _fabs(fmod_positive(h / 60.0f, 2.0f) - 1.0f));
    float m = v - c;
    
    float r, g, b;
    
    if (h >= 0.0f && h < 60.0f) {
        r = c; g = x; b = 0.0f;
    } else if (h >= 60.0f && h < 120.0f) {
        r = x; g = c; b = 0.0f;
    } else if (h >= 120.0f && h < 180.0f) {
        r = 0.0f; g = c; b = x;
    } else if (h >= 180.0f && h < 240.0f) {
        r = 0.0f; g = x; b = c;
    } else if (h >= 240.0f && h < 300.0f) {
        r = x; g = 0.0f; b = c;
    } else {
        r = c; g = 0.0f; b = x;
    }
    
    return make_float3(r + m, g + m, b + m);
}

// ============================================================================
// MAIN TRANSFORM
// ============================================================================

__DEVICE__ float3 transform(int p_Width, int p_Height, int p_X, int p_Y, float p_R, float p_G, float p_B) {
    // Input RGB
    float3 rgb = make_float3(p_R, p_G, p_B);
    
    // Convert to HSV
    float3 hsv = rgb_to_hsv(rgb);
    float h = hsv.x;
    float s = hsv.y;
    float v = hsv.z;
    
    // Apply hue shift curve (if enabled)
    if (enable_hue_shift_curve) {
        float hue_shift = cubic_spline_interpolate(h, test_hue_vs_hue, TEST_HUE_VS_HUE_SIZE);
        h = fmod_positive(h + hue_shift, 360.0f);
    }
    
    // Apply hue-dependent saturation (if enabled)
    if (enable_hue_sat_curve) {
        float sat_mult = cubic_spline_interpolate(h, test_hue_vs_sat, TEST_HUE_VS_SAT_SIZE);
        s = clamp(s * sat_mult, 0.0f, 1.0f);
    }
    
    // Apply global saturation
    s = clamp(s * global_saturation, 0.0f, 1.0f);
    
    // Reconstruct HSV
    hsv = make_float3(h, s, v);
    
    // Convert back to RGB
    float3 rgb_out = hsv_to_rgb(hsv);
    
    // Clamp output
    rgb_out.x = clamp(rgb_out.x, 0.0f, 1.0f);
    rgb_out.y = clamp(rgb_out.y, 0.0f, 1.0f);
    rgb_out.z = clamp(rgb_out.z, 0.0f, 1.0f);
    
    return rgb_out;
}