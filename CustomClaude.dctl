// ============================================================================
// FILM EMULATION DCTL - PROFESSIONAL COLOR GRADING SYSTEM
// ============================================================================
// Version: 1.0
// Compatible with: DaVinci Resolve Studio
// 
// This DCTL implements a comprehensive parametric film emulation system with:
// - 7 parametric curves for color/luminance transforms
// - Per-channel RGB tone curves
// - 3 color space modes (HSV, LCH, YCbCr)
// - Built-in film stock presets
// 
// Generated curve data can be pasted from the Film Emulation Web Tool
// ============================================================================

DEFINE_UI_PARAMS(preset, Film Preset, DCTLUI_COMBO_BOX, 1, {NEUTRAL, VELVIA, PORTRA, CINESTILL, TEAL_ORANGE, AGFA, CUSTOM}, {Neutral, Fuji Velvia, Kodak Portra, Cinestill 800T, Teal & Orange, Agfa Vista, Custom})
DEFINE_UI_PARAMS(color_mode, Color Space, DCTLUI_COMBO_BOX, 0, {HSV, LCH, YCBCR}, {HSV, LCH, YCbCr})
DEFINE_UI_PARAMS(global_exposure, Exposure, DCTLUI_SLIDER_FLOAT, 1.0, 0.5, 2.0, 0.01)
DEFINE_UI_PARAMS(global_saturation, Saturation, DCTLUI_SLIDER_FLOAT, 1.0, 0.0, 2.0, 0.01)
DEFINE_UI_PARAMS(global_contrast, Contrast, DCTLUI_SLIDER_FLOAT, 1.0, 0.5, 2.0, 0.01)

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

__DEVICE__ float clampf(float x, float min, float max) {
    return _fminf(_fmaxf(x, min), max);
}

__DEVICE__ float mod_f(float a, float b) {
    return a - b * _floor(a / b);
}

// ============================================================================
// COLOR SPACE CONVERSIONS
// ============================================================================

// RGB to HSV
__DEVICE__ float3 rgb_to_hsv(float3 rgb) {
    float cmax = _fmaxf(_fmaxf(rgb.x, rgb.y), rgb.z);
    float cmin = _fminf(_fminf(rgb.x, rgb.y), rgb.z);
    float delta = cmax - cmin;
    
    float h = 0.0f;
    if (delta > 0.0f) {
        if (cmax == rgb.x) {
            h = 60.0f * mod_f((rgb.y - rgb.z) / delta, 6.0f);
        } else if (cmax == rgb.y) {
            h = 60.0f * (((rgb.z - rgb.x) / delta) + 2.0f);
        } else {
            h = 60.0f * (((rgb.x - rgb.y) / delta) + 4.0f);
        }
    }
    if (h < 0.0f) h += 360.0f;
    
    float s = (cmax == 0.0f) ? 0.0f : delta / cmax;
    float v = cmax;
    
    return make_float3(h, s, v);
}

// HSV to RGB
__DEVICE__ float3 hsv_to_rgb(float3 hsv) {
    float h = hsv.x;
    float s = hsv.y;
    float v = hsv.z;
    
    float c = v * s;
    float x = c * (1.0f - _fabs(mod_f(h / 60.0f, 2.0f) - 1.0f));
    float m = v - c;
    
    float3 rgb_prime;
    if (h < 60.0f) {
        rgb_prime = make_float3(c, x, 0.0f);
    } else if (h < 120.0f) {
        rgb_prime = make_float3(x, c, 0.0f);
    } else if (h < 180.0f) {
        rgb_prime = make_float3(0.0f, c, x);
    } else if (h < 240.0f) {
        rgb_prime = make_float3(0.0f, x, c);
    } else if (h < 300.0f) {
        rgb_prime = make_float3(x, 0.0f, c);
    } else {
        rgb_prime = make_float3(c, 0.0f, x);
    }
    
    return make_float3(rgb_prime.x + m, rgb_prime.y + m, rgb_prime.z + m);
}

// RGB to LCH (via Lab)
__DEVICE__ float3 rgb_to_lch(float3 rgb) {
    // RGB to linear
    float r = (rgb.x <= 0.04045f) ? rgb.x / 12.92f : _powf((rgb.x + 0.055f) / 1.055f, 2.4f);
    float g = (rgb.y <= 0.04045f) ? rgb.y / 12.92f : _powf((rgb.y + 0.055f) / 1.055f, 2.4f);
    float b = (rgb.z <= 0.04045f) ? rgb.z / 12.92f : _powf((rgb.z + 0.055f) / 1.055f, 2.4f);
    
    // Linear RGB to XYZ (D65)
    float x = r * 0.4124f + g * 0.3576f + b * 0.1805f;
    float y = r * 0.2126f + g * 0.7152f + b * 0.0722f;
    float z = r * 0.0193f + g * 0.1192f + b * 0.9505f;
    
    // XYZ to Lab
    x = x / 0.95047f;
    y = y / 1.00000f;
    z = z / 1.08883f;
    
    x = (x > 0.008856f) ? _powf(x, 1.0f/3.0f) : (7.787f * x) + 16.0f/116.0f;
    y = (y > 0.008856f) ? _powf(y, 1.0f/3.0f) : (7.787f * y) + 16.0f/116.0f;
    z = (z > 0.008856f) ? _powf(z, 1.0f/3.0f) : (7.787f * z) + 16.0f/116.0f;
    
    float L = (116.0f * y) - 16.0f;
    float a = 500.0f * (x - y);
    float b_lab = 200.0f * (y - z);
    
    // Lab to LCH
    float C = _sqrtf(a * a + b_lab * b_lab);
    float H = _atan2f(b_lab, a) * 180.0f / 3.14159265359f;
    if (H < 0.0f) H += 360.0f;
    
    return make_float3(L, C, H);
}

// LCH to RGB
__DEVICE__ float3 lch_to_rgb(float3 lch) {
    float L = lch.x;
    float C = lch.y;
    float H = lch.z;
    
    // LCH to Lab
    float a = C * _cosf(H * 3.14159265359f / 180.0f);
    float b_lab = C * _sinf(H * 3.14159265359f / 180.0f);
    
    // Lab to XYZ
    float y = (L + 16.0f) / 116.0f;
    float x = a / 500.0f + y;
    float z = y - b_lab / 200.0f;
    
    x = (x > 0.206897f) ? _powf(x, 3.0f) : (x - 16.0f/116.0f) / 7.787f;
    y = (y > 0.206897f) ? _powf(y, 3.0f) : (y - 16.0f/116.0f) / 7.787f;
    z = (z > 0.206897f) ? _powf(z, 3.0f) : (z - 16.0f/116.0f) / 7.787f;
    
    x *= 0.95047f;
    y *= 1.00000f;
    z *= 1.08883f;
    
    // XYZ to linear RGB
    float r =  x *  3.2406f + y * -1.5372f + z * -0.4986f;
    float g =  x * -0.9689f + y *  1.8758f + z *  0.0415f;
    float b =  x *  0.0557f + y * -0.2040f + z *  1.0570f;
    
    // Linear to sRGB
    r = (r > 0.0031308f) ? 1.055f * _powf(r, 1.0f/2.4f) - 0.055f : 12.92f * r;
    g = (g > 0.0031308f) ? 1.055f * _powf(g, 1.0f/2.4f) - 0.055f : 12.92f * g;
    b = (b > 0.0031308f) ? 1.055f * _powf(b, 1.0f/2.4f) - 0.055f : 12.92f * b;
    
    return make_float3(clampf(r, 0.0f, 1.0f), clampf(g, 0.0f, 1.0f), clampf(b, 0.0f, 1.0f));
}

// RGB to YCbCr
__DEVICE__ float3 rgb_to_ycbcr(float3 rgb) {
    float y  =  0.299f * rgb.x + 0.587f * rgb.y + 0.114f * rgb.z;
    float cb = -0.169f * rgb.x - 0.331f * rgb.y + 0.500f * rgb.z + 0.5f;
    float cr =  0.500f * rgb.x - 0.419f * rgb.y - 0.081f * rgb.z + 0.5f;
    return make_float3(y, cb, cr);
}

// YCbCr to RGB
__DEVICE__ float3 ycbcr_to_rgb(float3 ycbcr) {
    float y = ycbcr.x;
    float cb = ycbcr.y - 0.5f;
    float cr = ycbcr.z - 0.5f;
    
    float r = y + 1.402f * cr;
    float g = y - 0.344f * cb - 0.714f * cr;
    float b = y + 1.772f * cb;
    
    return make_float3(clampf(r, 0.0f, 1.0f), clampf(g, 0.0f, 1.0f), clampf(b, 0.0f, 1.0f));
}

// ============================================================================
// CUBIC SPLINE INTERPOLATION
// ============================================================================

__DEVICE__ float cubic_spline_interpolate(float x, __CONSTANT__ float curve[][2], int size) {
    // Handle edge cases
    if (x <= curve[0][0]) return curve[0][1];
    if (x >= curve[size-1][0]) return curve[size-1][1];
    
    // Find the segment
    for (int i = 0; i < size - 1; i++) {
        float x1 = curve[i][0];
        float y1 = curve[i][1];
        float x2 = curve[i+1][0];
        float y2 = curve[i+1][1];
        
        if (x >= x1 && x <= x2) {
            float t = (x - x1) / (x2 - x1);
            
            // Get neighboring points for tangent calculation
            float x0 = (i > 0) ? curve[i-1][0] : x1;
            float y0 = (i > 0) ? curve[i-1][1] : y1;
            float x3 = (i < size - 2) ? curve[i+2][0] : x2;
            float y3 = (i < size - 2) ? curve[i+2][1] : y2;
            
            // Calculate tangents (Catmull-Rom)
            float m1 = (i > 0) ? (y2 - y0) / (x2 - x0) : (y2 - y1) / (x2 - x1);
            float m2 = (i < size - 2) ? (y3 - y1) / (x3 - x1) : (y2 - y1) / (x2 - x1);
            
            // Hermite interpolation
            float t2 = t * t;
            float t3 = t2 * t;
            float h00 = 2.0f * t3 - 3.0f * t2 + 1.0f;
            float h10 = t3 - 2.0f * t2 + t;
            float h01 = -2.0f * t3 + 3.0f * t2;
            float h11 = t3 - t2;
            
            return h00 * y1 + h10 * (x2 - x1) * m1 + h01 * y2 + h11 * (x2 - x1) * m2;
        }
    }
    
    return curve[size-1][1];
}

// ============================================================================
// PRESET CURVE DATA
// ============================================================================

// NEUTRAL PRESET
__CONSTANT__ float hueVsHue_NEUTRAL[][2] = {{0.0f, 0.0f}, {360.0f, 0.0f}};
__CONSTANT__ float hueVsSat_NEUTRAL[][2] = {{0.0f, 1.0f}, {360.0f, 1.0f}};
__CONSTANT__ float hueVsLum_NEUTRAL[][2] = {{0.0f, 0.0f}, {360.0f, 0.0f}};
__CONSTANT__ float satVsSat_NEUTRAL[][2] = {{0.0f, 0.0f}, {1.0f, 1.0f}};
__CONSTANT__ float satVsLum_NEUTRAL[][2] = {{0.0f, 0.0f}, {1.0f, 0.0f}};
__CONSTANT__ float lumVsSat_NEUTRAL[][2] = {{0.0f, 1.0f}, {1.0f, 1.0f}};
__CONSTANT__ float lumVsLum_NEUTRAL[][2] = {{0.0f, 0.0f}, {1.0f, 1.0f}};
__CONSTANT__ float redCurve_NEUTRAL[][2] = {{0.0f, 0.0f}, {1.0f, 1.0f}};
__CONSTANT__ float greenCurve_NEUTRAL[][2] = {{0.0f, 0.0f}, {1.0f, 1.0f}};
__CONSTANT__ float blueCurve_NEUTRAL[][2] = {{0.0f, 0.0f}, {1.0f, 1.0f}};

// FUJI VELVIA PRESET
__CONSTANT__ float hueVsHue_VELVIA[][2] = {{0.0f, 5.0f}, {60.0f, 10.0f}, {120.0f, -5.0f}, {180.0f, 0.0f}, {240.0f, 5.0f}, {300.0f, 0.0f}, {360.0f, 5.0f}};
__CONSTANT__ float hueVsSat_VELVIA[][2] = {{0.0f, 1.2f}, {60.0f, 1.4f}, {120.0f, 1.5f}, {180.0f, 1.3f}, {240.0f, 1.4f}, {300.0f, 1.1f}, {360.0f, 1.2f}};
__CONSTANT__ float hueVsLum_VELVIA[][2] = {{0.0f, 0.0f}, {60.0f, 0.05f}, {120.0f, 0.0f}, {180.0f, -0.02f}, {240.0f, -0.03f}, {300.0f, 0.0f}, {360.0f, 0.0f}};
__CONSTANT__ float satVsSat_VELVIA[][2] = {{0.0f, 0.0f}, {0.3f, 0.35f}, {0.6f, 0.7f}, {0.9f, 0.95f}, {1.0f, 1.0f}};
__CONSTANT__ float satVsLum_VELVIA[][2] = {{0.0f, 0.0f}, {0.5f, -0.02f}, {1.0f, -0.05f}};
__CONSTANT__ float lumVsSat_VELVIA[][2] = {{0.0f, 0.7f}, {0.2f, 1.0f}, {0.5f, 1.2f}, {0.8f, 1.1f}, {1.0f, 0.9f}};
__CONSTANT__ float lumVsLum_VELVIA[][2] = {{0.0f, 0.0f}, {0.1f, 0.15f}, {0.3f, 0.35f}, {0.5f, 0.5f}, {0.7f, 0.68f}, {0.9f, 0.88f}, {1.0f, 1.0f}};
__CONSTANT__ float redCurve_VELVIA[][2] = {{0.0f, 0.0f}, {0.5f, 0.52f}, {1.0f, 1.0f}};
__CONSTANT__ float greenCurve_VELVIA[][2] = {{0.0f, 0.0f}, {0.5f, 0.48f}, {1.0f, 0.98f}};
__CONSTANT__ float blueCurve_VELVIA[][2] = {{0.0f, 0.0f}, {0.5f, 0.5f}, {1.0f, 1.0f}};

// KODAK PORTRA PRESET
__CONSTANT__ float hueVsHue_PORTRA[][2] = {{0.0f, -3.0f}, {30.0f, 5.0f}, {60.0f, 5.0f}, {120.0f, 0.0f}, {180.0f, -5.0f}, {240.0f, -5.0f}, {300.0f, 0.0f}, {360.0f, -3.0f}};
__CONSTANT__ float hueVsSat_PORTRA[][2] = {{0.0f, 0.9f}, {30.0f, 1.0f}, {60.0f, 0.95f}, {120.0f, 0.85f}, {180.0f, 0.9f}, {240.0f, 0.85f}, {300.0f, 0.9f}, {360.0f, 0.9f}};
__CONSTANT__ float hueVsLum_PORTRA[][2] = {{0.0f, 0.0f}, {30.0f, 0.03f}, {60.0f, 0.02f}, {120.0f, 0.0f}, {180.0f, 0.0f}, {240.0f, 0.0f}, {300.0f, 0.0f}, {360.0f, 0.0f}};
__CONSTANT__ float satVsSat_PORTRA[][2] = {{0.0f, 0.0f}, {0.4f, 0.35f}, {0.7f, 0.65f}, {1.0f, 0.9f}};
__CONSTANT__ float satVsLum_PORTRA[][2] = {{0.0f, 0.0f}, {0.5f, -0.01f}, {1.0f, -0.03f}};
__CONSTANT__ float lumVsSat_PORTRA[][2] = {{0.0f, 0.6f}, {0.2f, 0.85f}, {0.5f, 1.0f}, {0.8f, 0.95f}, {1.0f, 0.8f}};
__CONSTANT__ float lumVsLum_PORTRA[][2] = {{0.0f, 0.02f}, {0.1f, 0.12f}, {0.3f, 0.32f}, {0.5f, 0.5f}, {0.7f, 0.7f}, {0.9f, 0.92f}, {1.0f, 0.98f}};
__CONSTANT__ float redCurve_PORTRA[][2] = {{0.0f, 0.0f}, {0.5f, 0.48f}, {1.0f, 0.98f}};
__CONSTANT__ float greenCurve_PORTRA[][2] = {{0.0f, 0.02f}, {0.5f, 0.5f}, {1.0f, 1.0f}};
__CONSTANT__ float blueCurve_PORTRA[][2] = {{0.0f, 0.0f}, {0.5f, 0.52f}, {1.0f, 1.0f}};

// CINESTILL 800T PRESET
__CONSTANT__ float hueVsHue_CINESTILL[][2] = {{0.0f, 10.0f}, {60.0f, 10.0f}, {120.0f, -5.0f}, {180.0f, -10.0f}, {240.0f, -8.0f}, {300.0f, 5.0f}, {360.0f, 10.0f}};
__CONSTANT__ float hueVsSat_CINESTILL[][2] = {{0.0f, 1.2f}, {60.0f, 1.1f}, {120.0f, 0.95f}, {180.0f, 1.1f}, {240.0f, 1.3f}, {300.0f, 1.15f}, {360.0f, 1.2f}};
__CONSTANT__ float hueVsLum_CINESTILL[][2] = {{0.0f, 0.05f}, {60.0f, 0.03f}, {120.0f, 0.0f}, {180.0f, -0.05f}, {240.0f, -0.03f}, {300.0f, 0.0f}, {360.0f, 0.05f}};
__CONSTANT__ float satVsSat_CINESTILL[][2] = {{0.0f, 0.0f}, {0.25f, 0.27f}, {0.5f, 0.55f}, {0.75f, 0.78f}, {1.0f, 1.0f}};
__CONSTANT__ float satVsLum_CINESTILL[][2] = {{0.0f, 0.0f}, {0.7f, 0.02f}, {1.0f, 0.05f}};
__CONSTANT__ float lumVsSat_CINESTILL[][2] = {{0.0f, 0.8f}, {0.2f, 1.0f}, {0.5f, 1.1f}, {0.8f, 1.2f}, {1.0f, 1.3f}};
__CONSTANT__ float lumVsLum_CINESTILL[][2] = {{0.0f, 0.0f}, {0.15f, 0.18f}, {0.35f, 0.4f}, {0.5f, 0.52f}, {0.7f, 0.73f}, {0.85f, 0.9f}, {1.0f, 1.0f}};
__CONSTANT__ float redCurve_CINESTILL[][2] = {{0.0f, 0.0f}, {0.5f, 0.52f}, {1.0f, 1.0f}};
__CONSTANT__ float greenCurve_CINESTILL[][2] = {{0.0f, 0.0f}, {0.5f, 0.5f}, {1.0f, 1.0f}};
__CONSTANT__ float blueCurve_CINESTILL[][2] = {{0.0f, 0.0f}, {0.5f, 0.48f}, {1.0f, 0.98f}};

// TEAL & ORANGE PRESET
__CONSTANT__ float hueVsHue_TEAL_ORANGE[][2] = {{0.0f, 15.0f}, {30.0f, 20.0f}, {60.0f, 10.0f}, {120.0f, 0.0f}, {180.0f, -15.0f}, {200.0f, -20.0f}, {240.0f, -10.0f}, {300.0f, 5.0f}, {360.0f, 15.0f}};
__CONSTANT__ float hueVsSat_TEAL_ORANGE[][2] = {{0.0f, 1.3f}, {30.0f, 1.4f}, {60.0f, 1.2f}, {120.0f, 0.9f}, {180.0f, 1.4f}, {200.0f, 1.5f}, {240.0f, 1.2f}, {300.0f, 1.0f}, {360.0f, 1.3f}};
__CONSTANT__ float hueVsLum_TEAL_ORANGE[][2] = {{0.0f, 0.02f}, {60.0f, 0.03f}, {120.0f, -0.02f}, {180.0f, 0.0f}, {240.0f, -0.03f}, {300.0f, 0.0f}, {360.0f, 0.02f}};
__CONSTANT__ float satVsSat_TEAL_ORANGE[][2] = {{0.0f, 0.0f}, {0.3f, 0.35f}, {0.6f, 0.68f}, {0.9f, 0.92f}, {1.0f, 1.0f}};
__CONSTANT__ float satVsLum_TEAL_ORANGE[][2] = {{0.0f, 0.0f}, {0.6f, -0.01f}, {1.0f, -0.02f}};
__CONSTANT__ float lumVsSat_TEAL_ORANGE[][2] = {{0.0f, 0.7f}, {0.3f, 1.1f}, {0.6f, 1.2f}, {0.9f, 0.9f}, {1.0f, 0.7f}};
__CONSTANT__ float lumVsLum_TEAL_ORANGE[][2] = {{0.0f, 0.05f}, {0.2f, 0.22f}, {0.5f, 0.5f}, {0.8f, 0.82f}, {1.0f, 0.95f}};
__CONSTANT__ float redCurve_TEAL_ORANGE[][2] = {{0.0f, 0.0f}, {0.5f, 0.51f}, {1.0f, 1.0f}};
__CONSTANT__ float greenCurve_TEAL_ORANGE[][2] = {{0.0f, 0.0f}, {0.5f, 0.5f}, {1.0f, 1.0f}};
__CONSTANT__ float blueCurve_TEAL_ORANGE[][2] = {{0.0f, 0.0f}, {0.5f, 0.49f}, {1.0f, 1.0f}};

// AGFA VISTA PRESET
__CONSTANT__ float hueVsHue_AGFA[][2] = {{0.0f, 8.0f}, {60.0f, 12.0f}, {120.0f, 5.0f}, {180.0f, -5.0f}, {240.0f, -3.0f}, {300.0f, 5.0f}, {360.0f, 8.0f}};
__CONSTANT__ float hueVsSat_AGFA[][2] = {{0.0f, 1.1f}, {60.0f, 1.25f}, {120.0f, 1.2f}, {180.0f, 1.0f}, {240.0f, 0.95f}, {300.0f, 1.05f}, {360.0f, 1.1f}};
__CONSTANT__ float hueVsLum_AGFA[][2] = {{0.0f, 0.02f}, {60.0f, 0.04f}, {120.0f, 0.01f}, {180.0f, 0.0f}, {240.0f, -0.01f}, {300.0f, 0.0f}, {360.0f, 0.02f}};
__CONSTANT__ float satVsSat_AGFA[][2] = {{0.0f, 0.0f}, {0.4f, 0.43f}, {0.7f, 0.75f}, {1.0f, 1.0f}};
__CONSTANT__ float satVsLum_AGFA[][2] = {{0.0f, 0.0f}, {0.5f, 0.0f}, {1.0f, 0.01f}};
__CONSTANT__ float lumVsSat_AGFA[][2] = {{0.0f, 0.75f}, {0.3f, 1.05f}, {0.6f, 1.1f}, {1.0f, 0.9f}};
__CONSTANT__ float lumVsLum_AGFA[][2] = {{0.0f, 0.0f}, {0.25f, 0.25f}, {0.5f, 0.5f}, {0.75f, 0.75f}, {1.0f, 1.0f}};
__CONSTANT__ float redCurve_AGFA[][2] = {{0.0f, 0.0f}, {0.5f, 0.48f}, {1.0f, 0.98f}};
__CONSTANT__ float greenCurve_AGFA[][2] = {{0.0f, 0.0f}, {0.5f, 0.5f}, {1.0f, 1.0f}};
__CONSTANT__ float blueCurve_AGFA[][2] = {{0.0f, 0.01f}, {0.5f, 0.52f}, {1.0f, 1.0f}};

// CUSTOM PRESET - Replace with exported data from web tool
__CONSTANT__ float hueVsHue_CUSTOM[][2] = {{0.0f, 0.0f}, {360.0f, 0.0f}};
__CONSTANT__ float hueVsSat_CUSTOM[][2] = {{0.0f, 1.0f}, {360.0f, 1.0f}};
__CONSTANT__ float hueVsLum_CUSTOM[][2] = {{0.0f, 0.0f}, {360.0f, 0.0f}};
__CONSTANT__ float satVsSat_CUSTOM[][2] = {{0.0f, 0.0f}, {1.0f, 1.0f}};
__CONSTANT__ float satVsLum_CUSTOM[][2] = {{0.0f, 0.0f}, {1.0f, 0.0f}};
__CONSTANT__ float lumVsSat_CUSTOM[][2] = {{0.0f, 1.0f}, {1.0f, 1.0f}};
__CONSTANT__ float lumVsLum_CUSTOM[][2] = {{0.0f, 0.0f}, {1.0f, 1.0f}};
__CONSTANT__ float redCurve_CUSTOM[][2] = {{0.0f, 0.0f}, {1.0f, 1.0f}};
__CONSTANT__ float greenCurve_CUSTOM[][2] = {{0.0f, 0.0f}, {1.0f, 1.0f}};
__CONSTANT__ float blueCurve_CUSTOM[][2] = {{0.0f, 0.0f}, {1.0f, 1.0f}};

// ============================================================================
// CURVE SIZE DEFINITIONS
// ============================================================================

#define SIZE_HUE_VS_HUE_NEUTRAL 2
#define SIZE_HUE_VS_SAT_NEUTRAL 2
#define SIZE_HUE_VS_LUM_NEUTRAL 2
#define SIZE_SAT_VS_SAT_NEUTRAL 2
#define SIZE_SAT_VS_LUM_NEUTRAL 2
#define SIZE_LUM_VS_SAT_NEUTRAL 2
#define SIZE_LUM_VS_LUM_NEUTRAL 2
#define SIZE_RED_CURVE_NEUTRAL 2
#define SIZE_GREEN_CURVE_NEUTRAL 2
#define SIZE_BLUE_CURVE_NEUTRAL 2

#define SIZE_HUE_VS_HUE_VELVIA 7
#define SIZE_HUE_VS_SAT_VELVIA 7
#define SIZE_HUE_VS_LUM_VELVIA 7
#define SIZE_SAT_VS_SAT_VELVIA 5
#define SIZE_SAT_VS_LUM_VELVIA 3
#define SIZE_LUM_VS_SAT_VELVIA 5
#define SIZE_LUM_VS_LUM_VELVIA 7
#define SIZE_RED_CURVE_VELVIA 3
#define SIZE_GREEN_CURVE_VELVIA 3
#define SIZE_BLUE_CURVE_VELVIA 3

#define SIZE_HUE_VS_HUE_PORTRA 8
#define SIZE_HUE_VS_SAT_PORTRA 8
#define SIZE_HUE_VS_LUM_PORTRA 8
#define SIZE_SAT_VS_SAT_PORTRA 4
#define SIZE_SAT_VS_LUM_PORTRA 3
#define SIZE_LUM_VS_SAT_PORTRA 5
#define SIZE_LUM_VS_LUM_PORTRA 7
#define SIZE_RED_CURVE_PORTRA 3
#define SIZE_GREEN_CURVE_PORTRA 3
#define SIZE_BLUE_CURVE_PORTRA 3

#define SIZE_HUE_VS_HUE_CINESTILL 7
#define SIZE_HUE_VS_SAT_CINESTILL 7
#define SIZE_HUE_VS_LUM_CINESTILL 7
#define SIZE_SAT_VS_SAT_CINESTILL 5
#define SIZE_SAT_VS_LUM_CINESTILL 3
#define SIZE_LUM_VS_SAT_CINESTILL 5
#define SIZE_LUM_VS_LUM_CINESTILL 7
#define SIZE_RED_CURVE_CINESTILL 3
#define SIZE_GREEN_CURVE_CINESTILL 3
#define SIZE_BLUE_CURVE_CINESTILL 3

#define SIZE_HUE_VS_HUE_TEAL_ORANGE 9
#define SIZE_HUE_VS_SAT_TEAL_ORANGE 9
#define SIZE_HUE_VS_LUM_TEAL_ORANGE 7
#define SIZE_SAT_VS_SAT_TEAL_ORANGE 5
#define SIZE_SAT_VS_LUM_TEAL_ORANGE 3
#define SIZE_LUM_VS_SAT_TEAL_ORANGE 5
#define SIZE_LUM_VS_LUM_TEAL_ORANGE 5
#define SIZE_RED_CURVE_TEAL_ORANGE 3
#define SIZE_GREEN_CURVE_TEAL_ORANGE 3
#define SIZE_BLUE_CURVE_TEAL_ORANGE 3

#define SIZE_HUE_VS_HUE_AGFA 7
#define SIZE_HUE_VS_SAT_AGFA 7
#define SIZE_HUE_VS_LUM_AGFA 7
#define SIZE_SAT_VS_SAT_AGFA 4
#define SIZE_SAT_VS_LUM_AGFA 3
#define SIZE_LUM_VS_SAT_AGFA 4
#define SIZE_LUM_VS_LUM_AGFA 5
#define SIZE_RED_CURVE_AGFA 3
#define SIZE_GREEN_CURVE_AGFA 3
#define SIZE_BLUE_CURVE_AGFA 3

#define SIZE_HUE_VS_HUE_CUSTOM 2
#define SIZE_HUE_VS_SAT_CUSTOM 2
#define SIZE_HUE_VS_LUM_CUSTOM 2
#define SIZE_SAT_VS_SAT_CUSTOM 2
#define SIZE_SAT_VS_LUM_CUSTOM 2
#define SIZE_LUM_VS_SAT_CUSTOM 2
#define SIZE_LUM_VS_LUM_CUSTOM 2
#define SIZE_RED_CURVE_CUSTOM 2
#define SIZE_GREEN_CURVE_CUSTOM 2
#define SIZE_BLUE_CURVE_CUSTOM 2

// ============================================================================
// MAIN TRANSFORM FUNCTION
// ============================================================================

__DEVICE__ float3 transform(int p_Width, int p_Height, int p_X, int p_Y, float p_R, float p_G, float p_B) {
    // Input RGB
    float3 rgb = make_float3(p_R, p_G, p_B);
    
    // Select preset curves
    __CONSTANT__ float (*hueVsHue)[2];
    __CONSTANT__ float (*hueVsSat)[2];
    __CONSTANT__ float (*hueVsLum)[2];
    __CONSTANT__ float (*satVsSat)[2];
    __CONSTANT__ float (*satVsLum)[2];
    __CONSTANT__ float (*lumVsSat)[2];
    __CONSTANT__ float (*lumVsLum)[2];
    __CONSTANT__ float (*redCurve)[2];
    __CONSTANT__ float (*greenCurve)[2];
    __CONSTANT__ float (*blueCurve)[2];
    
    int size_hueVsHue, size_hueVsSat, size_hueVsLum;
    int size_satVsSat, size_satVsLum, size_lumVsSat, size_lumVsLum;
    int size_redCurve, size_greenCurve, size_blueCurve;
    
    float preset_exposure = 1.0f;
    float preset_saturation = 1.0f;
    float preset_contrast = 1.0f;
    
    if (preset == NEUTRAL) {
        hueVsHue = hueVsHue_NEUTRAL; size_hueVsHue = SIZE_HUE_VS_HUE_NEUTRAL;
        hueVsSat = hueVsSat_NEUTRAL; size_hueVsSat = SIZE_HUE_VS_SAT_NEUTRAL;
        hueVsLum = hueVsLum_NEUTRAL; size_hueVsLum = SIZE_HUE_VS_LUM_NEUTRAL;
        satVsSat = satVsSat_NEUTRAL; size_satVsSat = SIZE_SAT_VS_SAT_NEUTRAL;
        satVsLum = satVsLum_NEUTRAL; size_satVsLum = SIZE_SAT_VS_LUM_NEUTRAL;
        lumVsSat = lumVsSat_NEUTRAL; size_lumVsSat = SIZE_LUM_VS_SAT_NEUTRAL;
        lumVsLum = lumVsLum_NEUTRAL; size_lumVsLum = SIZE_LUM_VS_LUM_NEUTRAL;
        redCurve = redCurve_NEUTRAL; size_redCurve = SIZE_RED_CURVE_NEUTRAL;
        greenCurve = greenCurve_NEUTRAL; size_greenCurve = SIZE_GREEN_CURVE_NEUTRAL;
        blueCurve = blueCurve_NEUTRAL; size_blueCurve = SIZE_BLUE_CURVE_NEUTRAL;
    } else if (preset == VELVIA) {
        hueVsHue = hueVsHue_VELVIA; size_hueVsHue = SIZE_HUE_VS_HUE_VELVIA;
        hueVsSat = hueVsSat_VELVIA; size_hueVsSat = SIZE_HUE_VS_SAT_VELVIA;
        hueVsLum = hueVsLum_VELVIA; size_hueVsLum = SIZE_HUE_VS_LUM_VELVIA;
        satVsSat = satVsSat_VELVIA; size_satVsSat = SIZE_SAT_VS_SAT_VELVIA;
        satVsLum = satVsLum_VELVIA; size_satVsLum = SIZE_SAT_VS_LUM_VELVIA;
        lumVsSat = lumVsSat_VELVIA; size_lumVsSat = SIZE_LUM_VS_SAT_VELVIA;
        lumVsLum = lumVsLum_VELVIA; size_lumVsLum = SIZE_LUM_VS_LUM_VELVIA;
        redCurve = redCurve_VELVIA; size_redCurve = SIZE_RED_CURVE_VELVIA;
        greenCurve = greenCurve_VELVIA; size_greenCurve = SIZE_GREEN_CURVE_VELVIA;
        blueCurve = blueCurve_VELVIA; size_blueCurve = SIZE_BLUE_CURVE_VELVIA;
        preset_saturation = 1.2f;
        preset_contrast = 1.15f;
    } else if (preset == PORTRA) {
        hueVsHue = hueVsHue_PORTRA; size_hueVsHue = SIZE_HUE_VS_HUE_PORTRA;
        hueVsSat = hueVsSat_PORTRA; size_hueVsSat = SIZE_HUE_VS_SAT_PORTRA;
        hueVsLum = hueVsLum_PORTRA; size_hueVsLum = SIZE_HUE_VS_LUM_PORTRA;
        satVsSat = satVsSat_PORTRA; size_satVsSat = SIZE_SAT_VS_SAT_PORTRA;
        satVsLum = satVsLum_PORTRA; size_satVsLum = SIZE_SAT_VS_LUM_PORTRA;
        lumVsSat = lumVsSat_PORTRA; size_lumVsSat = SIZE_LUM_VS_SAT_PORTRA;
        lumVsLum = lumVsLum_PORTRA; size_lumVsLum = SIZE_LUM_VS_LUM_PORTRA;
        redCurve = redCurve_PORTRA; size_redCurve = SIZE_RED_CURVE_PORTRA;
        greenCurve = greenCurve_PORTRA; size_greenCurve = SIZE_GREEN_CURVE_PORTRA;
        blueCurve = blueCurve_PORTRA; size_blueCurve = SIZE_BLUE_CURVE_PORTRA;
        preset_saturation = 0.9f;
        preset_contrast = 0.95f;
    } else if (preset == CINESTILL) {
        hueVsHue = hueVsHue_CINESTILL; size_hueVsHue = SIZE_HUE_VS_HUE_CINESTILL;
        hueVsSat = hueVsSat_CINESTILL; size_hueVsSat = SIZE_HUE_VS_SAT_CINESTILL;
        hueVsLum = hueVsLum_CINESTILL; size_hueVsLum = SIZE_HUE_VS_LUM_CINESTILL;
        satVsSat = satVsSat_CINESTILL; size_satVsSat = SIZE_SAT_VS_SAT_CINESTILL;
        satVsLum = satVsLum_CINESTILL; size_satVsLum = SIZE_SAT_VS_LUM_CINESTILL;
        lumVsSat = lumVsSat_CINESTILL; size_lumVsSat = SIZE_LUM_VS_SAT_CINESTILL;
        lumVsLum = lumVsLum_CINESTILL; size_lumVsLum = SIZE_LUM_VS_LUM_CINESTILL;
        redCurve = redCurve_CINESTILL; size_redCurve = SIZE_RED_CURVE_CINESTILL;
        greenCurve = greenCurve_CINESTILL; size_greenCurve = SIZE_GREEN_CURVE_CINESTILL;
        blueCurve = blueCurve_CINESTILL; size_blueCurve = SIZE_BLUE_CURVE_CINESTILL;
        preset_saturation = 1.05f;
        preset_contrast = 1.1f;
    } else if (preset == TEAL_ORANGE) {
        hueVsHue = hueVsHue_TEAL_ORANGE; size_hueVsHue = SIZE_HUE_VS_HUE_TEAL_ORANGE;
        hueVsSat = hueVsSat_TEAL_ORANGE; size_hueVsSat = SIZE_HUE_VS_SAT_TEAL_ORANGE;
        hueVsLum = hueVsLum_TEAL_ORANGE; size_hueVsLum = SIZE_HUE_VS_LUM_TEAL_ORANGE;
        satVsSat = satVsSat_TEAL_ORANGE; size_satVsSat = SIZE_SAT_VS_SAT_TEAL_ORANGE;
        satVsLum = satVsLum_TEAL_ORANGE; size_satVsLum = SIZE_SAT_VS_LUM_TEAL_ORANGE;
        lumVsSat = lumVsSat_TEAL_ORANGE; size_lumVsSat = SIZE_LUM_VS_SAT_TEAL_ORANGE;
        lumVsLum = lumVsLum_TEAL_ORANGE; size_lumVsLum = SIZE_LUM_VS_LUM_TEAL_ORANGE;
        redCurve = redCurve_TEAL_ORANGE; size_redCurve = SIZE_RED_CURVE_TEAL_ORANGE;
        greenCurve = greenCurve_TEAL_ORANGE; size_greenCurve = SIZE_GREEN_CURVE_TEAL_ORANGE;
        blueCurve = blueCurve_TEAL_ORANGE; size_blueCurve = SIZE_BLUE_CURVE_TEAL_ORANGE;
        preset_saturation = 1.2f;
        preset_contrast = 1.15f;
    } else if (preset == AGFA) {
        hueVsHue = hueVsHue_AGFA; size_hueVsHue = SIZE_HUE_VS_HUE_AGFA;
        hueVsSat = hueVsSat_AGFA; size_hueVsSat = SIZE_HUE_VS_SAT_AGFA;
        hueVsLum = hueVsLum_AGFA; size_hueVsLum = SIZE_HUE_VS_LUM_AGFA;
        satVsSat = satVsSat_AGFA; size_satVsSat = SIZE_SAT_VS_SAT_AGFA;
        satVsLum = satVsLum_AGFA; size_satVsLum = SIZE_SAT_VS_LUM_AGFA;
        lumVsSat = lumVsSat_AGFA; size_lumVsSat = SIZE_LUM_VS_SAT_AGFA;
        lumVsLum = lumVsLum_AGFA; size_lumVsLum = SIZE_LUM_VS_LUM_AGFA;
        redCurve = redCurve_AGFA; size_redCurve = SIZE_RED_CURVE_AGFA;
        greenCurve = greenCurve_AGFA; size_greenCurve = SIZE_GREEN_CURVE_AGFA;
        blueCurve = blueCurve_AGFA; size_blueCurve = SIZE_BLUE_CURVE_AGFA;
        preset_saturation = 1.1f;
    } else { // CUSTOM
        hueVsHue = hueVsHue_CUSTOM; size_hueVsHue = SIZE_HUE_VS_HUE_CUSTOM;
        hueVsSat = hueVsSat_CUSTOM; size_hueVsSat = SIZE_HUE_VS_SAT_CUSTOM;
        hueVsLum = hueVsLum_CUSTOM; size_hueVsLum = SIZE_HUE_VS_LUM_CUSTOM;
        satVsSat = satVsSat_CUSTOM; size_satVsSat = SIZE_SAT_VS_SAT_CUSTOM;
        satVsLum = satVsLum_CUSTOM; size_satVsLum = SIZE_SAT_VS_LUM_CUSTOM;
        lumVsSat = lumVsSat_CUSTOM; size_lumVsSat = SIZE_LUM_VS_SAT_CUSTOM;
        lumVsLum = lumVsLum_CUSTOM; size_lumVsLum = SIZE_LUM_VS_LUM_CUSTOM;
        redCurve = redCurve_CUSTOM; size_redCurve = SIZE_RED_CURVE_CUSTOM;
        greenCurve = greenCurve_CUSTOM; size_greenCurve = SIZE_GREEN_CURVE_CUSTOM;
        blueCurve = blueCurve_CUSTOM; size_blueCurve = SIZE_BLUE_CURVE_CUSTOM;
    }
    
    // Combine preset and user adjustments
    float final_exposure = global_exposure * preset_exposure;
    float final_saturation = global_saturation * preset_saturation;
    float final_contrast = global_contrast * preset_contrast;
    
    // ========================================================================
    // COLOR TRANSFORM PIPELINE
    // ========================================================================
    
    float h, s, v;
    
    // Convert RGB to selected color space
    if (color_mode == HSV) {
        float3 hsv = rgb_to_hsv(rgb);
        h = hsv.x;
        s = hsv.y;
        v = hsv.z;
    } else if (color_mode == LCH) {
        float3 lch = rgb_to_lch(rgb);
        v = lch.x / 100.0f;  // Normalize L to 0-1
        s = lch.y / 128.0f;  // Normalize C (approximate max chroma)
        h = lch.z;
    } else { // YCBCR
        float3 ycbcr = rgb_to_ycbcr(rgb);
        v = ycbcr.x;  // Y (luma)
        // Convert Cb, Cr to polar coordinates
        float cb = ycbcr.y - 0.5f;
        float cr = ycbcr.z - 0.5f;
        s = _sqrtf(cb * cb + cr * cr) * 2.0f;  // Chroma
        h = _atan2f(cr, cb) * 180.0f / 3.14159265359f;
        if (h < 0.0f) h += 360.0f;
    }
    
    // Apply hue shift
    float hue_shift = cubic_spline_interpolate(h, hueVsHue, size_hueVsHue);
    h = mod_f(h + hue_shift, 360.0f);
    if (h < 0.0f) h += 360.0f;
    
    // Apply hue-dependent saturation
    float sat_mult = cubic_spline_interpolate(h, hueVsSat, size_hueVsSat);
    s = clampf(s * sat_mult, 0.0f, (color_mode == LCH) ? 2.0f : 1.0f);
    
    // Apply hue-dependent luminance
    float lum_offset = cubic_spline_interpolate(h, hueVsLum, size_hueVsLum);
    v = clampf(v + lum_offset, 0.0f, 1.0f);
    
    // Apply saturation-dependent saturation (non-linear)
    float sat_curve = cubic_spline_interpolate(s, satVsSat, size_satVsSat);
    s = clampf(sat_curve, 0.0f, (color_mode == LCH) ? 2.0f : 1.0f);
    
    // Apply saturation-dependent luminance (NEW - Tier 2)
    float sat_lum_offset = cubic_spline_interpolate(s, satVsLum, size_satVsLum);
    v = clampf(v + sat_lum_offset, 0.0f, 1.0f);
    
    // Apply luminance-dependent saturation
    float lum_sat_mult = cubic_spline_interpolate(v, lumVsSat, size_lumVsSat);
    s = clampf(s * lum_sat_mult, 0.0f, (color_mode == LCH) ? 2.0f : 1.0f);
    
    // Apply global saturation
    s = clampf(s * final_saturation, 0.0f, (color_mode == LCH) ? 2.0f : 1.0f);
    
    // Apply tone curve (luminance vs luminance)
    v = cubic_spline_interpolate(v, lumVsLum, size_lumVsLum);
    
    // Apply contrast around midpoint
    v = 0.5f + (v - 0.5f) * final_contrast;
    
    // Apply exposure
    v = clampf(v * final_exposure, 0.0f, 1.0f);
    
    // Convert back to RGB
    float3 rgb_out;
    if (color_mode == HSV) {
        rgb_out = hsv_to_rgb(make_float3(h, s, v));
    } else if (color_mode == LCH) {
        rgb_out = lch_to_rgb(make_float3(v * 100.0f, s * 128.0f, h));
    } else { // YCBCR
        // Convert polar back to Cb, Cr
        float cb = (s / 2.0f) * _cosf(h * 3.14159265359f / 180.0f) + 0.5f;
        float cr = (s / 2.0f) * _sinf(h * 3.14159265359f / 180.0f) + 0.5f;
        rgb_out = ycbcr_to_rgb(make_float3(v, cb, cr));
    }
    
    // Apply per-channel tone curves
    rgb_out.x = cubic_spline_interpolate(rgb_out.x, redCurve, size_redCurve);
    rgb_out.y = cubic_spline_interpolate(rgb_out.y, greenCurve, size_greenCurve);
    rgb_out.z = cubic_spline_interpolate(rgb_out.z, blueCurve, size_blueCurve);
    
    // Final clipping
    rgb_out.x = clampf(rgb_out.x, 0.0f, 1.0f);
    rgb_out.y = clampf(rgb_out.y, 0.0f, 1.0f);
    rgb_out.z = clampf(rgb_out.z, 0.0f, 1.0f);
    
    return rgb_out;
}