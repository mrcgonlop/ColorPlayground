// FilmGrade DCTL - Professional Film Emulation DRT
// Converts DaVinci Wide Gamut + DaVinci Intermediate (log) to Display or Log output
// Provides: Sat→Hue, Lum→Hue, Lum→Lum curves + Film emulation properties
//
// HYBRID APPROACH:
// - Color pipeline from JP_2499 DRT (Juan Pablo Zambrano): Linear Rec.709 working space
// - Hue operations from OpenDRT: Opponent color space for perceptually uniform rotation
// - Gamut compression, tone mapping, purity from JP_2499
//
// Why this hybrid?
// - JP_2499's Linear Rec.709 workflow eliminates artifacts (banding, clipping) from ICtCp/PQ
// - OpenDRT's opponent space enables clean Sat→Hue and Lum→Hue curves without matrix approximation
// - Opponent space separates luminance from hue/chroma, no energy correction needed for rotations
//
// Designed to complement DaVinci Resolve's native curves (Hue→Hue, Hue→Sat, Lum→Sat, etc.)
// Pure 1D color transform (no spatial operations)

DEFINE_UI_PARAMS(preset, Film Preset, DCTLUI_COMBO_BOX, 0, {NEUTRAL, ICONIC_FILM}, {Neutral, Iconic Film})

// Output Settings
DEFINE_UI_PARAMS(output_mode, Output Mode, DCTLUI_COMBO_BOX, 0, {LOG_PASSTHROUGH, REC709_GAMMA22, REC709_GAMMA24, SRGB}, {Log Passthrough, Rec.709 Gamma 2.2, Rec.709 Gamma 2.4, sRGB})

// Curve Enable Toggles
DEFINE_UI_PARAMS(enable_sat_to_hue, Enable Sat→Hue Curve, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(enable_lum_to_hue, Enable Lum→Hue Curve, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(enable_lum_to_lum, Enable Lum→Lum Curve, DCTLUI_CHECK_BOX, 0)

// Film Emulation Properties
DEFINE_UI_PARAMS(enable_gamut_compression, Enable Gamut Compression, DCTLUI_CHECK_BOX, 1)
DEFINE_UI_PARAMS(gamut_compress_power, Gamut Compress Power, DCTLUI_SLIDER_FLOAT, 0.03, 0.01, 0.15, 0.01)

DEFINE_UI_PARAMS(enable_toe_shoulder, Enable Toe/Shoulder, DCTLUI_CHECK_BOX, 1)
DEFINE_UI_PARAMS(toe_mx, Toe Max Input, DCTLUI_SLIDER_FLOAT, 0.18, 0.1, 0.3, 0.01)
DEFINE_UI_PARAMS(toe_my, Toe Min Output, DCTLUI_SLIDER_FLOAT, 0.1, 0.05, 0.2, 0.01)
DEFINE_UI_PARAMS(toe_py, Toe Peak Output, DCTLUI_SLIDER_FLOAT, 1.0, 0.8, 1.2, 0.01)
DEFINE_UI_PARAMS(toe_gamma, Toe Gamma, DCTLUI_SLIDER_FLOAT, 1.15, 0.8, 1.5, 0.01)

DEFINE_UI_PARAMS(enable_purity, Enable Purity saturation, DCTLUI_CHECK_BOX, 1)
DEFINE_UI_PARAMS(purity_red, Purity Red, DCTLUI_SLIDER_FLOAT, 0.0, -0.5, 0.5, 0.01)
DEFINE_UI_PARAMS(purity_green, Purity Green, DCTLUI_SLIDER_FLOAT, 0.0, -0.5, 0.5, 0.01)
DEFINE_UI_PARAMS(purity_blue, Purity Blue, DCTLUI_SLIDER_FLOAT, 0.0, -0.5, 0.5, 0.01)

// Channel Crosstalk (Film Dye Interaction)
DEFINE_UI_PARAMS(enable_crosstalk, Enable Channel Crosstalk, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(crosstalk_rg, Red→Green Crosstalk, DCTLUI_SLIDER_FLOAT, 0.0, -0.3, 0.3, 0.01)
DEFINE_UI_PARAMS(crosstalk_rb, Red→Blue Crosstalk, DCTLUI_SLIDER_FLOAT, 0.0, -0.3, 0.3, 0.01)
DEFINE_UI_PARAMS(crosstalk_gr, Green→Red Crosstalk, DCTLUI_SLIDER_FLOAT, 0.0, -0.3, 0.3, 0.01)
DEFINE_UI_PARAMS(crosstalk_gb, Green→Blue Crosstalk, DCTLUI_SLIDER_FLOAT, 0.0, -0.3, 0.3, 0.01)
DEFINE_UI_PARAMS(crosstalk_br, Blue→Red Crosstalk, DCTLUI_SLIDER_FLOAT, 0.0, -0.3, 0.3, 0.01)
DEFINE_UI_PARAMS(crosstalk_bg, Blue→Green Crosstalk, DCTLUI_SLIDER_FLOAT, 0.0, -0.3, 0.3, 0.01)

// Shadow/Midtone/Highlight Hue Shifts (additive to Lum→Hue curve)
DEFINE_UI_PARAMS(shadow_hue_shift, Shadow Hue Shift deg, DCTLUI_SLIDER_FLOAT, 0.0, -30.0, 30.0, 0.5)
DEFINE_UI_PARAMS(midtone_hue_shift, Midtone Hue Shift deg, DCTLUI_SLIDER_FLOAT, 0.0, -30.0, 30.0, 0.5)
DEFINE_UI_PARAMS(highlight_hue_shift, Highlight Hue Shift deg, DCTLUI_SLIDER_FLOAT, 0.0, -30.0, 30.0, 0.5)

// Per-Channel Gamut Compression
DEFINE_UI_PARAMS(gamut_compress_r, Gamut Compress Red, DCTLUI_SLIDER_FLOAT, 0.03, 0.01, 0.15, 0.01)
DEFINE_UI_PARAMS(gamut_compress_g, Gamut Compress Green, DCTLUI_SLIDER_FLOAT, 0.03, 0.01, 0.15, 0.01)
DEFINE_UI_PARAMS(gamut_compress_b, Gamut Compress Blue, DCTLUI_SLIDER_FLOAT, 0.03, 0.01, 0.15, 0.01)

// Overall RGB Hue Rotation (JP_2499 style)
DEFINE_UI_PARAMS(enable_overall_hue, Enable Overall Hue Rotation, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(overall_hue_r, Overall Hue R, DCTLUI_SLIDER_FLOAT, 0.0, -0.5, 0.5, 0.01)
DEFINE_UI_PARAMS(overall_hue_g, Overall Hue G, DCTLUI_SLIDER_FLOAT, 0.0, -0.5, 0.5, 0.01)
DEFINE_UI_PARAMS(overall_hue_b, Overall Hue B, DCTLUI_SLIDER_FLOAT, 0.0, -0.5, 0.5, 0.01)

// Per-Hue-Zone Sat->Hue (Cyan, Magenta, Yellow zones)
DEFINE_UI_PARAMS(enable_hue_zone_sat, Enable Hue-Zone Sat-Hue, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(sat_hue_cyan, Sat-Hue Cyan deg, DCTLUI_SLIDER_FLOAT, 0.0, -30.0, 30.0, 0.5)
DEFINE_UI_PARAMS(sat_hue_magenta, Sat-Hue Magenta deg, DCTLUI_SLIDER_FLOAT, 0.0, -30.0, 30.0, 0.5)
DEFINE_UI_PARAMS(sat_hue_yellow, Sat-Hue Yellow deg, DCTLUI_SLIDER_FLOAT, 0.0, -30.0, 30.0, 0.5)

// Per-Hue-Zone Lum->Hue (Cyan, Magenta, Yellow zones)
DEFINE_UI_PARAMS(enable_hue_zone_lum, Enable Hue-Zone Lum-Hue, DCTLUI_CHECK_BOX, 0)
DEFINE_UI_PARAMS(lum_hue_cyan, Lum-Hue Cyan deg, DCTLUI_SLIDER_FLOAT, 0.0, -30.0, 30.0, 0.5)
DEFINE_UI_PARAMS(lum_hue_magenta, Lum-Hue Magenta deg, DCTLUI_SLIDER_FLOAT, 0.0, -30.0, 30.0, 0.5)
DEFINE_UI_PARAMS(lum_hue_yellow, Lum-Hue Yellow deg, DCTLUI_SLIDER_FLOAT, 0.0, -30.0, 30.0, 0.5)

// ============================================================================
// MATRIX DEFINITIONS & HELPER FUNCTIONS
// ============================================================================

typedef struct {
    float3 x, y, z;
} float3x3;

__DEVICE__ float3x3 make_float3x3(float3 a, float3 b, float3 c) {
    float3x3 m;
    m.x = a; m.y = b; m.z = c;
    return m;
}

// DaVinci Wide Gamut to XYZ (D65)
#define matrix_davinciwg_to_xyz \
    make_float3x3(make_float3(0.700622320175f, 0.148774802685f, 0.101058728993f), \
                  make_float3(0.274118483067f, 0.873631775379f, -0.147750422359f), \
                  make_float3(-0.098962903023f, -0.137895315886f, 1.325916051865f))

// XYZ to Rec.709
#define matrix_xyz_to_rec709 \
    make_float3x3(make_float3(3.2409699419f, -1.53738317757f, -0.498610760293f), \
                  make_float3(-0.969243636281f, 1.87596750151f, 0.041555057407f), \
                  make_float3(0.055630079697f, -0.203976958889f, 1.05697151424f))

// Rec.709 to XYZ
#define matrix_rec709_to_xyz \
    make_float3x3(make_float3(0.412390917540f, 0.357584357262f, 0.180480793118f), \
                  make_float3(0.212639078498f, 0.715168714523f, 0.072192311287f), \
                  make_float3(0.019330825657f, 0.119194783270f, 0.950532138348f))

__DEVICE__ inline float3x3 inv_f33(float3x3 m) {
    float d = m.x.x * (m.y.y * m.z.z - m.z.y * m.y.z) -
              m.x.y * (m.y.x * m.z.z - m.y.z * m.z.x) +
              m.x.z * (m.y.x * m.z.y - m.y.y * m.z.x);
    float id = 1.0f / d;
    float3x3 c;
    c.x.x = id * (m.y.y * m.z.z - m.z.y * m.y.z);
    c.x.y = id * (m.x.z * m.z.y - m.x.y * m.z.z);
    c.x.z = id * (m.x.y * m.y.z - m.x.z * m.y.y);
    c.y.x = id * (m.y.z * m.z.x - m.y.x * m.z.z);
    c.y.y = id * (m.x.x * m.z.z - m.x.z * m.z.x);
    c.y.z = id * (m.y.x * m.x.z - m.x.x * m.y.z);
    c.z.x = id * (m.y.x * m.z.y - m.z.x * m.y.y);
    c.z.y = id * (m.z.x * m.x.y - m.x.x * m.z.y);
    c.z.z = id * (m.x.x * m.y.y - m.y.x * m.x.y);
    return c;
}

__DEVICE__ inline float3 vdot(float3x3 m, float3 v) {
    return make_float3(
        m.x.x * v.x + m.x.y * v.y + m.x.z * v.z,
        m.y.x * v.x + m.y.y * v.y + m.y.z * v.z,
        m.z.x * v.x + m.z.y * v.y + m.z.z * v.z);
}

__DEVICE__ inline float max3(float x, float y, float z) {
    return _fmaxf(x, _fmaxf(y, z));
}

__DEVICE__ inline float3 maxf3(float b, float3 a) {
    return make_float3(_fmaxf(a.x, b), _fmaxf(a.y, b), _fmaxf(a.z, b));
}

__DEVICE__ inline float3 minf3(float b, float3 a) {
    return make_float3(_fminf(a.x, b), _fminf(a.y, b), _fminf(a.z, b));
}

__DEVICE__ inline float _sign(float x) {
    if (x > 0.0f) return 1.0f;
    if (x < 0.0f) return -1.0f;
    return 0.0f;
}

__DEVICE__ inline float spowf(float a, float b) {
    // Safe power function that preserves sign
    return _sign(a) * _powf(_fabs(a), b);
}

// ============================================================================
// DAVINCI INTERMEDIATE LOG
// ============================================================================

__DEVICE__ inline float oetf_davinci_intermediate(float x, int inv) {
    const float A = 0.0075f;
    const float B = 7.0f;
    const float C = 0.07329248f;
    const float M = 10.44426855f;
    const float LIN_CUT = 0.00262409f;
    const float LOG_CUT = 0.02740668f;

    if (inv == 1) {
        // Log to Linear
        return x <= LOG_CUT ? x / M : _exp2f(x / C - B) - A;
    } else {
        // Linear to Log
        return x <= LIN_CUT ? x * M : (_log2f(x + A) + B) * C;
    }
}

// ============================================================================
// JP_2499 STYLE FUNCTIONS
// ============================================================================

__DEVICE__ inline float3x3 transpose_f33(float3x3 A) {
    float3x3 B;
    B.x = make_float3(A.x.x, A.y.x, A.z.x);
    B.y = make_float3(A.x.y, A.y.y, A.z.y);
    B.z = make_float3(A.x.z, A.y.z, A.z.z);
    return B;
}

__DEVICE__ inline float3 avgweights(float3x3 mt) {
    float3 weights = vdot(mt, make_float3(1.0f, 1.0f, 1.0f));

    mt.x /= weights.x;
    mt.y /= weights.y;
    mt.z /= weights.z;

    mt = transpose_f33(mt);

    weights = make_float3(
        mt.x.x + mt.x.y + mt.x.z,
        mt.y.x + mt.y.y + mt.y.z,
        mt.z.x + mt.z.y + mt.z.z
    );
    weights /= 3.0f;

    return weights;
}

__DEVICE__ inline float powerptoe(float x, float p, float m, float t0) {
    // Power function with toe compression
    float y = x > t0 ? x : (x - t0) * spowf(spowf((t0 - x) / (t0 - m), 1.0f / p) + 1.0f, -p) + t0;
    return y;
}

__DEVICE__ inline float3 powerptoef3f(float3 a, float p, float m, float t0) {
    return make_float3(
        powerptoe(a.x, p, m, t0),
        powerptoe(a.y, p, m, t0),
        powerptoe(a.z, p, m, t0)
    );
}

__DEVICE__ inline float3 NonLinearGamutMapping(float3 in, float p, float m, float t0) {
    // JP_2499 gamut compression: compress ratios, not absolute values
    float mx = max3(in.x, in.y, in.z);

    float3 rats;
    rats.x = mx == 0.0f ? 0.0f : in.x / mx;
    rats.y = mx == 0.0f ? 0.0f : in.y / mx;
    rats.z = mx == 0.0f ? 0.0f : in.z / mx;
    rats = powerptoef3f(rats, p, m, t0);

    float3 out = rats * mx;
    return out;
}

// Per-channel gamut compression (separate power for R, G, B)
__DEVICE__ inline float3 NonLinearGamutMappingPerChannel(float3 in, float p_r, float p_g, float p_b, float m, float t0) {
    float mx = max3(in.x, in.y, in.z);

    float3 rats;
    rats.x = mx == 0.0f ? 0.0f : in.x / mx;
    rats.y = mx == 0.0f ? 0.0f : in.y / mx;
    rats.z = mx == 0.0f ? 0.0f : in.z / mx;

    // Apply different power per channel
    rats.x = powerptoe(rats.x, p_r, m, t0);
    rats.y = powerptoe(rats.y, p_g, m, t0);
    rats.z = powerptoe(rats.z, p_b, m, t0);

    float3 out = rats * mx;
    return out;
}

__DEVICE__ inline float3 EnergyCorrection(float3 pre, float3 post, float3x3 mt) {
    // Preserve luminance/energy after color operations
    float PI_LOCAL = 3.14159265359f;

    float3 weights = avgweights(mt);

    float preavg = weights.x * pre.x + weights.y * pre.y + weights.z * pre.z;
    float postavg = weights.x * post.x + weights.y * post.y + weights.z * post.z;

    float gain = 4.0f * _atan2f(preavg, postavg) / PI_LOCAL;
    gain = powerptoe(gain, 0.16f, 0.0f, 1.0f);
    gain = _sinf(gain * PI_LOCAL / 4.0f) / _cosf(gain * PI_LOCAL / 4.0f);
    gain = isinf(gain) ? 1.0f : gain;

    float3 out = post * gain;
    return out;
}

// Modified Daniele curve (JP_2499 tone mapper)
__DEVICE__ inline float3 modifiedDanieleCurve(float3 rgb, float mx, float my, float py, float g, float o, int inv) {
    float mi = 0.5f * (my + _sqrtf(my * my + 4.0f * my * o));
    float pi = 0.5f * (py + _sqrtf(py * py + 4.0f * py * o));
    float s = ((1.0f - _powf(mi / pi, 1.0f / g)) / _powf(mi / pi, 1.0f / g)) * mx;

    if (inv == 1) {
        // Inverse tone map (not used for forward DRT)
        rgb.x = 0.5f * (rgb.x + _sqrtf(rgb.x * rgb.x + rgb.x * 4.0f * o));
        rgb.y = 0.5f * (rgb.y + _sqrtf(rgb.y * rgb.y + rgb.y * 4.0f * o));
        rgb.z = 0.5f * (rgb.z + _sqrtf(rgb.z * rgb.z + rgb.z * 4.0f * o));

        g = 1.0f / g;

        rgb.x = s * _powf(rgb.x / pi, g) / (1.0f - _powf(rgb.x / pi, g));
        rgb.y = s * _powf(rgb.y / pi, g) / (1.0f - _powf(rgb.y / pi, g));
        rgb.z = s * _powf(rgb.z / pi, g) / (1.0f - _powf(rgb.z / pi, g));

        return rgb;
    } else {
        // Forward tone map
        rgb.x = pi * _powf(rgb.x / (rgb.x + s), g);
        rgb.y = pi * _powf(rgb.y / (rgb.y + s), g);
        rgb.z = pi * _powf(rgb.z / (rgb.z + s), g);

        rgb.x = rgb.x * rgb.x / (rgb.x + o);
        rgb.y = rgb.y * rgb.y / (rgb.y + o);
        rgb.z = rgb.z * rgb.z / (rgb.z + o);

        return rgb;
    }
}

// Purity adjustment (inset matrix for saturation)
__DEVICE__ inline float3x3 simpleInsetMatrix(float red, float green, float blue, int inv) {
    float gain_coef = 1.0f + red + green + blue;

    float3 redcoeff = make_float3(1.0f + red, green, blue) / gain_coef;
    float3 greencoeff = make_float3(red, 1.0f + green, blue) / gain_coef;
    float3 bluecoeff = make_float3(red, green, 1.0f + blue) / gain_coef;

    float3x3 M = make_float3x3(redcoeff, greencoeff, bluecoeff);

    M = inv ? inv_f33(M) : M;

    return M;
}

// Channel crosstalk matrix (film dye interaction)
__DEVICE__ inline float3x3 crosstalkMatrix(float rg, float rb, float gr, float gb, float br, float bg) {
    // Matrix maps input RGB to output RGB with crosstalk
    // Each output channel is influenced by other input channels
    // Example: output_R = input_R + gr*input_G + br*input_B

    float3 redcoeff   = make_float3(1.0f, gr, br);      // R output = R + gr*G + br*B
    float3 greencoeff = make_float3(rg, 1.0f, bg);      // G output = rg*R + G + bg*B
    float3 bluecoeff  = make_float3(rb, gb, 1.0f);      // B output = rb*R + gb*G + B

    return make_float3x3(redcoeff, greencoeff, bluecoeff);
}

// Simple hue matrix (JP_2499 overall hue rotation)
__DEVICE__ inline float3x3 simpleHueMatrix(float red, float green, float blue) {
    float3 redcoeff = make_float3(1.0f, green > 0.0f ? green : 0.0f, blue < 0.0f ? -blue : 0.0f);
    float3 greencoeff = make_float3(red > 0.0f ? red : 0.0f, 1.0f, blue > 0.0f ? blue : 0.0f);
    float3 bluecoeff = make_float3(red < 0.0f ? -red : 0.0f, green < 0.0f ? -green : 0.0f, 1.0f);

    float3 white;
    white.x = 1.0f + redcoeff.y + redcoeff.z;
    white.y = greencoeff.x + 1.0f + greencoeff.z;
    white.z = bluecoeff.x + bluecoeff.y + 1.0f;

    redcoeff = redcoeff / white.x;
    greencoeff = greencoeff / white.y;
    bluecoeff = bluecoeff / white.z;

    return make_float3x3(redcoeff, greencoeff, bluecoeff);
}

// ============================================================================
// OPPONENT COLOR SPACE (from OpenDRT)
// ============================================================================

// Opponent color space: Cyan-Yellow (CY) and Green-Magenta (GM) axes
// Provides perceptually uniform hue representation
__DEVICE__ inline float2 opponent(float3 rgb) {
    // CY axis: R - B (positive = yellow/red, negative = cyan/blue)
    // GM axis: G - (R+B)/2 (positive = green, negative = magenta)
    return make_float2(
        rgb.x - rgb.z,
        rgb.y - (rgb.x + rgb.z) / 2.0f
    );
}

// Inverse opponent: Convert from opponent space back to RGB
__DEVICE__ inline float3 opponent_to_rgb(float2 opp, float lum) {
    // Given opponent coordinates and luminance, reconstruct RGB
    // cy = R - B = opp.x
    // gm = G - (R+B)/2 = opp.y
    // lum = (R + G + B) / 3

    // Solving the system:
    // R + G + B = 3 * lum
    // R - B = cy
    // G - (R+B)/2 = gm

    // From equation 3: G = gm + (R+B)/2
    // Substitute into equation 1: R + gm + (R+B)/2 + B = 3*lum
    // Simplify: 1.5*R + 1.5*B + gm = 3*lum
    // So: R + B = 2*lum - (2/3)*gm

    // From equation 2: R = B + cy
    // Substitute: (B + cy) + B = 2*lum - (2/3)*gm
    // So: B = lum - (1/3)*gm - cy/2

    float b = lum - opp.y / 3.0f - opp.x / 2.0f;
    float r = b + opp.x;
    float g = opp.y + (r + b) / 2.0f;

    return make_float3(r, g, b);
}

// Calculate achromatic distance (saturation) from opponent coordinates
__DEVICE__ inline float achromatic_distance(float2 opp) {
    return _sqrtf(_fmaxf(0.0f, opp.x * opp.x + opp.y * opp.y)) / 2.0f;
}

// Calculate hue angle from opponent coordinates
__DEVICE__ inline float opponent_hue(float2 opp) {
    const float PI = 3.14159265359f;
    // Hue angle in radians, rotated so red = 0
    float hue = _fmod(_atan2f(opp.y, opp.x) + PI + 1.10714931f, 2.0f * PI);
    return hue;
}

// Rotate hue angle by a given amount (in radians)
__DEVICE__ inline float2 rotate_hue(float2 opp, float rotation) {
    float radius = _sqrtf(_fmaxf(0.0f, opp.x * opp.x + opp.y * opp.y));
    if (radius < 1e-6f) return opp;  // Achromatic, no rotation needed

    float hue = _atan2f(opp.y, opp.x);
    hue += rotation;

    return make_float2(
        radius * _cosf(hue),
        radius * _sinf(hue)
    );
}

// Get hue zone weights for Cyan, Magenta, Yellow (film negative primaries)
__DEVICE__ inline float3 get_hue_zone_weights(float2 opp) {
    const float PI = 3.14159265359f;

    // Get hue angle in radians (-PI to PI)
    float hue = _atan2f(opp.y, opp.x);

    // Convert to 0-360 degrees for easier understanding
    float hue_deg = hue * 180.0f / PI;
    if (hue_deg < 0.0f) hue_deg += 360.0f;

    // Film negative primaries (subtractive colors):
    // Cyan: ~180° (opposite of Red)
    // Magenta: ~300° (opposite of Green)
    // Yellow: ~60° (opposite of Blue)

    float cyan_center = 180.0f;
    float magenta_center = 300.0f;
    float yellow_center = 60.0f;

    // Calculate distance to each center (with wraparound)
    float dist_cyan = _fabs(hue_deg - cyan_center);
    if (dist_cyan > 180.0f) dist_cyan = 360.0f - dist_cyan;

    float dist_magenta = _fabs(hue_deg - magenta_center);
    if (dist_magenta > 180.0f) dist_magenta = 360.0f - dist_magenta;

    float dist_yellow = _fabs(hue_deg - yellow_center);
    if (dist_yellow > 180.0f) dist_yellow = 360.0f - dist_yellow;

    // Convert distances to weights (closer = higher weight)
    // Using smooth falloff over 120 degree zones
    float weight_cyan = _fmaxf(0.0f, 1.0f - dist_cyan / 60.0f);
    float weight_magenta = _fmaxf(0.0f, 1.0f - dist_magenta / 60.0f);
    float weight_yellow = _fmaxf(0.0f, 1.0f - dist_yellow / 60.0f);

    // Normalize so weights sum to 1 (if any weight exists)
    float total = weight_cyan + weight_magenta + weight_yellow;
    if (total > 0.001f) {
        weight_cyan /= total;
        weight_magenta /= total;
        weight_yellow /= total;
    }

    return make_float3(weight_cyan, weight_magenta, weight_yellow);
}

// ============================================================================
// CURVE INTERPOLATION
// ============================================================================

__DEVICE__ float cubic_spline_interpolate(float x, const float curve[][2], int size) {
    if (size < 2) return 0.0f;
    if (x <= curve[0][0]) return curve[0][1];
    if (x >= curve[size - 1][0]) return curve[size - 1][1];

    for (int i = 0; i < size - 1; i++) {
        if (x >= curve[i][0] && x <= curve[i + 1][0]) {
            float t = (x - curve[i][0]) / (curve[i + 1][0] - curve[i][0]);
            float t2 = t * t;
            float t3 = t2 * t;

            float p0 = (i > 0) ? curve[i - 1][1] : curve[i][1];
            float p1 = curve[i][1];
            float p2 = curve[i + 1][1];
            float p3 = (i < size - 2) ? curve[i + 2][1] : curve[i + 1][1];

            return 0.5f * (
                (2.0f * p1) +
                (-p0 + p2) * t +
                (2.0f * p0 - 5.0f * p1 + 4.0f * p2 - p3) * t2 +
                (-p0 + 3.0f * p1 - 3.0f * p2 + p3) * t3
            );
        }
    }
    return 0.0f;
}

// ============================================================================
// PRESET CURVE DEFINITIONS
// ============================================================================

// Sat→Hue curves (saturation 0-1 → hue rotation in degrees)
__CONSTANT__ float sat_to_hue_NEUTRAL[][2] = {
    {0.0f, 0.0f},
    {1.0f, 0.0f}
};

__CONSTANT__ float sat_to_hue_ICONIC[][2] = {
    {0.0f, 0.0f},
    {0.5f, 0.0f},
    {1.0f, 15.0f}  // Rotate 15 degrees at max saturation (film hue loop)
};

// Lum→Hue curves (luminance 0-1 → hue rotation in degrees)
__CONSTANT__ float lum_to_hue_NEUTRAL[][2] = {
    {0.0f, 0.0f},
    {1.0f, 0.0f}
};

__CONSTANT__ float lum_to_hue_ICONIC[][2] = {
    {0.0f, -8.0f},   // Shadows cooler (-8 degrees)
    {0.18f, 0.0f},   // Middle grey neutral
    {1.0f, 12.0f}    // Highlights warmer (+12 degrees)
};

// Lum→Lum curves (input lum → output lum)
__CONSTANT__ float lum_to_lum_NEUTRAL[][2] = {
    {0.0f, 0.0f},
    {1.0f, 1.0f}
};

__CONSTANT__ float lum_to_lum_ICONIC[][2] = {
    {0.0f, 0.0f},
    {0.18f, 0.20f},
    {0.5f, 0.55f},
    {1.0f, 1.0f}
};

// ============================================================================
// MAIN TRANSFORM
// ============================================================================

__DEVICE__ float3 transform(int p_Width, int p_Height, int p_X, int p_Y, float p_R, float p_G, float p_B) {

    float3 rgb = make_float3(p_R, p_G, p_B);

    // ========================================================================
    // 1. LOG TO LINEAR (DaVinci Intermediate → Linear DWG)
    // ========================================================================
    rgb.x = oetf_davinci_intermediate(rgb.x, 1);
    rgb.y = oetf_davinci_intermediate(rgb.y, 1);
    rgb.z = oetf_davinci_intermediate(rgb.z, 1);

    // ========================================================================
    // 2. DWG → REC.709 (working space)
    // ========================================================================
    rgb = vdot(matrix_davinciwg_to_xyz, rgb);
    rgb = vdot(matrix_xyz_to_rec709, rgb);

    // ========================================================================
    // 3. SELECT PRESET CURVES
    // ========================================================================
    const float (*sat_to_hue)[2];
    const float (*lum_to_hue)[2];
    const float (*lum_to_lum)[2];
    int sat_to_hue_size, lum_to_hue_size, lum_to_lum_size; 
    if (preset == 0) { // NEUTRAL
        sat_to_hue = sat_to_hue_NEUTRAL; sat_to_hue_size = 2;
        lum_to_hue = lum_to_hue_NEUTRAL; lum_to_hue_size = 2;
        lum_to_lum = lum_to_lum_NEUTRAL; lum_to_lum_size = 2;
    } else { // ICONIC_FILM
        sat_to_hue = sat_to_hue_ICONIC; sat_to_hue_size = 3;
        lum_to_hue = lum_to_hue_ICONIC; lum_to_hue_size = 3;
        lum_to_lum = lum_to_lum_ICONIC; lum_to_lum_size = 4;
    }

    // ========================================================================
    // 4. INITIAL GAMUT COMPRESSION (before any hue operations)
    // ========================================================================
    if (enable_gamut_compression) {
        float3 rgb_copy = rgb;
        rgb = NonLinearGamutMappingPerChannel(rgb, gamut_compress_r, gamut_compress_g, gamut_compress_b, 0.0f, 1.0f);
        rgb = EnergyCorrection(rgb_copy, rgb, matrix_rec709_to_xyz);
    }

    // ========================================================================
    // 4b. CHANNEL CROSSTALK (film dye interaction)
    // ========================================================================
    if (enable_crosstalk) {
        float3 rgb_copy = rgb;
        float3x3 ct_matrix = crosstalkMatrix(crosstalk_rg, crosstalk_rb, crosstalk_gr, crosstalk_gb, crosstalk_br, crosstalk_bg);
        rgb = vdot(ct_matrix, rgb);
        rgb = EnergyCorrection(rgb_copy, rgb, matrix_rec709_to_xyz);
    }

    // ========================================================================
    // 4c. OVERALL RGB HUE ROTATION (JP_2499 style)
    // ========================================================================
    if (enable_overall_hue) {
        float3 rgb_copy = rgb;
        float3x3 hue_matrix = simpleHueMatrix(overall_hue_r, overall_hue_g, overall_hue_b);
        rgb = vdot(hue_matrix, rgb);
        rgb = EnergyCorrection(rgb_copy, rgb, matrix_rec709_to_xyz);
    }

    // ========================================================================
    // 5. OPPONENT SPACE HUE OPERATIONS
    // ========================================================================

    // Convert to opponent space
    float2 opp = opponent(rgb);
    float lum = (rgb.x + rgb.y + rgb.z) / 3.0f;  // Simple luminance

    // Calculate saturation (achromatic distance)
    float sat = achromatic_distance(opp);

    // Get hue zone weights (CMY - film negative primaries)
    float3 hue_weights = get_hue_zone_weights(opp);

    // SAT→HUE: Hue rotation based on saturation (global curve + per-hue-zone)
    if ((enable_sat_to_hue || enable_hue_zone_sat) && sat > 0.001f) {
        float hue_shift_deg = 0.0f;

        // Global curve contribution
        if (enable_sat_to_hue) {
            hue_shift_deg += cubic_spline_interpolate(sat, sat_to_hue, sat_to_hue_size);
        }

        // Per-hue-zone contribution (weighted by CMY zones)
        if (enable_hue_zone_sat) {
            hue_shift_deg += hue_weights.x * sat_hue_cyan +
                             hue_weights.y * sat_hue_magenta +
                             hue_weights.z * sat_hue_yellow;
        }

        if (_fabs(hue_shift_deg) > 0.01f) {
            const float DEG_TO_RAD = 3.14159265359f / 180.0f;
            opp = rotate_hue(opp, hue_shift_deg * DEG_TO_RAD);
        }
    }

    // LUM→HUE: Hue rotation based on luminance (curve + tripartite + per-hue-zone)
    if ((enable_lum_to_hue || enable_hue_zone_lum || _fabs(shadow_hue_shift) > 0.01f || _fabs(midtone_hue_shift) > 0.01f || _fabs(highlight_hue_shift) > 0.01f) && sat > 0.001f) {
        float hue_shift_deg = 0.0f;

        // Global curve contribution
        if (enable_lum_to_hue) {
            hue_shift_deg += cubic_spline_interpolate(lum, lum_to_hue, lum_to_hue_size);
        }

        // Tripartite slider contribution (shadow/midtone/highlight)
        // Smooth blending zones: shadow (0-0.18), midtone (0.18-0.5), highlight (0.5-1.0)
        if (lum < 0.18f) {
            // Shadow zone: full shadow shift, blend to midtone
            float shadow_weight = 1.0f - lum / 0.18f;
            float midtone_weight = lum / 0.18f;
            hue_shift_deg += shadow_hue_shift * shadow_weight + midtone_hue_shift * midtone_weight;
        } else if (lum < 0.5f) {
            // Midtone zone: blend from midtone to highlight
            float midtone_weight = (0.5f - lum) / (0.5f - 0.18f);
            float highlight_weight = (lum - 0.18f) / (0.5f - 0.18f);
            hue_shift_deg += midtone_hue_shift * midtone_weight + highlight_hue_shift * highlight_weight;
        } else {
            // Highlight zone: full highlight shift
            hue_shift_deg += highlight_hue_shift;
        }

        // Per-hue-zone contribution (weighted by CMY zones)
        if (enable_hue_zone_lum) {
            hue_shift_deg += hue_weights.x * lum_hue_cyan +
                             hue_weights.y * lum_hue_magenta +
                             hue_weights.z * lum_hue_yellow;
        }

        if (_fabs(hue_shift_deg) > 0.01f) {
            const float DEG_TO_RAD = 3.14159265359f / 180.0f;
            opp = rotate_hue(opp, hue_shift_deg * DEG_TO_RAD);
        }
    }

    // Convert back from opponent space to RGB
    rgb = opponent_to_rgb(opp, lum);

    // Safety clamp
    rgb = maxf3(0.0f, rgb);

    // ========================================================================
    // 7. ENCODE TO LOG FOR STORAGE (if log passthrough)
    // ========================================================================
    float3 log2499;
    log2499.x = oetf_davinci_intermediate(rgb.x, 0);
    log2499.y = oetf_davinci_intermediate(rgb.y, 0);
    log2499.z = oetf_davinci_intermediate(rgb.z, 0);

    if (output_mode == 0) { // LOG_PASSTHROUGH
        return log2499;
    }

    // ========================================================================
    // 8. DECODE FROM LOG (for display rendering)
    // ========================================================================
    rgb.x = oetf_davinci_intermediate(log2499.x, 1);
    rgb.y = oetf_davinci_intermediate(log2499.y, 1);
    rgb.z = oetf_davinci_intermediate(log2499.z, 1);

    rgb = maxf3(0.0f, rgb);

    // ========================================================================
    // 9. TOE/SHOULDER (tone mapping)
    // ========================================================================
    if (enable_toe_shoulder) {
        rgb = modifiedDanieleCurve(rgb, toe_mx, toe_my, toe_py, toe_gamma, 0.04f, 0);
    }

    // ========================================================================
    // 10. LUM→LUM CURVE (on linear RGB after tone mapping)
    // ========================================================================
    if (enable_lum_to_lum) {
        float3 weights = avgweights(matrix_rec709_to_xyz);
        float lum = weights.x * rgb.x + weights.y * rgb.y + weights.z * rgb.z;
        float lum_mapped = cubic_spline_interpolate(lum, lum_to_lum, lum_to_lum_size);

        if (lum > 0.0001f) {
            float ratio = lum_mapped / lum;
            rgb.x *= ratio;
            rgb.y *= ratio;
            rgb.z *= ratio;
        }
    }

    // ========================================================================
    // 11. PURITY (saturation adjustment)
    // ========================================================================
    if (enable_purity) {
        rgb = vdot(simpleInsetMatrix(purity_red / 10.0f, purity_green / 10.0f, purity_blue / 10.0f, 1), rgb);
    }

    // ========================================================================
    // 12. FINAL GAMUT COMPRESSION FOR DISPLAY
    // ========================================================================
    float3 rgb_copy = rgb;
    rgb = NonLinearGamutMapping(rgb, 0.01f, 0.0f, 1.0f);
    rgb = EnergyCorrection(rgb_copy, rgb, matrix_rec709_to_xyz);
    rgb = maxf3(0.0f, rgb);

    // Compress inverted values (for smooth rolloff near white)
    float3 linear_inv = make_float3(1.0f, 1.0f, 1.0f) - rgb;
    rgb_copy = linear_inv;
    linear_inv = NonLinearGamutMapping(linear_inv, 0.01f, 0.0f, 1.0f);
    linear_inv = EnergyCorrection(rgb_copy, linear_inv, matrix_rec709_to_xyz);
    rgb = make_float3(1.0f, 1.0f, 1.0f) - linear_inv;

    // ========================================================================
    // 13. OUTPUT GAMMA ENCODING
    // ========================================================================
    float3 out;

    if (output_mode == 1) { // REC709_GAMMA22
        out.x = _powf(rgb.x, 1.0f / 2.2f);
        out.y = _powf(rgb.y, 1.0f / 2.2f);
        out.z = _powf(rgb.z, 1.0f / 2.2f);
    } else if (output_mode == 2) { // REC709_GAMMA24
        out.x = _powf(rgb.x, 1.0f / 2.4f);
        out.y = _powf(rgb.y, 1.0f / 2.4f);
        out.z = _powf(rgb.z, 1.0f / 2.4f);
    } else { // SRGB
        out.x = (rgb.x <= 0.0031308f) ? rgb.x * 12.92f : 1.055f * _powf(rgb.x, 1.0f / 2.4f) - 0.055f;
        out.y = (rgb.y <= 0.0031308f) ? rgb.y * 12.92f : 1.055f * _powf(rgb.y, 1.0f / 2.4f) - 0.055f;
        out.z = (rgb.z <= 0.0031308f) ? rgb.z * 12.92f : 1.055f * _powf(rgb.z, 1.0f / 2.4f) - 0.055f;
    }

    return out;
}
